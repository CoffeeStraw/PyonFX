{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to the PyonFX library website!","text":"<p>\"PyonFX is an easy way to create KFX (Karaoke Effects) and complex typesetting using the ASS format (Advanced Substation Alpha).\"</p> <p></p>"},{"location":"#what-is-pyonfx","title":"What is PyonFX?","text":"<p>PyonFX is a Python library designed to make the creation of KFX and complex typesetting easy when working with the ASS (Advanced Substation Alpha) subtitle format. It provides creators with precise, programmatic control over visual effects by allowing detailed manipulation of tags, text, and shapes \u2014 extending down to the frame-by-frame and pixel-by-pixel level.</p>"},{"location":"#key-features-at-a-glance","title":"Key features at a glance","text":"<ul> <li>High-level dataclasses: parse .ass file into structured objects (<code>Meta</code>, <code>Style</code>, <code>Line</code>, <code>Word</code>, <code>Syllable</code>, <code>Char</code>), incorporating font metrics and temporal/positional data;</li> <li>Shape manipulation:<ul> <li>Create: generate shape objects from geometric primitives (triangle, square, heart, etc.) or custom drawing commands;</li> <li>Transform: precisely map, move, align, scale, rotate, and skew shapes;</li> <li>Advanced editing: supports B\u00e9zier curve flattening and line segmentation for granular shape control;</li> <li>Buffer: expand, contract, or extract outlines from shapes;</li> <li>Morph: morph smoothly between 2 individual shapes or 2 collections of shapes;</li> </ul> </li> <li>Frame-by-frame: work at the individual frame level, with support for timestamp-based editing (ideal for handling CFR and VFR videos) and built-in utilities to automatically interpolate values between key frames using Penner's easing functions;</li> <li>Pixel-by-pixel: rasterize text or shapes for direct pixel access, and mask them with images;</li> <li>Colour utilities: make your KFX lines change seamlessly based on video content, and work with HSV, OKLab, RGB, and ASS color spaces;</li> <li>Live preview: integrate with MPV for real-time previewing. Changes to scripts are reflected on reload, allowing workflows independent of traditional Aegisub-based previews;</li> <li>Performance tracker: monitor runtime performance and generated line count;</li> <li>Cross-platform availability: install it via <code>pip</code> on Windows, macOS and Linux;</li> <li>Comprehensive examples and community: offers over <code>TBD</code> example scripts, and is supported by an active community of users.</li> </ul>"},{"location":"#explore-the-documentation","title":"Explore the documentation","text":"Section Purpose Tutorials Step-by-step projects that teach you the basics and beyond. Guides Short \u201cHow do I\u2026?\u201d recipes for specific tasks. Reference Auto-generated API for every public class and function. Explanation Deep dives into the library\u2019s architecture and algorithms. <p>Happy KFX and typesetting making \u2014 and welcome to the community! \ud83c\udf89</p>"},{"location":"reference/","title":"API reference","text":"<p>This reference manual describes all the classes and functions provided by the library. It is terse, but attempts to be exact and complete.</p> <p>Start exploring using the sidebar or the links below:</p> <ul> <li>ass_core</li> <li>convert</li> <li>pixel</li> <li>shape</li> <li>utils</li> </ul>"},{"location":"reference/ass_core/","title":"ASS Core","text":""},{"location":"reference/ass_core/#pyonfx.ass_core.Meta","title":"<code>Meta</code>  <code>dataclass</code>","text":"<p>Encapsulates the script properties of an ASS file, including video resolution, wrap style, and media file paths.</p> <p>Attributes:</p> Name Type Description <code>wrap_style</code> <code>int | None</code> <p>Specifies the wrap style for subtitles. The typical value 0 indicates smart wrapping.</p> <code>scaled_border_and_shadow</code> <code>bool | None</code> <p>Determines whether border and shadow sizes are scaled according to the script resolution (True) or the video resolution (False).</p> <code>play_res_x</code> <code>int | None</code> <p>Specifies the script's video width resolution in pixels. This influences horizontal coordinate calculations.</p> <code>play_res_y</code> <code>int | None</code> <p>Specifies the script's video height resolution in pixels. This influences vertical coordinate calculations.</p> <code>audio</code> <code>str | None</code> <p>Absolute file path to the associated audio file.</p> <code>video</code> <code>str | None</code> <p>Absolute file path to the associated video file.</p> Source code in <code>pyonfx/ass_core.py</code> <pre><code>@dataclass(slots=True)\nclass Meta:\n    \"\"\"Encapsulates the script properties of an ASS file, including video resolution, wrap style, and media file paths.\n\n    Attributes:\n        wrap_style: Specifies the wrap style for subtitles. The typical value 0 indicates smart wrapping.\n        scaled_border_and_shadow: Determines whether border and shadow sizes are scaled according to the script resolution (True) or the video resolution (False).\n        play_res_x: Specifies the script's video width resolution in pixels. This influences horizontal coordinate calculations.\n        play_res_y: Specifies the script's video height resolution in pixels. This influences vertical coordinate calculations.\n        audio: Absolute file path to the associated audio file.\n        video: Absolute file path to the associated video file.\n    \"\"\"\n\n    wrap_style: int | None\n    scaled_border_and_shadow: bool | None\n    play_res_x: int | None\n    play_res_y: int | None\n    audio: str | None\n    video: str | None\n    timestamps: ABCTimestamps | None\n\n    def parse_line(self, line: str, ass_path: str) -&gt; str:\n        \"\"\"Parses a single ASS line and update the relevant fields.\"\"\"\n        line = line.strip()\n\n        if not line:\n            pass\n        elif match := re.match(r\"WrapStyle:\\s*(\\d+)$\", line):\n            self.wrap_style = int(match.group(1))\n        elif match := re.match(r\"ScaledBorderAndShadow:\\s*(.+)$\", line):\n            self.scaled_border_and_shadow = match.group(1).strip().lower() == \"yes\"\n        elif match := re.match(r\"PlayResX:\\s*(\\d+)$\", line):\n            self.play_res_x = int(match.group(1))\n        elif match := re.match(r\"PlayResY:\\s*(\\d+)$\", line):\n            self.play_res_y = int(match.group(1))\n        elif match := re.match(r\"Audio File:\\s*(.*)$\", line):\n            self.audio = _resolve_path(ass_path, match.group(1).strip())\n            line = f\"Audio File: {self.audio}\"\n        elif match := re.match(r\"Video File:\\s*(.*)$\", line):\n            # Parse video file path\n            match_group = str(match.group(1)).strip()\n            is_dummy = match_group.startswith(\"?dummy\")\n            self.video = (\n                match_group if is_dummy else _resolve_path(ass_path, match_group)\n            )\n\n            line = f\"Video File: {self.video}\"\n\n            # Set up timestamps based on video file\n            if os.path.isfile(self.video):\n                self.timestamps = VideoTimestamps.from_video_file(Path(self.video))\n            elif is_dummy:\n                # Parse dummy video format: ?dummy:fps:duration\n                parts = self.video.split(\":\")\n                if len(parts) &gt;= 2:\n                    fps_str = parts[1]\n                    fps = Fraction(fps_str)\n                    self.timestamps = FPSTimestamps(\n                        RoundingMethod.ROUND, Fraction(1000), fps, Fraction(0)  # type: ignore[attr-defined]\n                    )\n\n        return line + \"\\n\"\n\n    def serialize(self) -&gt; tuple[list[str], list[str]]:\n        \"\"\"Serializes the meta object into ASS script info and garbage sections.\"\"\"\n        script_info_lines = []\n        if self.wrap_style is not None:\n            script_info_lines.append(f\"WrapStyle: {self.wrap_style}\")\n        if self.scaled_border_and_shadow is not None:\n            script_info_lines.append(\n                f\"ScaledBorderAndShadow: {'Yes' if self.scaled_border_and_shadow else 'No'}\"\n            )\n        if self.play_res_x is not None:\n            script_info_lines.append(f\"PlayResX: {self.play_res_x}\")\n        if self.play_res_y is not None:\n            script_info_lines.append(f\"PlayResY: {self.play_res_y}\")\n\n        # Append a newline to each Script Info line\n        script_info_lines = [f\"{line}\\n\" for line in script_info_lines]\n\n        garbage_lines = []\n        if self.audio is not None:\n            garbage_lines.append(f\"Audio File: {self.audio}\")\n        if self.video is not None:\n            garbage_lines.append(f\"Video File: {self.video}\")\n\n        # Append a newline to each Aegisub Project Garbage line\n        garbage_lines = [f\"{line}\\n\" for line in garbage_lines]\n\n        return script_info_lines, garbage_lines\n</code></pre>"},{"location":"reference/ass_core/#pyonfx.ass_core.Meta.parse_line","title":"<code>parse_line(line, ass_path)</code>","text":"<p>Parses a single ASS line and update the relevant fields.</p> Source code in <code>pyonfx/ass_core.py</code> <pre><code>def parse_line(self, line: str, ass_path: str) -&gt; str:\n    \"\"\"Parses a single ASS line and update the relevant fields.\"\"\"\n    line = line.strip()\n\n    if not line:\n        pass\n    elif match := re.match(r\"WrapStyle:\\s*(\\d+)$\", line):\n        self.wrap_style = int(match.group(1))\n    elif match := re.match(r\"ScaledBorderAndShadow:\\s*(.+)$\", line):\n        self.scaled_border_and_shadow = match.group(1).strip().lower() == \"yes\"\n    elif match := re.match(r\"PlayResX:\\s*(\\d+)$\", line):\n        self.play_res_x = int(match.group(1))\n    elif match := re.match(r\"PlayResY:\\s*(\\d+)$\", line):\n        self.play_res_y = int(match.group(1))\n    elif match := re.match(r\"Audio File:\\s*(.*)$\", line):\n        self.audio = _resolve_path(ass_path, match.group(1).strip())\n        line = f\"Audio File: {self.audio}\"\n    elif match := re.match(r\"Video File:\\s*(.*)$\", line):\n        # Parse video file path\n        match_group = str(match.group(1)).strip()\n        is_dummy = match_group.startswith(\"?dummy\")\n        self.video = (\n            match_group if is_dummy else _resolve_path(ass_path, match_group)\n        )\n\n        line = f\"Video File: {self.video}\"\n\n        # Set up timestamps based on video file\n        if os.path.isfile(self.video):\n            self.timestamps = VideoTimestamps.from_video_file(Path(self.video))\n        elif is_dummy:\n            # Parse dummy video format: ?dummy:fps:duration\n            parts = self.video.split(\":\")\n            if len(parts) &gt;= 2:\n                fps_str = parts[1]\n                fps = Fraction(fps_str)\n                self.timestamps = FPSTimestamps(\n                    RoundingMethod.ROUND, Fraction(1000), fps, Fraction(0)  # type: ignore[attr-defined]\n                )\n\n    return line + \"\\n\"\n</code></pre>"},{"location":"reference/ass_core/#pyonfx.ass_core.Meta.serialize","title":"<code>serialize()</code>","text":"<p>Serializes the meta object into ASS script info and garbage sections.</p> Source code in <code>pyonfx/ass_core.py</code> <pre><code>def serialize(self) -&gt; tuple[list[str], list[str]]:\n    \"\"\"Serializes the meta object into ASS script info and garbage sections.\"\"\"\n    script_info_lines = []\n    if self.wrap_style is not None:\n        script_info_lines.append(f\"WrapStyle: {self.wrap_style}\")\n    if self.scaled_border_and_shadow is not None:\n        script_info_lines.append(\n            f\"ScaledBorderAndShadow: {'Yes' if self.scaled_border_and_shadow else 'No'}\"\n        )\n    if self.play_res_x is not None:\n        script_info_lines.append(f\"PlayResX: {self.play_res_x}\")\n    if self.play_res_y is not None:\n        script_info_lines.append(f\"PlayResY: {self.play_res_y}\")\n\n    # Append a newline to each Script Info line\n    script_info_lines = [f\"{line}\\n\" for line in script_info_lines]\n\n    garbage_lines = []\n    if self.audio is not None:\n        garbage_lines.append(f\"Audio File: {self.audio}\")\n    if self.video is not None:\n        garbage_lines.append(f\"Video File: {self.video}\")\n\n    # Append a newline to each Aegisub Project Garbage line\n    garbage_lines = [f\"{line}\\n\" for line in garbage_lines]\n\n    return script_info_lines, garbage_lines\n</code></pre>"},{"location":"reference/ass_core/#pyonfx.ass_core.Style","title":"<code>Style</code>  <code>dataclass</code>","text":"<p>Represents a typographic style for ASS subtitles.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Unique identifier for the style.</p> <code>fontname</code> <code>str</code> <p>Typeface used for the subtitles.</p> <code>fontsize</code> <code>float</code> <p>Font size in points.</p> <code>color1</code> <code>str</code> <p>Primary fill color, typically in hexadecimal format.</p> <code>alpha1</code> <code>str</code> <p>Transparency (alpha channel) for the primary fill color.</p> <code>color2</code> <code>str</code> <p>Secondary color used for karaoke effects.</p> <code>alpha2</code> <code>str</code> <p>Transparency for the secondary color.</p> <code>color3</code> <code>str</code> <p>Outline (border) color.</p> <code>alpha3</code> <code>str</code> <p>Transparency for the outline color.</p> <code>color4</code> <code>str</code> <p>Shadow color.</p> <code>alpha4</code> <code>str</code> <p>Transparency for the shadow color.</p> <code>bold</code> <code>bool</code> <p>Indicates if the font is italic.</p> <code>italic</code> <code>bool</code> <p>Indicates if the font is italic.</p> <code>underline</code> <code>bool</code> <p>Indicates if the text is underlined.</p> <code>strikeout</code> <code>bool</code> <p>Indicates if the text has a strike-through effect.</p> <code>scale_x</code> <code>float</code> <p>Horizontal scaling factor as a percentage (100 means no scaling).</p> <code>scale_y</code> <code>float</code> <p>Vertical scaling factor as a percentage (100 means no scaling).</p> <code>spacing</code> <code>float</code> <p>Additional horizontal spacing between letters in pixels.</p> <code>angle</code> <code>float</code> <p>Rotation angle of the text in degrees.</p> <code>border_style</code> <code>bool</code> <p>Specifies the border style: True for an opaque box, False for a standard outline.</p> <code>outline</code> <code>float</code> <p>Outline thickness in pixels.</p> <code>shadow</code> <code>float</code> <p>Shadow offset distance in pixels.</p> <code>alignment</code> <code>int</code> <p>ASS alignment code (typically an integer from 1 to 9).</p> <code>margin_l</code> <code>int</code> <p>Left margin in pixels.</p> <code>margin_r</code> <code>int</code> <p>Right margin in pixels.</p> <code>margin_v</code> <code>int</code> <p>Vertical margin in pixels; determines vertical positioning relative to the video frame.</p> <code>encoding</code> <code>int</code> <p>Font encoding/codepage. The value 1 is standard, allowing the selection of any installed font.</p> Source code in <code>pyonfx/ass_core.py</code> <pre><code>@dataclass(slots=True)\nclass Style:\n    \"\"\"Represents a typographic style for ASS subtitles.\n\n    Attributes:\n        name: Unique identifier for the style.\n        fontname: Typeface used for the subtitles.\n        fontsize: Font size in points.\n        color1: Primary fill color, typically in hexadecimal format.\n        alpha1: Transparency (alpha channel) for the primary fill color.\n        color2: Secondary color used for karaoke effects.\n        alpha2: Transparency for the secondary color.\n        color3: Outline (border) color.\n        alpha3: Transparency for the outline color.\n        color4: Shadow color.\n        alpha4: Transparency for the shadow color.\n        bold: Indicates if the font is italic.\n        italic: Indicates if the font is italic.\n        underline: Indicates if the text is underlined.\n        strikeout: Indicates if the text has a strike-through effect.\n        scale_x: Horizontal scaling factor as a percentage (100 means no scaling).\n        scale_y: Vertical scaling factor as a percentage (100 means no scaling).\n        spacing: Additional horizontal spacing between letters in pixels.\n        angle: Rotation angle of the text in degrees.\n        border_style: Specifies the border style: True for an opaque box, False for a standard outline.\n        outline: Outline thickness in pixels.\n        shadow: Shadow offset distance in pixels.\n        alignment: ASS alignment code (typically an integer from 1 to 9).\n        margin_l: Left margin in pixels.\n        margin_r: Right margin in pixels.\n        margin_v: Vertical margin in pixels; determines vertical positioning relative to the video frame.\n        encoding: Font encoding/codepage. The value 1 is standard, allowing the selection of any installed font.\n    \"\"\"\n\n    name: str\n    fontname: str\n    fontsize: float\n    color1: str\n    alpha1: str\n    color2: str\n    alpha2: str\n    color3: str\n    alpha3: str\n    color4: str\n    alpha4: str\n    bold: bool\n    italic: bool\n    underline: bool\n    strikeout: bool\n    scale_x: float\n    scale_y: float\n    spacing: float\n    angle: float\n    border_style: bool\n    outline: float\n    shadow: float\n    alignment: int\n    margin_l: int\n    margin_r: int\n    margin_v: int\n    encoding: int\n\n    @classmethod\n    def from_ass_line(cls, line: str) -&gt; \"Style\":\n        \"\"\"Parse a single ASS line and return the corresponding Style object.\"\"\"\n        style_match = re.match(r\"Style:\\s*(.+)$\", line)\n        if not style_match:\n            raise ValueError(f\"Invalid style line: {line}\")\n\n        # Parse style fields\n        #   Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour,\n        #   Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle,\n        #   BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding\n        style_fields = [field.strip() for field in style_match.group(1).split(\",\")]\n\n        return cls(\n            name=style_fields[0],\n            fontname=style_fields[1],\n            fontsize=float(style_fields[2]),\n            color1=f\"&amp;H{style_fields[3][4:]}&amp;\",\n            alpha1=f\"{style_fields[3][:4]}&amp;\",\n            color2=f\"&amp;H{style_fields[4][4:]}&amp;\",\n            alpha2=f\"{style_fields[4][:4]}&amp;\",\n            color3=f\"&amp;H{style_fields[5][4:]}&amp;\",\n            alpha3=f\"{style_fields[5][:4]}&amp;\",\n            color4=f\"&amp;H{style_fields[6][4:]}&amp;\",\n            alpha4=f\"{style_fields[6][:4]}&amp;\",\n            bold=style_fields[7] == \"-1\",\n            italic=style_fields[8] == \"-1\",\n            underline=style_fields[9] == \"-1\",\n            strikeout=style_fields[10] == \"-1\",\n            scale_x=float(style_fields[11]),\n            scale_y=float(style_fields[12]),\n            spacing=float(style_fields[13]),\n            angle=float(style_fields[14]),\n            border_style=style_fields[15] == \"3\",\n            outline=float(style_fields[16]),\n            shadow=float(style_fields[17]),\n            alignment=int(style_fields[18]),\n            margin_l=int(style_fields[19]),\n            margin_r=int(style_fields[20]),\n            margin_v=int(style_fields[21]),\n            encoding=int(style_fields[22]),\n        )\n\n    def serialize(self, style_name: str) -&gt; str:\n        \"\"\"Serialize a Style object into an ASS style line.\"\"\"\n        bold = \"-1\" if self.bold else \"0\"\n        italic = \"-1\" if self.italic else \"0\"\n        underline = \"-1\" if self.underline else \"0\"\n        strikeout = \"-1\" if self.strikeout else \"0\"\n        border = \"3\" if self.border_style else \"1\"\n        fontsize = (\n            str(int(self.fontsize))\n            if self.fontsize == int(self.fontsize)\n            else str(self.fontsize)\n        )\n        scale_x = (\n            str(int(self.scale_x))\n            if self.scale_x == int(self.scale_x)\n            else str(self.scale_x)\n        )\n        scale_y = (\n            str(int(self.scale_y))\n            if self.scale_y == int(self.scale_y)\n            else str(self.scale_y)\n        )\n        spacing = (\n            str(int(self.spacing))\n            if self.spacing == int(self.spacing)\n            else str(self.spacing)\n        )\n        angle = (\n            str(int(self.angle)) if self.angle == int(self.angle) else str(self.angle)\n        )\n        outline_width = (\n            str(int(self.outline))\n            if self.outline == int(self.outline)\n            else str(self.outline)\n        )\n        shadow = (\n            str(int(self.shadow))\n            if self.shadow == int(self.shadow)\n            else str(self.shadow)\n        )\n        primary = f\"&amp;H{self.alpha1}{self.color1}\"\n        secondary = f\"&amp;H{self.alpha2}{self.color2}\"\n        outline_col = f\"&amp;H{self.alpha3}{self.color3}\"\n        back = f\"&amp;H{self.alpha4}{self.color4}\"\n        style_line = (\n            f\"Style: {style_name},{self.fontname},{fontsize},{primary},{secondary},\"\n            f\"{outline_col},{back},{bold},{italic},{underline},{strikeout},\"\n            f\"{scale_x},{scale_y},{spacing},{angle},{border},{outline_width},\"\n            f\"{shadow},{self.alignment},{self.margin_l},{self.margin_r},\"\n            f\"{self.margin_v},{self.encoding}\\n\"\n        )\n        return style_line\n</code></pre>"},{"location":"reference/ass_core/#pyonfx.ass_core.Style.from_ass_line","title":"<code>from_ass_line(line)</code>  <code>classmethod</code>","text":"<p>Parse a single ASS line and return the corresponding Style object.</p> Source code in <code>pyonfx/ass_core.py</code> <pre><code>@classmethod\ndef from_ass_line(cls, line: str) -&gt; \"Style\":\n    \"\"\"Parse a single ASS line and return the corresponding Style object.\"\"\"\n    style_match = re.match(r\"Style:\\s*(.+)$\", line)\n    if not style_match:\n        raise ValueError(f\"Invalid style line: {line}\")\n\n    # Parse style fields\n    #   Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour,\n    #   Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle,\n    #   BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding\n    style_fields = [field.strip() for field in style_match.group(1).split(\",\")]\n\n    return cls(\n        name=style_fields[0],\n        fontname=style_fields[1],\n        fontsize=float(style_fields[2]),\n        color1=f\"&amp;H{style_fields[3][4:]}&amp;\",\n        alpha1=f\"{style_fields[3][:4]}&amp;\",\n        color2=f\"&amp;H{style_fields[4][4:]}&amp;\",\n        alpha2=f\"{style_fields[4][:4]}&amp;\",\n        color3=f\"&amp;H{style_fields[5][4:]}&amp;\",\n        alpha3=f\"{style_fields[5][:4]}&amp;\",\n        color4=f\"&amp;H{style_fields[6][4:]}&amp;\",\n        alpha4=f\"{style_fields[6][:4]}&amp;\",\n        bold=style_fields[7] == \"-1\",\n        italic=style_fields[8] == \"-1\",\n        underline=style_fields[9] == \"-1\",\n        strikeout=style_fields[10] == \"-1\",\n        scale_x=float(style_fields[11]),\n        scale_y=float(style_fields[12]),\n        spacing=float(style_fields[13]),\n        angle=float(style_fields[14]),\n        border_style=style_fields[15] == \"3\",\n        outline=float(style_fields[16]),\n        shadow=float(style_fields[17]),\n        alignment=int(style_fields[18]),\n        margin_l=int(style_fields[19]),\n        margin_r=int(style_fields[20]),\n        margin_v=int(style_fields[21]),\n        encoding=int(style_fields[22]),\n    )\n</code></pre>"},{"location":"reference/ass_core/#pyonfx.ass_core.Style.serialize","title":"<code>serialize(style_name)</code>","text":"<p>Serialize a Style object into an ASS style line.</p> Source code in <code>pyonfx/ass_core.py</code> <pre><code>def serialize(self, style_name: str) -&gt; str:\n    \"\"\"Serialize a Style object into an ASS style line.\"\"\"\n    bold = \"-1\" if self.bold else \"0\"\n    italic = \"-1\" if self.italic else \"0\"\n    underline = \"-1\" if self.underline else \"0\"\n    strikeout = \"-1\" if self.strikeout else \"0\"\n    border = \"3\" if self.border_style else \"1\"\n    fontsize = (\n        str(int(self.fontsize))\n        if self.fontsize == int(self.fontsize)\n        else str(self.fontsize)\n    )\n    scale_x = (\n        str(int(self.scale_x))\n        if self.scale_x == int(self.scale_x)\n        else str(self.scale_x)\n    )\n    scale_y = (\n        str(int(self.scale_y))\n        if self.scale_y == int(self.scale_y)\n        else str(self.scale_y)\n    )\n    spacing = (\n        str(int(self.spacing))\n        if self.spacing == int(self.spacing)\n        else str(self.spacing)\n    )\n    angle = (\n        str(int(self.angle)) if self.angle == int(self.angle) else str(self.angle)\n    )\n    outline_width = (\n        str(int(self.outline))\n        if self.outline == int(self.outline)\n        else str(self.outline)\n    )\n    shadow = (\n        str(int(self.shadow))\n        if self.shadow == int(self.shadow)\n        else str(self.shadow)\n    )\n    primary = f\"&amp;H{self.alpha1}{self.color1}\"\n    secondary = f\"&amp;H{self.alpha2}{self.color2}\"\n    outline_col = f\"&amp;H{self.alpha3}{self.color3}\"\n    back = f\"&amp;H{self.alpha4}{self.color4}\"\n    style_line = (\n        f\"Style: {style_name},{self.fontname},{fontsize},{primary},{secondary},\"\n        f\"{outline_col},{back},{bold},{italic},{underline},{strikeout},\"\n        f\"{scale_x},{scale_y},{spacing},{angle},{border},{outline_width},\"\n        f\"{shadow},{self.alignment},{self.margin_l},{self.margin_r},\"\n        f\"{self.margin_v},{self.encoding}\\n\"\n    )\n    return style_line\n</code></pre>"},{"location":"reference/ass_core/#pyonfx.ass_core.Char","title":"<code>Char</code>  <code>dataclass</code>","text":"<p>Represents a single character within a subtitle line.</p> <p>Attributes:</p> Name Type Description <code>i</code> <code>int</code> <p>Zero-based index of the character within the line.</p> <code>word_i</code> <code>int</code> <p>Index of the word to which this character belongs.</p> <code>syl_i</code> <code>int</code> <p>Index of the syllable to which this character belongs.</p> <code>syl_char_i</code> <code>int</code> <p>Index of the character within its parent syllable.</p> <code>start_time</code> <code>int</code> <p>Start time in milliseconds when the character appears.</p> <code>end_time</code> <code>int</code> <p>End time in milliseconds when the character disappears.</p> <code>duration</code> <code>int</code> <p>Duration in milliseconds, computed as end_time - start_time.</p> <code>styleref</code> <code>Style</code> <p>Reference to the Style object used for formatting this character.</p> <code>text</code> <code>str</code> <p>The actual character as a string.</p> <code>inline_fx</code> <code>str</code> <p>Inline effects specified for this character (derived from -EFFECT tag).</p> <code>width</code> <code>float</code> <p>Width of the character in pixels.</p> <code>height</code> <code>float</code> <p>Height of the character in pixels.</p> <code>x</code> <code>float</code> <p>Horizontal position (x-coordinate in pixels).</p> <code>y</code> <code>float</code> <p>Vertical position (y-coordinate in pixels).</p> <code>left</code> <code>float</code> <p>Left boundary (in pixels).</p> <code>center</code> <code>float</code> <p>Horizontal center position (in pixels).</p> <code>right</code> <code>float</code> <p>Right boundary (in pixels).</p> <code>top</code> <code>float</code> <p>Top boundary (in pixels).</p> <code>middle</code> <code>float</code> <p>Vertical center position (in pixels).</p> <code>bottom</code> <code>float</code> <p>Bottom boundary (in pixels).</p> Source code in <code>pyonfx/ass_core.py</code> <pre><code>@dataclass(slots=True)\nclass Char:\n    \"\"\"Represents a single character within a subtitle line.\n\n    Attributes:\n        i: Zero-based index of the character within the line.\n        word_i: Index of the word to which this character belongs.\n        syl_i: Index of the syllable to which this character belongs.\n        syl_char_i: Index of the character within its parent syllable.\n        start_time: Start time in milliseconds when the character appears.\n        end_time: End time in milliseconds when the character disappears.\n        duration: Duration in milliseconds, computed as end_time - start_time.\n        styleref: Reference to the Style object used for formatting this character.\n        text: The actual character as a string.\n        inline_fx: Inline effects specified for this character (derived from \\\\-EFFECT tag).\n        width: Width of the character in pixels.\n        height: Height of the character in pixels.\n        x: Horizontal position (x-coordinate in pixels).\n        y: Vertical position (y-coordinate in pixels).\n        left: Left boundary (in pixels).\n        center: Horizontal center position (in pixels).\n        right: Right boundary (in pixels).\n        top: Top boundary (in pixels).\n        middle: Vertical center position (in pixels).\n        bottom: Bottom boundary (in pixels).\n    \"\"\"\n\n    i: int\n    word_i: int\n    syl_i: int\n    syl_char_i: int\n    start_time: int\n    end_time: int\n    styleref: Style\n    text: str\n    inline_fx: str\n    width: float\n    height: float\n    x: float\n    y: float\n    left: float\n    center: float\n    right: float\n    top: float\n    middle: float\n    bottom: float\n\n    @property\n    def duration(self) -&gt; int:\n        return self.end_time - self.start_time\n\n    def __repr__(self):\n        return _pretty_print(self)\n</code></pre>"},{"location":"reference/ass_core/#pyonfx.ass_core.Syllable","title":"<code>Syllable</code>  <code>dataclass</code>","text":"<p>Represents a syllable within a subtitle line.</p> <p>Attributes:</p> Name Type Description <code>i</code> <code>int</code> <p>Zero-based index of the syllable within the line.</p> <code>word_i</code> <code>int</code> <p>Index of the word that contains this syllable.</p> <code>start_time</code> <code>int</code> <p>Start time in milliseconds when the syllable begins.</p> <code>end_time</code> <code>int</code> <p>End time in milliseconds when the syllable ends.</p> <code>duration</code> <code>int</code> <p>Duration in milliseconds, computed as end_time - start_time.</p> <code>styleref</code> <code>Style</code> <p>Reference to the Style object used for formatting this syllable.</p> <code>text</code> <code>str</code> <p>Text content of the syllable.</p> <code>tags</code> <code>str</code> <p>ASS override tags preceding the syllable text (excluding \\k tags).</p> <code>inline_fx</code> <code>str</code> <p>Inline effects for the syllable (derived from -EFFECT tag).</p> <code>prespace</code> <code>int</code> <p>Number of leading spaces before the syllable.</p> <code>postspace</code> <code>int</code> <p>Number of trailing spaces after the syllable.</p> <code>width</code> <code>float</code> <p>Width of the syllable in pixels.</p> <code>height</code> <code>float</code> <p>Height of the syllable in pixels.</p> <code>x</code> <code>float</code> <p>Horizontal position (x-coordinate in pixels).</p> <code>y</code> <code>float</code> <p>Vertical position (y-coordinate in pixels).</p> <code>left</code> <code>float</code> <p>Left boundary (in pixels).</p> <code>center</code> <code>float</code> <p>Horizontal center position (in pixels).</p> <code>right</code> <code>float</code> <p>Right boundary (in pixels).</p> <code>top</code> <code>float</code> <p>Top boundary (in pixels).</p> <code>middle</code> <code>float</code> <p>Vertical center position (in pixels).</p> <code>bottom</code> <code>float</code> <p>Bottom boundary (in pixels).</p> Source code in <code>pyonfx/ass_core.py</code> <pre><code>@dataclass(slots=True)\nclass Syllable:\n    \"\"\"Represents a syllable within a subtitle line.\n\n    Attributes:\n        i: Zero-based index of the syllable within the line.\n        word_i: Index of the word that contains this syllable.\n        start_time: Start time in milliseconds when the syllable begins.\n        end_time: End time in milliseconds when the syllable ends.\n        duration: Duration in milliseconds, computed as end_time - start_time.\n        styleref: Reference to the Style object used for formatting this syllable.\n        text: Text content of the syllable.\n        tags: ASS override tags preceding the syllable text (excluding \\\\k tags).\n        inline_fx: Inline effects for the syllable (derived from \\\\-EFFECT tag).\n        prespace: Number of leading spaces before the syllable.\n        postspace: Number of trailing spaces after the syllable.\n        width: Width of the syllable in pixels.\n        height: Height of the syllable in pixels.\n        x: Horizontal position (x-coordinate in pixels).\n        y: Vertical position (y-coordinate in pixels).\n        left: Left boundary (in pixels).\n        center: Horizontal center position (in pixels).\n        right: Right boundary (in pixels).\n        top: Top boundary (in pixels).\n        middle: Vertical center position (in pixels).\n        bottom: Bottom boundary (in pixels).\n    \"\"\"\n\n    i: int\n    word_i: int\n    start_time: int\n    end_time: int\n    styleref: Style\n    text: str\n    tags: str\n    inline_fx: str\n    prespace: int\n    postspace: int\n    width: float\n    height: float\n    x: float\n    y: float\n    left: float\n    center: float\n    right: float\n    top: float\n    middle: float\n    bottom: float\n\n    @property\n    def duration(self) -&gt; int:\n        return self.end_time - self.start_time\n\n    def __repr__(self):\n        return _pretty_print(self)\n</code></pre>"},{"location":"reference/ass_core/#pyonfx.ass_core.Word","title":"<code>Word</code>  <code>dataclass</code>","text":"<p>Represents a word within a subtitle line.</p> <p>Attributes:</p> Name Type Description <code>i</code> <code>int</code> <p>Zero-based index of the word within the line.</p> <code>start_time</code> <code>int</code> <p>Start time in milliseconds for the word (typically matching the line's start time).</p> <code>end_time</code> <code>int</code> <p>End time in milliseconds for the word (typically matching the line's end time).</p> <code>duration</code> <code>int</code> <p>Duration in milliseconds, computed as end_time - start_time.</p> <code>styleref</code> <code>Style</code> <p>Reference to the Style object for this word.</p> <code>text</code> <code>str</code> <p>Text content of the word.</p> <code>prespace</code> <code>int</code> <p>Number of leading spaces before the word.</p> <code>postspace</code> <code>int</code> <p>Number of trailing spaces after the word.</p> <code>width</code> <code>float</code> <p>Width of the word in pixels.</p> <code>height</code> <code>float</code> <p>Height of the word in pixels.</p> <code>x</code> <code>float</code> <p>Horizontal position (x-coordinate in pixels).</p> <code>y</code> <code>float</code> <p>Vertical position (y-coordinate in pixels).</p> <code>left</code> <code>float</code> <p>Left boundary (in pixels).</p> <code>center</code> <code>float</code> <p>Horizontal center position (in pixels).</p> <code>right</code> <code>float</code> <p>Right boundary (in pixels).</p> <code>top</code> <code>float</code> <p>Top boundary (in pixels).</p> <code>middle</code> <code>float</code> <p>Vertical center position (in pixels).</p> <code>bottom</code> <code>float</code> <p>Bottom boundary (in pixels).</p> Source code in <code>pyonfx/ass_core.py</code> <pre><code>@dataclass(slots=True)\nclass Word:\n    \"\"\"Represents a word within a subtitle line.\n\n    Attributes:\n        i: Zero-based index of the word within the line.\n        start_time: Start time in milliseconds for the word (typically matching the line's start time).\n        end_time: End time in milliseconds for the word (typically matching the line's end time).\n        duration: Duration in milliseconds, computed as end_time - start_time.\n        styleref: Reference to the Style object for this word.\n        text: Text content of the word.\n        prespace: Number of leading spaces before the word.\n        postspace: Number of trailing spaces after the word.\n        width: Width of the word in pixels.\n        height: Height of the word in pixels.\n        x: Horizontal position (x-coordinate in pixels).\n        y: Vertical position (y-coordinate in pixels).\n        left: Left boundary (in pixels).\n        center: Horizontal center position (in pixels).\n        right: Right boundary (in pixels).\n        top: Top boundary (in pixels).\n        middle: Vertical center position (in pixels).\n        bottom: Bottom boundary (in pixels).\n    \"\"\"\n\n    i: int\n    start_time: int\n    end_time: int\n    styleref: Style\n    text: str\n    prespace: int\n    postspace: int\n    width: float\n    height: float\n    x: float\n    y: float\n    left: float\n    center: float\n    right: float\n    top: float\n    middle: float\n    bottom: float\n\n    @property\n    def duration(self) -&gt; int:\n        return self.end_time - self.start_time\n\n    def __repr__(self):\n        return _pretty_print(self)\n</code></pre>"},{"location":"reference/ass_core/#pyonfx.ass_core.Line","title":"<code>Line</code>  <code>dataclass</code>","text":"<p>Represents a subtitle line in an ASS file.</p> <p>Attributes:</p> Name Type Description <code>comment</code> <code>bool</code> <p>Indicates if the line is a comment (True) or dialogue (False).</p> <code>layer</code> <code>int</code> <p>Layer number for the line (higher layers are rendered above lower ones).</p> <code>start_time</code> <code>int</code> <p>Start time in milliseconds when the line appears.</p> <code>end_time</code> <code>int</code> <p>End time in milliseconds when the line disappears.</p> <code>duration</code> <code>int</code> <p>Duration in milliseconds, computed as end_time - start_time.</p> <code>style</code> <code>str</code> <p>Name of the style applied to the line.</p> <code>styleref</code> <code>Style</code> <p>Reference to the Style object used for formatting this line.</p> <code>actor</code> <code>str</code> <p>Actor or source associated with the line.</p> <code>margin_l</code> <code>int</code> <p>Left margin in pixels.</p> <code>margin_r</code> <code>int</code> <p>Right margin in pixels.</p> <code>margin_v</code> <code>int</code> <p>Vertical margin in pixels.</p> <code>effect</code> <code>str</code> <p>Effect field for the line.</p> <code>raw_text</code> <code>str</code> <p>Original text of the line, including override tags.</p> <code>text</code> <code>str</code> <p>Stripped text of the line (override tags removed).</p> <code>i</code> <code>int</code> <p>Zero-based index of the line in the ASS file.</p> <code>leadin</code> <code>int</code> <p>Time gap in milliseconds before this line, relative to the previous line.</p> <code>leadout</code> <code>int</code> <p>Time gap in milliseconds after this line, relative to the next line.</p> <code>width</code> <code>float</code> <p>Width of the line in pixels.</p> <code>height</code> <code>float</code> <p>Height of the line in pixels.</p> <code>ascent</code> <code>float</code> <p>Font ascent value for the line.</p> <code>descent</code> <code>float</code> <p>Font descent value for the line.</p> <code>internal_leading</code> <code>float</code> <p>Internal leading (line spacing within the font) in pixels.</p> <code>external_leading</code> <code>float</code> <p>External leading (additional spacing between lines) in pixels.</p> <code>x</code> <code>float</code> <p>Horizontal position (x-coordinate in pixels) of the line.</p> <code>y</code> <code>float</code> <p>Vertical position (y-coordinate in pixels) of the line.</p> <code>left</code> <code>float</code> <p>Left boundary of the line (in pixels).</p> <code>center</code> <code>float</code> <p>Horizontal center position of the line (in pixels).</p> <code>right</code> <code>float</code> <p>Right boundary of the line (in pixels).</p> <code>top</code> <code>float</code> <p>Top boundary of the line (in pixels).</p> <code>middle</code> <code>float</code> <p>Vertical center position of the line (in pixels).</p> <code>bottom</code> <code>float</code> <p>Bottom boundary of the line (in pixels).</p> <code>words</code> <code>list[Word]</code> <p>List of Word objects contained in the line.</p> <code>syls</code> <code>list[Syllable]</code> <p>List of Syllable objects in the line (if available).</p> <code>chars</code> <code>list[Char]</code> <p>List of Char objects in the line.</p> Source code in <code>pyonfx/ass_core.py</code> <pre><code>@dataclass(slots=True)\nclass Line:\n    \"\"\"Represents a subtitle line in an ASS file.\n\n    Attributes:\n        comment: Indicates if the line is a comment (True) or dialogue (False).\n        layer: Layer number for the line (higher layers are rendered above lower ones).\n        start_time: Start time in milliseconds when the line appears.\n        end_time: End time in milliseconds when the line disappears.\n        duration: Duration in milliseconds, computed as end_time - start_time.\n        style: Name of the style applied to the line.\n        styleref: Reference to the Style object used for formatting this line.\n        actor: Actor or source associated with the line.\n        margin_l: Left margin in pixels.\n        margin_r: Right margin in pixels.\n        margin_v: Vertical margin in pixels.\n        effect: Effect field for the line.\n        raw_text: Original text of the line, including override tags.\n        text: Stripped text of the line (override tags removed).\n        i: Zero-based index of the line in the ASS file.\n        leadin: Time gap in milliseconds before this line, relative to the previous line.\n        leadout: Time gap in milliseconds after this line, relative to the next line.\n        width: Width of the line in pixels.\n        height: Height of the line in pixels.\n        ascent: Font ascent value for the line.\n        descent: Font descent value for the line.\n        internal_leading: Internal leading (line spacing within the font) in pixels.\n        external_leading: External leading (additional spacing between lines) in pixels.\n        x: Horizontal position (x-coordinate in pixels) of the line.\n        y: Vertical position (y-coordinate in pixels) of the line.\n        left: Left boundary of the line (in pixels).\n        center: Horizontal center position of the line (in pixels).\n        right: Right boundary of the line (in pixels).\n        top: Top boundary of the line (in pixels).\n        middle: Vertical center position of the line (in pixels).\n        bottom: Bottom boundary of the line (in pixels).\n        words: List of Word objects contained in the line.\n        syls: List of Syllable objects in the line (if available).\n        chars: List of Char objects in the line.\n    \"\"\"\n\n    comment: bool\n    layer: int\n    start_time: int\n    end_time: int\n    style: str\n    styleref: Style\n    actor: str\n    margin_l: int\n    margin_r: int\n    margin_v: int\n    effect: str\n    raw_text: str\n    text: str\n    i: int\n    leadin: int\n    leadout: int\n    width: float\n    height: float\n    ascent: float\n    descent: float\n    internal_leading: float\n    external_leading: float\n    x: float\n    y: float\n    left: float\n    center: float\n    right: float\n    top: float\n    middle: float\n    bottom: float\n    words: list[Word]\n    syls: list[Syllable]\n    chars: list[Char]\n\n    @property\n    def duration(self) -&gt; int:\n        return self.end_time - self.start_time\n\n    def __repr__(self):\n        return _pretty_print(self)\n\n    def copy(self) -&gt; \"Line\":\n        \"\"\"\n        Returns:\n            A deep copy of this object (line)\n        \"\"\"\n        return copy.deepcopy(self)\n\n    @classmethod\n    def from_ass_line(\n        cls, line: str, line_index: int, styles: dict[str, Style]\n    ) -&gt; \"Line\":\n        \"\"\"Parse a single ASS line and return the corresponding Line object.\"\"\"\n        event_match = re.match(r\"(Dialogue|Comment):\\s*(.+)$\", line)\n        if not event_match:\n            raise ValueError(\n                f\"Invalid event line. Line index: {line_index}, Line: {line}.\"\n            )\n\n        # Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text\n        event_type = event_match.group(1)\n        event_data = event_match.group(2)\n\n        # Split into fields, allowing the text field to contain commas\n        event_fields = event_data.split(\",\", 9)\n        if len(event_fields) &lt; 10:\n            raise ValueError(f\"Incomplete event line at index {line_index}: {line}\")\n\n        # Convert time fields\n        try:\n            start_time = Convert.time(event_fields[1])\n            end_time = Convert.time(event_fields[2])\n        except Exception as e:\n            raise ValueError(f\"Invalid time fields at line {line_index}: {e}\")\n\n        # Resolve style reference\n        style_name = event_fields[3]\n        try:\n            styleref = styles[style_name]\n        except KeyError:\n            raise ValueError(f\"Unknown style '{style_name}' at line {line_index}\")\n\n        return cls(\n            comment=(event_type == \"Comment\"),\n            layer=int(event_fields[0]),\n            start_time=start_time,\n            end_time=end_time,\n            style=style_name,\n            styleref=styleref,\n            actor=event_fields[4],\n            margin_l=int(event_fields[5]),\n            margin_r=int(event_fields[6]),\n            margin_v=int(event_fields[7]),\n            effect=event_fields[8],\n            raw_text=event_fields[9],\n            text=\"\",\n            i=line_index,\n            leadin=-1,\n            leadout=-1,\n            width=float(\"nan\"),\n            height=float(\"nan\"),\n            ascent=float(\"nan\"),\n            descent=float(\"nan\"),\n            internal_leading=float(\"nan\"),\n            external_leading=float(\"nan\"),\n            x=float(\"nan\"),\n            y=float(\"nan\"),\n            left=float(\"nan\"),\n            center=float(\"nan\"),\n            right=float(\"nan\"),\n            top=float(\"nan\"),\n            middle=float(\"nan\"),\n            bottom=float(\"nan\"),\n            words=[],\n            syls=[],\n            chars=[],\n        )\n\n    def serialize(self) -&gt; str:\n        \"\"\"Serialize a Line object into an ASS line.\"\"\"\n        return (\n            f\"{'Comment' if self.comment else 'Dialogue'}: {self.layer},\"\n            f\"{Convert.time(max(0, int(self.start_time)))},\"\n            f\"{Convert.time(max(0, int(self.end_time)))},\"\n            f\"{self.style},\"\n            f\"{self.actor},\"\n            f\"{self.margin_l:04d},\"\n            f\"{self.margin_r:04d},\"\n            f\"{self.margin_v:04d},\"\n            f\"{self.effect},\"\n            f\"{self.text}\\n\"\n        )\n</code></pre>"},{"location":"reference/ass_core/#pyonfx.ass_core.Line.copy","title":"<code>copy()</code>","text":"<p>Returns:</p> Type Description <code>Line</code> <p>A deep copy of this object (line)</p> Source code in <code>pyonfx/ass_core.py</code> <pre><code>def copy(self) -&gt; \"Line\":\n    \"\"\"\n    Returns:\n        A deep copy of this object (line)\n    \"\"\"\n    return copy.deepcopy(self)\n</code></pre>"},{"location":"reference/ass_core/#pyonfx.ass_core.Line.from_ass_line","title":"<code>from_ass_line(line, line_index, styles)</code>  <code>classmethod</code>","text":"<p>Parse a single ASS line and return the corresponding Line object.</p> Source code in <code>pyonfx/ass_core.py</code> <pre><code>@classmethod\ndef from_ass_line(\n    cls, line: str, line_index: int, styles: dict[str, Style]\n) -&gt; \"Line\":\n    \"\"\"Parse a single ASS line and return the corresponding Line object.\"\"\"\n    event_match = re.match(r\"(Dialogue|Comment):\\s*(.+)$\", line)\n    if not event_match:\n        raise ValueError(\n            f\"Invalid event line. Line index: {line_index}, Line: {line}.\"\n        )\n\n    # Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text\n    event_type = event_match.group(1)\n    event_data = event_match.group(2)\n\n    # Split into fields, allowing the text field to contain commas\n    event_fields = event_data.split(\",\", 9)\n    if len(event_fields) &lt; 10:\n        raise ValueError(f\"Incomplete event line at index {line_index}: {line}\")\n\n    # Convert time fields\n    try:\n        start_time = Convert.time(event_fields[1])\n        end_time = Convert.time(event_fields[2])\n    except Exception as e:\n        raise ValueError(f\"Invalid time fields at line {line_index}: {e}\")\n\n    # Resolve style reference\n    style_name = event_fields[3]\n    try:\n        styleref = styles[style_name]\n    except KeyError:\n        raise ValueError(f\"Unknown style '{style_name}' at line {line_index}\")\n\n    return cls(\n        comment=(event_type == \"Comment\"),\n        layer=int(event_fields[0]),\n        start_time=start_time,\n        end_time=end_time,\n        style=style_name,\n        styleref=styleref,\n        actor=event_fields[4],\n        margin_l=int(event_fields[5]),\n        margin_r=int(event_fields[6]),\n        margin_v=int(event_fields[7]),\n        effect=event_fields[8],\n        raw_text=event_fields[9],\n        text=\"\",\n        i=line_index,\n        leadin=-1,\n        leadout=-1,\n        width=float(\"nan\"),\n        height=float(\"nan\"),\n        ascent=float(\"nan\"),\n        descent=float(\"nan\"),\n        internal_leading=float(\"nan\"),\n        external_leading=float(\"nan\"),\n        x=float(\"nan\"),\n        y=float(\"nan\"),\n        left=float(\"nan\"),\n        center=float(\"nan\"),\n        right=float(\"nan\"),\n        top=float(\"nan\"),\n        middle=float(\"nan\"),\n        bottom=float(\"nan\"),\n        words=[],\n        syls=[],\n        chars=[],\n    )\n</code></pre>"},{"location":"reference/ass_core/#pyonfx.ass_core.Line.serialize","title":"<code>serialize()</code>","text":"<p>Serialize a Line object into an ASS line.</p> Source code in <code>pyonfx/ass_core.py</code> <pre><code>def serialize(self) -&gt; str:\n    \"\"\"Serialize a Line object into an ASS line.\"\"\"\n    return (\n        f\"{'Comment' if self.comment else 'Dialogue'}: {self.layer},\"\n        f\"{Convert.time(max(0, int(self.start_time)))},\"\n        f\"{Convert.time(max(0, int(self.end_time)))},\"\n        f\"{self.style},\"\n        f\"{self.actor},\"\n        f\"{self.margin_l:04d},\"\n        f\"{self.margin_r:04d},\"\n        f\"{self.margin_v:04d},\"\n        f\"{self.effect},\"\n        f\"{self.text}\\n\"\n    )\n</code></pre>"},{"location":"reference/ass_core/#pyonfx.ass_core.Ass","title":"<code>Ass</code>","text":"<p>ASS File Handler.</p> <p>This class provides an interface for reading, processing, and writing Advanced SubStation Alpha (ASS) subtitle files. It extracts metadata, styles, and dialogue events, computes extended layout metrics, and outputs ASS files for use with Aegisub or MPV. It also supports preserving the original subtitle content as comments and auto-resolves file paths.</p> <p>Attributes:</p> Name Type Description <code>path_input</code> <code>str</code> <p>absolute path to the input subtitle file.</p> <code>path_output</code> <code>str</code> <p>absolute path to the output subtitle file.</p> <code>meta</code> <code>Meta</code> <p>metadata extracted from the ASS file.</p> <code>styles</code> <code>dict[str, Style]</code> <p>mapping of style names to their style objects present in the ASS file.</p> <code>lines</code> <code>list[Line]</code> <p>list of subtitle event lines parsed from the file.</p> <code>PIXEL_STYLE</code> <code>Style</code> <p>default lightweight style for pixel-based effects.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; io = Ass(\"in.ass\")\n&gt;&gt;&gt; meta, styles, lines = io.get_data()\n</code></pre> Source code in <code>pyonfx/ass_core.py</code> <pre><code>class Ass:\n    \"\"\"ASS File Handler.\n\n    This class provides an interface for reading, processing, and writing Advanced SubStation Alpha (ASS) subtitle files.\n    It extracts metadata, styles, and dialogue events, computes extended layout metrics, and outputs ASS files for use with Aegisub or MPV.\n    It also supports preserving the original subtitle content as comments and auto-resolves file paths.\n\n    Attributes:\n        path_input: absolute path to the input subtitle file.\n        path_output: absolute path to the output subtitle file.\n        meta: metadata extracted from the ASS file.\n        styles: mapping of style names to their style objects present in the ASS file.\n        lines: list of subtitle event lines parsed from the file.\n        PIXEL_STYLE: default lightweight style for pixel-based effects.\n\n    Examples:\n        &gt;&gt;&gt; io = Ass(\"in.ass\")\n        &gt;&gt;&gt; meta, styles, lines = io.get_data()\n    \"\"\"\n\n    PIXEL_STYLE: Style = Style(\n        name=\"p\",\n        fontname=\"Arial\",\n        fontsize=20,\n        color1=\"FFFFFF\",\n        alpha1=\"00\",\n        color2=\"FFFFFF\",\n        alpha2=\"00\",\n        color3=\"000000\",\n        alpha3=\"0000\",\n        color4=\"000000\",\n        alpha4=\"0000\",\n        bold=False,\n        italic=False,\n        underline=False,\n        strikeout=False,\n        scale_x=100,\n        scale_y=100,\n        spacing=0,\n        angle=0,\n        border_style=False,\n        outline=0,\n        shadow=0,\n        alignment=7,\n        margin_l=0,\n        margin_r=0,\n        margin_v=0,\n        encoding=1,\n    )\n    \"\"\"Lightweight style for pixels.\"\"\"\n\n    def __init__(\n        self,\n        path_input: str,\n        path_output: str = \"output.ass\",\n        keep_original: bool = True,\n        extended: bool = True,\n        vertical_kanji: bool = False,\n    ):\n        \"\"\"Initialize the ASS object.\n\n        Args:\n            path_input: The path for the input ASS file, which can be relative or absolute.\n            path_output: The path for the output ASS file (default: \"output.ass\").\n            keep_original: If True, the original lines are kept as comments in the output.\n            extended: If True, extended information (including positioning, metrics, words, syllables, and characters) will be computed.\n            vertical_kanji: If True, lines with alignment 4, 5 or 6 will be repositioned vertically.\n        \"\"\"\n        # Progress/statistics\n        self._saved = False\n        self._plines = 0  # Total produced lines\n        self._ptime = time.time()  # Total processing time\n        self._stats_by_effect: defaultdict[str, dict[str, float | int]] = defaultdict(\n            lambda: {\"lines\": 0, \"time\": 0.0, \"calls\": 0}\n        )\n\n        # Output buffers\n        self._output: list[str] = []\n        self._output_extradata: list[str] = []\n\n        # Public attributes\n        self.meta: Meta = Meta(\n            wrap_style=None,\n            scaled_border_and_shadow=None,\n            play_res_x=None,\n            play_res_y=None,\n            audio=None,\n            video=None,\n            timestamps=None,\n        )\n        self.styles: dict[str, Style] = {}\n        self.lines: list[Line] = []\n\n        # Getting absolute sub file path\n        self.path_input: str = _resolve_path(sys.argv[0], path_input)\n        if not os.path.isfile(self.path_input):\n            raise FileNotFoundError(\n                \"Invalid path for the Subtitle file: %s\" % self.path_input\n            )\n        self.path_output: str = _resolve_path(sys.argv[0], path_output)\n\n        # Parse the ASS file\n        current_section = \"\"\n        line_index = 0\n\n        with open(self.path_input, encoding=\"utf-8-sig\") as file:\n            for line in file:\n                # New section?\n                section_match = re.match(r\"^\\[([^\\]]*)\\]\", line)\n                if section_match:\n                    current_section = section_match.group(1)\n                    if current_section != \"Aegisub Extradata\":\n                        self._output.append(line)\n                    continue\n\n                # Copy-paste lines\n                elif line.startswith(\"Format\") or not line.strip():\n                    self._output.append(line)\n                # Sections parsers\n                elif current_section in (\"Script Info\", \"Aegisub Project Garbage\"):\n                    line = self.meta.parse_line(line, self.path_input)\n                    self._output.append(line)\n                elif current_section == \"V4+ Styles\":\n                    style = Style.from_ass_line(line)\n                    self.styles[style.name] = style\n                    self._output.append(line)\n                elif current_section == \"Events\":\n                    self.lines.append(Line.from_ass_line(line, line_index, self.styles))\n                    if keep_original:\n                        self._output.append(\n                            re.sub(r\"^(Dialogue|Comment):\", \"Comment:\", line, count=1)\n                        )\n                    line_index += 1\n                elif current_section == \"Aegisub Extradata\":\n                    self._output_extradata.append(line)\n                elif (\n                    current_section and line.strip()\n                ):  # Non-empty line in unknown section\n                    raise ValueError(\n                        f\"Unexpected section in the input file: [{current_section}]\"\n                    )\n\n        # Add extended information to lines and meta?\n        if extended:\n            self._process_extended_line_data(vertical_kanji)\n\n    def _process_extended_line_data(self, vertical_kanji: bool) -&gt; None:\n        \"\"\"Process extended line data including positioning, words, syllables, and characters.\"\"\"\n\n        def _split_raw_segments(\n            lines: list[Line],\n        ) -&gt; tuple[list[Line], list[int], list[int]]:\n            \"\"\"Split each raw_text at \\\\N and compute cumulative k-offsets.\"\"\"\n            output_lines: list[Line] = []\n            new_lines_indices: list[int] = []\n            new_lines_k_offsets: list[int] = []\n            for line in lines:\n                raw_segments = line.raw_text.split(\"\\\\N\")\n                text_segments = re.sub(r\"\\{.*?\\}\", \"\", line.raw_text).split(\"\\\\N\")\n                seg_k_durations = [\n                    sum(int(m) * 10 for m in re.findall(r\"\\\\[kK][of]?(\\d+)\", seg))\n                    for seg in raw_segments\n                ]\n                cumulative_k_durations = [\n                    sum(seg_k_durations[:i]) for i in range(len(seg_k_durations))\n                ]\n\n                for seg_idx, (raw_seg, text_seg) in enumerate(\n                    zip(raw_segments, text_segments)\n                ):\n                    seg_line = line.copy()\n                    seg_line.raw_text = raw_seg\n                    seg_line.text = text_seg\n                    output_lines.append(seg_line)\n                    new_lines_indices.append(seg_idx)\n                    new_lines_k_offsets.append(cumulative_k_durations[seg_idx])\n            return output_lines, new_lines_indices, new_lines_k_offsets\n\n        def _compute_line_fields(line: Line, font: Font, split_index: int):\n            line.text = re.sub(r\"\\{.*?\\}\", \"\", line.raw_text)\n\n            line.width, line.height = font.get_text_extents(line.text.strip())\n            (\n                line.ascent,\n                line.descent,\n                line.internal_leading,\n                line.external_leading,\n            ) = font.get_metrics()\n\n            if (\n                self.meta.play_res_x is None\n                or self.meta.play_res_x &lt;= 0\n                or self.meta.play_res_y is None\n                or self.meta.play_res_y &lt;= 0\n            ):\n                return\n\n            # Resolve margins\n            margins = {\n                \"l\": line.margin_l or line.styleref.margin_l,\n                \"r\": line.margin_r or line.styleref.margin_r,\n                \"v\": line.margin_v or line.styleref.margin_v,\n            }\n\n            # Horizontal position\n            h_group = (line.styleref.alignment - 1) % 3\n            positions = [\n                margins[\"l\"],\n                (self.meta.play_res_x - line.width) / 2\n                + (margins[\"l\"] - margins[\"r\"]) / 2,\n                self.meta.play_res_x - margins[\"r\"] - line.width,\n            ]\n            line.left = positions[h_group]\n            line.center = line.left + line.width / 2\n            line.right = line.left + line.width\n            line.x = (line.left, line.center, line.right)[h_group]\n\n            # Vertical position\n            v_group = (line.styleref.alignment - 1) // 3\n            positions = [\n                self.meta.play_res_y - margins[\"v\"] - line.height,  # bottom\n                (self.meta.play_res_y - line.height) / 2,  # middle\n                margins[\"v\"],  # top\n            ]\n            line.top = positions[v_group]\n            line.middle = line.top + line.height / 2\n            line.bottom = line.top + line.height\n            line.y = (line.bottom, line.middle, line.top)[v_group]\n\n            # Apply vertical offset for split lines\n            if split_index &gt; 0:\n                offset = split_index * line.height\n                line.top += offset\n                line.middle += offset\n                line.bottom += offset\n                line.y += offset\n\n        def _build_words(line: Line, font: Font):\n            for wi, (prespace, word_text, postspace) in enumerate(\n                re.findall(r\"(\\s*)([^\\s]+)(\\s*)\", line.text)\n            ):\n                width, height = font.get_text_extents(word_text)\n                line.words.append(\n                    Word(\n                        i=wi,\n                        start_time=line.start_time,\n                        end_time=line.end_time,\n                        styleref=line.styleref,\n                        text=word_text,\n                        prespace=len(prespace),\n                        postspace=len(postspace),\n                        width=width,\n                        height=height,\n                        x=float(\"nan\"),\n                        y=float(\"nan\"),\n                        left=float(\"nan\"),\n                        center=float(\"nan\"),\n                        right=float(\"nan\"),\n                        top=float(\"nan\"),\n                        middle=float(\"nan\"),\n                        bottom=float(\"nan\"),\n                    )\n                )\n\n            if (\n                line.left == float(\"nan\")\n                or self.meta.play_res_x is None\n                or self.meta.play_res_y is None\n            ):\n                return\n\n            h_group = (line.styleref.alignment - 1) % 3\n            v_group = (line.styleref.alignment - 1) // 3\n\n            if not vertical_kanji or v_group in (0, 2):\n                cur_x = line.left\n                space_offset = space_width + style_spacing\n\n                for i, word in enumerate(line.words):\n                    # Add prespace offset for all words except the first one\n                    if i &gt; 0:\n                        cur_x += word.prespace * space_offset\n\n                    # Horizontal position\n                    word.left = cur_x\n                    word.center = word.left + word.width / 2\n                    word.right = word.left + word.width\n                    word.x = [word.left, word.center, word.right][h_group]\n\n                    # Vertical position (copy from line)\n                    word.top, word.middle, word.bottom, word.y = (\n                        line.top,\n                        line.middle,\n                        line.bottom,\n                        line.y,\n                    )\n\n                    # Update cur_x for next word\n                    cur_x += word.width + word.postspace * space_offset + style_spacing\n            else:\n                max_width = max(word.width for word in line.words)\n                sum_height = sum(word.height for word in line.words)\n\n                cur_y = self.meta.play_res_y / 2 - sum_height / 2\n                alignment = line.styleref.alignment\n\n                for word in line.words:\n                    # Horizontal position\n                    x_fix = (max_width - word.width) / 2\n\n                    if alignment == 4:\n                        word.left = line.left + x_fix\n                        word.x = word.left\n                    elif alignment == 5:\n                        word.left = self.meta.play_res_x / 2 - word.width / 2\n                        word.x = word.left + word.width / 2\n                    else:\n                        word.left = line.right - word.width - x_fix\n                        word.x = word.left + word.width\n\n                    word.center = word.left + word.width / 2\n                    word.right = word.left + word.width\n\n                    # Vertical position\n                    word.top = cur_y\n                    word.middle = cur_y + word.height / 2\n                    word.bottom = cur_y + word.height\n                    word.y = word.middle\n                    cur_y += word.height\n\n        def _parse_syllables(line_raw_text: str) -&gt; list[tuple[str, int, str]]:\n            KARAOKE_PATTERN = re.compile(r\"\\\\[kK][fot]?(\\d+)?\")\n            TAG_BLOCK_PATTERN = re.compile(r\"\\{([^}]*)\\}|([^{]+)\")\n            TAG_EXTRACT_PATTERN = re.compile(r\"\\\\[^\\\\]*\")\n\n            result = []\n            pending_tags = []\n            current_tags = []\n            current_text = \"\"\n            current_duration = \"\"\n\n            # Split line into tag blocks {...} and text segments\n            for match in TAG_BLOCK_PATTERN.finditer(line_raw_text):\n                tag_content, text_content = match.group(1), match.group(2)\n\n                if tag_content is not None:\n                    tags = TAG_EXTRACT_PATTERN.findall(tag_content)\n                    karaoke_matches = {tag: KARAOKE_PATTERN.match(tag) for tag in tags}\n                    has_karaoke = any(karaoke_matches.values())\n\n                    if has_karaoke:\n                        # Karaoke block: process tags\n                        found_karaoke = False\n                        for tag in tags:\n                            k_match = karaoke_matches[tag]\n                            if k_match:\n                                if current_tags:\n                                    result.append(\n                                        (\n                                            \"\".join(current_tags),\n                                            current_duration,\n                                            current_text,\n                                        )\n                                    )\n                                    current_text = \"\"\n                                current_tags = pending_tags + [tag]\n                                current_duration = (\n                                    int(k_match.group(1)) if k_match.group(1) else 0\n                                )\n                                pending_tags = []\n                                found_karaoke = True\n                            else:\n                                if found_karaoke:\n                                    current_tags.append(tag)\n                                else:\n                                    pending_tags.append(tag)\n                    else:\n                        # Non-karaoke block: decide where these tags belong\n                        if current_tags and not current_text:\n                            current_tags.extend(tags)\n                        else:\n                            pending_tags.extend(tags)\n                else:\n                    # Plain text: add to current division\n                    current_text += text_content\n\n            # Add the final division if it exists\n            if current_tags:\n                result.append((\"\".join(current_tags), current_duration, current_text))\n\n            return result\n\n        def _build_syllables(\n            line: Line,\n            syllable_data: list[tuple[str, int, str]],\n            font: Font,\n            split_k_offset: int,\n        ):\n            # Precompute word boundaries (start_idx, end_idx, word_i)\n            word_boundaries: list[tuple[int, int, int]] = []\n            idx = 0\n            for w in line.words:\n                start = idx + w.prespace\n                end = start + len(w.text)\n                word_boundaries.append((start, end, w.i))\n                idx = end + w.postspace\n\n            last_time = split_k_offset\n            syl_char_idx = 0\n\n            for syl_i, (tags, k_dur, raw_text) in enumerate(syllable_data):\n                # Inline effect\n                m = re.search(r\"\\\\-([^\\s\\\\}]+)\", tags)\n                inline_fx = m.group(1) if m else \"\"\n\n                # Text and spacing\n                text_stripped = raw_text.strip()\n                prespace = len(raw_text) - len(raw_text.lstrip())\n                postspace = (\n                    len(raw_text) - len(raw_text.rstrip()) if text_stripped else 0\n                )\n\n                # Timing\n                duration = k_dur * 10 if k_dur else 0\n                start_time = last_time\n                end_time = start_time + duration\n\n                # Determine word index\n                syl_start = syl_char_idx + prespace\n                syl_word_i = next(\n                    (w_i for s, e, w_i in word_boundaries if s &lt;= syl_start &lt; e), 0\n                )\n\n                # Font metrics\n                width, height = font.get_text_extents(text_stripped)\n\n                # Create and append syllable\n                line.syls.append(\n                    Syllable(\n                        i=syl_i,\n                        word_i=syl_word_i,\n                        start_time=start_time,\n                        end_time=end_time,\n                        styleref=line.styleref,\n                        text=text_stripped,\n                        tags=tags,\n                        inline_fx=inline_fx,\n                        prespace=prespace,\n                        postspace=postspace,\n                        width=width,\n                        height=height,\n                        x=float(\"nan\"),\n                        y=float(\"nan\"),\n                        left=float(\"nan\"),\n                        center=float(\"nan\"),\n                        right=float(\"nan\"),\n                        top=float(\"nan\"),\n                        middle=float(\"nan\"),\n                        bottom=float(\"nan\"),\n                    )\n                )\n\n                # Update for next iteration\n                last_time = end_time\n                syl_char_idx += prespace + len(text_stripped) + postspace\n\n            if (\n                line.left == float(\"nan\")\n                or self.meta.play_res_x is None\n                or self.meta.play_res_y is None\n            ):\n                return\n\n            h_group = (line.styleref.alignment - 1) % 3\n            v_group = (line.styleref.alignment - 1) // 3\n\n            if not vertical_kanji or v_group in (0, 2):\n                cur_x = line.left\n                found_first_text_syl = False\n                space_offset = space_width + style_spacing\n\n                for syl in line.syls:\n                    # Add prespace offset only after the first syllable with text\n                    if found_first_text_syl:\n                        cur_x += syl.prespace * space_offset\n                    elif syl.text:\n                        found_first_text_syl = True\n\n                    # Horizontal position\n                    syl.left = cur_x\n                    syl.center = syl.left + syl.width / 2\n                    syl.right = syl.left + syl.width\n                    syl.x = [syl.left, syl.center, syl.right][h_group]\n\n                    # Vertical position\n                    syl.top, syl.middle, syl.bottom, syl.y = (\n                        line.top,\n                        line.middle,\n                        line.bottom,\n                        line.y,\n                    )\n\n                    # Update cur_x for next syllable\n                    cur_x += syl.width + syl.postspace * space_offset + style_spacing\n            else:\n                max_width = max(syl.width for syl in line.syls)\n                sum_height = sum(syl.height for syl in line.syls)\n\n                cur_y = self.meta.play_res_y / 2 - sum_height / 2\n                alignment = line.styleref.alignment\n\n                for syl in line.syls:\n                    x_fix = (max_width - syl.width) / 2\n\n                    # Horizontal position\n                    if alignment == 4:\n                        syl.left = line.left + x_fix\n                    elif alignment == 5:\n                        syl.left = self.meta.play_res_x / 2 - syl.width / 2\n                    else:\n                        syl.left = line.right - syl.width - x_fix\n\n                    syl.center = syl.left + syl.width / 2\n                    syl.right = syl.left + syl.width\n                    syl.x = [syl.left, syl.center, syl.right][h_group]\n\n                    # Vertical position\n                    syl.top = cur_y\n                    syl.middle = cur_y + syl.height / 2\n                    syl.bottom = cur_y + syl.height\n                    syl.y = syl.middle\n\n                    cur_y += syl.height\n\n        def _build_chars(line: Line, font: Font):\n            # Chars are built from syllables: fallback to words if no syllables\n            words_or_syls = line.syls if line.syls else line.words\n\n            char_index = 0\n            for el in words_or_syls:\n                el_text = \"{}{}{}\".format(\n                    \" \" * el.prespace, el.text, \" \" * el.postspace\n                )\n                for ci, char_text in enumerate(list(el_text)):\n                    width, height = font.get_text_extents(char_text)\n\n                    char = Char(\n                        i=char_index,\n                        word_i=getattr(el, \"word_i\", el.i),\n                        syl_i=el.i if line.syls else -1,  # -1 means no syllable\n                        syl_char_i=ci,\n                        start_time=el.start_time,\n                        end_time=el.end_time,\n                        styleref=line.styleref,\n                        text=char_text,\n                        inline_fx=getattr(el, \"inline_fx\", \"\"),\n                        width=width,\n                        height=height,\n                        x=float(\"nan\"),\n                        y=float(\"nan\"),\n                        left=float(\"nan\"),\n                        center=float(\"nan\"),\n                        right=float(\"nan\"),\n                        top=float(\"nan\"),\n                        middle=float(\"nan\"),\n                        bottom=float(\"nan\"),\n                    )\n                    char_index += 1\n                    line.chars.append(char)\n\n            if (\n                line.left == float(\"nan\")\n                or self.meta.play_res_x is None\n                or self.meta.play_res_y is None\n            ):\n                return\n\n            h_group = (line.styleref.alignment - 1) % 3\n            v_group = (line.styleref.alignment - 1) // 3\n\n            if not vertical_kanji or v_group in (0, 2):\n                cur_x = line.left\n                found_first_non_whitespace = False\n\n                for char in line.chars:\n                    # Horizontal position\n                    char.left = cur_x\n                    char.center = char.left + char.width / 2\n                    char.right = char.left + char.width\n                    char.x = [char.left, char.center, char.right][h_group]\n\n                    # Update cur_x after first visible character\n                    if found_first_non_whitespace:\n                        cur_x += char.width + style_spacing\n                    elif not char.text.isspace():\n                        found_first_non_whitespace = True\n                        cur_x += char.width + style_spacing\n\n                    # Vertical position (copy from line)\n                    char.top, char.middle, char.bottom, char.y = (\n                        line.top,\n                        line.middle,\n                        line.bottom,\n                        line.y,\n                    )\n            else:\n                max_width = max(char.width for char in line.chars)\n                sum_height = sum(char.height for char in line.chars)\n                cur_y = self.meta.play_res_y / 2 - sum_height / 2\n\n                # Set line box metrics\n                line.top = cur_y\n                line.middle = self.meta.play_res_y / 2\n                line.bottom = line.top + sum_height\n                line.width = max_width\n                line.height = sum_height\n\n                if line.styleref.alignment == 4:\n                    line.center = line.left + max_width / 2\n                    line.right = line.left + max_width\n                elif line.styleref.alignment == 5:\n                    line.left = line.center - max_width / 2\n                    line.right = line.left + max_width\n                else:\n                    line.left = line.right - max_width\n                    line.center = line.left + max_width / 2\n\n                for char in line.chars:\n                    # Horizontal position\n                    x_fix = (max_width - char.width) / 2\n\n                    if line.styleref.alignment == 4:\n                        char.left = line.left + x_fix\n                    elif line.styleref.alignment == 5:\n                        char.left = self.meta.play_res_x / 2 - char.width / 2\n                    else:\n                        char.left = line.right - char.width - x_fix\n\n                    char.center = char.left + char.width / 2\n                    char.right = char.left + char.width\n                    char.x = [char.left, char.center, char.right][h_group]\n\n                    # Vertical position\n                    char.top = cur_y\n                    char.middle = cur_y + char.height / 2\n                    char.bottom = cur_y + char.height\n                    char.y = char.middle\n\n                    cur_y += char.height\n\n        def _assign_lead_times(lines_by_styles):\n            for _, lines in lines_by_styles.items():\n                # Sort lines by start_time\n                sorted_lines = sorted(lines, key=lambda l: l.start_time)\n\n                # Group consecutive lines with the same index 'i'\n                grouped = [\n                    list(group)\n                    for _, group in itertools.groupby(sorted_lines, key=lambda l: l.i)\n                ]\n\n                # Compute and assign leadin/leadout for each group\n                for idx, group in enumerate(grouped):\n                    prev_end = grouped[idx - 1][-1].end_time if idx &gt; 0 else None\n                    next_start = (\n                        grouped[idx + 1][0].start_time\n                        if idx &lt; len(grouped) - 1\n                        else None\n                    )\n\n                    leadin = (\n                        1001 if prev_end is None else group[0].start_time - prev_end\n                    )\n                    leadout = (\n                        1001 if next_start is None else next_start - group[-1].end_time\n                    )\n\n                    for line in group:\n                        line.leadin = leadin\n                        line.leadout = leadout\n\n        # Let the fun begin (Pyon!)\n        self.lines, new_lines_indices, new_lines_k_offsets = _split_raw_segments(\n            self.lines\n        )\n        lines_by_styles: dict[str, list[Line]] = defaultdict(list)\n\n        for line, split_index, split_k_offset in zip(\n            self.lines, new_lines_indices, new_lines_k_offsets\n        ):\n            # Group lines by style for leadin/leadout calculation\n            lines_by_styles[line.style].append(line)\n\n            # Get font metrics and spacing\n            font = Font(line.styleref)\n            space_width = font.get_text_extents(\" \")[0]\n            style_spacing = line.styleref.spacing\n\n            # Compute line fields\n            _compute_line_fields(line, font, split_index)\n\n            # Build words\n            _build_words(line, font)\n\n            # Build syllables\n            syllable_data = _parse_syllables(line.raw_text)\n            _build_syllables(line, syllable_data, font, split_k_offset)\n\n            # Build chars\n            _build_chars(line, font)\n\n        # Add leadin/leadout\n        _assign_lead_times(lines_by_styles)\n\n    def replace_meta(self, meta: Meta) -&gt; None:\n        \"\"\"Replace metadata in the ASS output file.\n\n        Args:\n            meta: A Meta object containing the updated metadata.\n\n        Examples:\n            &gt;&gt;&gt; meta, _, _ = io.get_data()\n            &gt;&gt;&gt; meta.wrap_style = 2\n            &gt;&gt;&gt; io.replace_meta(meta)\n        \"\"\"\n        self.meta = meta\n        new_script_lines, new_garbage_lines = meta.serialize()\n\n        def get_key(line: str) -&gt; str:\n            return line.split(\":\", 1)[0].strip() if \":\" in line else \"\"\n\n        def update_section(section: str, new_lines: list[str]) -&gt; None:\n            # Build a dictionary of new meta lines keyed by their meta key\n            new_meta = {get_key(line): line for line in new_lines if get_key(line)}\n\n            # Locate the section header in the _output list\n            try:\n                header_idx = next(\n                    i\n                    for i, line in enumerate(self._output)\n                    if line.strip().startswith(section)\n                )\n            except StopIteration:\n                if section == \"[Aegisub Project Garbage]\":\n                    # Insert the Aegisub Project Garbage section after [Script Info] if available\n                    try:\n                        script_idx = next(\n                            i\n                            for i, line in enumerate(self._output)\n                            if line.strip().startswith(\"[Script Info]\")\n                        )\n                        end_script_idx = next(\n                            (\n                                j\n                                for j, line in enumerate(\n                                    self._output[script_idx + 1 :], start=script_idx + 1\n                                )\n                                if line.strip().startswith(\"[\")\n                            ),\n                            len(self._output),\n                        )\n                        insert_idx = end_script_idx\n                    except StopIteration:\n                        insert_idx = len(self._output)\n                    self._output.insert(insert_idx, f\"{section}\\n\")\n                    self._output.insert(insert_idx + 1, \"\\n\")\n                    header_idx = insert_idx\n                else:\n                    raise ValueError(f\"{section} is not a valid section.\")\n\n            # Determine the end of the section (first line starting with '[' after header)\n            end_idx = (\n                next(\n                    (\n                        j\n                        for j, line in enumerate(\n                            self._output[header_idx + 1 :], start=header_idx + 1\n                        )\n                        if line.strip().startswith(\"[\")\n                    ),\n                    len(self._output),\n                )\n                - 1\n            )\n\n            # Update only the meta-related lines in this section\n            updated_block = [\n                new_meta.pop(get_key(line), line) if get_key(line) else line\n                for line in self._output[header_idx + 1 : end_idx]\n            ]\n\n            # Append any new meta lines not already present\n            updated_block.extend(new_meta.values())\n            self._output[:] = (\n                self._output[: header_idx + 1] + updated_block + self._output[end_idx:]\n            )\n\n        update_section(\"[Script Info]\", new_script_lines)\n        update_section(\"[Aegisub Project Garbage]\", new_garbage_lines)\n\n    def replace_style(self, style_name: str, style: Style) -&gt; None:\n        \"\"\"Replace an existing style in the ASS output file.\n\n        Args:\n            style_name: The name of the style to be replaced.\n            style: A Style object containing the updated style parameters.\n\n        Examples:\n            &gt;&gt;&gt; style = styles['Default']\n            &gt;&gt;&gt; style.fontname = 'Helvetica'\n            &gt;&gt;&gt; io.replace_style('Default', style)\n\n        See Also:\n            [add_style][pyonfx.ass_core.Ass.add_style]\n        \"\"\"\n        if style_name not in self.styles:\n            raise ValueError(f\"Style {style_name} does not exist.\")\n\n        # Update the style in the dictionary\n        self.styles[style_name] = style\n\n        # Serialize the new style\n        new_style_line = style.serialize(style_name)\n\n        # Update the corresponding style line in the _output list\n        for idx, line in enumerate(self._output):\n            stripped_line = line.lstrip()\n            if stripped_line.startswith(\"Style:\"):\n                parts = stripped_line[len(\"Style:\") :].split(\",\", 1)\n                if parts and parts[0].strip() == style_name:\n                    self._output[idx] = new_style_line\n                    break\n\n    def add_style(self, style_name: str, style: Style) -&gt; None:\n        \"\"\"Add a new style to the ASS output file.\n\n        Args:\n            style_name: The name for the new style. This name must be unique within the ASS file.\n            style: A Style object containing the styling parameters for the new style.\n\n        Examples:\n            &gt;&gt;&gt; new_style = Style(name=\"NewStyle\", fontname=\"Arial\", fontsize=20, color1=\"FFFFFF\", alpha1=\"00\",\n            ...                    color2=\"FFFFFF\", alpha2=\"00\", color3=\"000000\", alpha3=\"0000\",\n            ...                    color4=\"000000\", alpha4=\"0000\", bold=False, italic=False, underline=False,\n            ...                    strikeout=False, scale_x=100, scale_y=100, spacing=0, angle=0, border_style=False,\n            ...                    outline=0, shadow=0, alignment=7, margin_l=0, margin_r=0, margin_v=0, encoding=1)\n            &gt;&gt;&gt; io.add_style(\"NewStyle\", new_style)\n\n        Notes:\n            Ensure that the style name is unique in the current styles mapping.\n\n        See Also:\n            [replace_style][pyonfx.ass_core.Ass.replace_style]\n        \"\"\"\n        if style_name in self.styles:\n            raise ValueError(f\"Style {style_name} already exists.\")\n\n        insertion_index = None\n        in_styles_section = False\n        for i, line in enumerate(self._output):\n            stripped = line.strip()\n            if stripped.startswith(\"[\") and \"V4+ Styles\" in stripped:\n                in_styles_section = True\n                continue\n            if in_styles_section and stripped.startswith(\"[\"):\n                insertion_index = i - 1\n                break\n        if insertion_index is None:\n            insertion_index = len(self._output)\n\n        style_line = style.serialize(style_name)\n        self._output.insert(insertion_index, style_line)\n        self.styles[style_name] = style\n\n    def get_data(self) -&gt; tuple[Meta, dict[str, Style], list[Line]]:\n        \"\"\"Retrieve metadata, styles, and subtitle lines from the ASS file.\n\n        This utility method returns the essential components of a parsed ASS file:\n\n        - meta: A Meta object containing configuration and metadata.\n        - styles: A dictionary mapping style names to their corresponding Style objects.\n        - lines: A list of Line objects representing the subtitle dialogue events.\n\n        Returns:\n            tuple: A tuple containing the meta object, the dictionary of styles, and the list of subtitle lines.\n\n        Examples:\n            &gt;&gt;&gt; meta, styles, lines = ass.get_data()\n        \"\"\"\n        return self.meta, self.styles, self.lines\n\n    def write_line(self, line: Line) -&gt; None:\n        \"\"\"Write a subtitle line to the output buffer.\n\n        Args:\n            line: A Line object representing a subtitle event.\n\n        Examples:\n            &gt;&gt;&gt; line = some_line_object  # a valid Line object\n            &gt;&gt;&gt; io.write_line(line)\n\n        Notes:\n            This method only updates the internal buffer; you must call save() to persist the changes to disk.\n\n        See Also:\n            [save][pyonfx.ass_core.Ass.save]\n        \"\"\"\n        self._output.append(line.serialize())\n        self._plines += 1\n\n    def save(self, quiet: bool = False) -&gt; None:\n        \"\"\"Save the processed subtitles to the output ASS file and print performance metrics.\n\n        Args:\n            quiet: If True, suppresses the output messages during the save process. Defaults to False.\n\n        Notes:\n            Make sure to call this method after all subtitle processing is complete to persist your changes.\n\n        See Also:\n            [open_aegisub][pyonfx.ass_core.Ass.open_aegisub], [open_mpv][pyonfx.ass_core.Ass.open_mpv]\n        \"\"\"\n        # Add script generation info\n        header_idx = next(\n            i\n            for i, line in enumerate(self._output)\n            if line.strip().startswith(\"[Script Info]\")\n        )\n        start_idx = header_idx + 1\n        end_idx = next(\n            (\n                i\n                for i in range(start_idx, len(self._output))\n                if self._output[i].startswith(\"[\")\n            ),\n            len(self._output),\n        )\n\n        found_generated = False\n        i = start_idx\n        while i &lt; end_idx:\n            line = self._output[i]\n            stripped = line.lstrip()\n            if stripped.startswith(\"; http:\"):\n                self._output.pop(i)\n                end_idx -= 1\n            elif stripped.startswith(\"; Script generated by\"):\n                self._output[i] = \"; Script generated by PyonFX\\n\"\n                found_generated = True\n                i += 1\n            else:\n                i += 1\n\n        if not found_generated:\n            self._output.insert(start_idx, \"; Script generated by PyonFX\\n\")\n\n        # Writing to file\n        with open(self.path_output, \"w\", encoding=\"utf-8-sig\") as f:\n            f.writelines(self._output)\n            if self._output_extradata:\n                f.write(\"\\n[Aegisub Extradata]\\n\")\n                f.writelines(self._output_extradata)\n\n        self._saved = True\n\n        if quiet:\n            return\n\n        total_runtime = time.time() - self._ptime\n        avg_per_gen_line = total_runtime / self._plines if self._plines else 0.0\n\n        print(f\"\ud83d\udc30 Produced lines: {self._plines}\")\n        print(\n            f\"\u23f1\ufe0f  Total runtime: {total_runtime:.1f}s\"\n            f\" (avg {avg_per_gen_line:.3f}s per generated line)\"\n        )\n\n        if self._stats_by_effect:\n            print(\"\\n\ud83d\udcca STATISTICS\")\n\n            table_data = []\n            for eff, data in self._stats_by_effect.items():\n                calls = data[\"calls\"]\n                lines = data[\"lines\"]\n                time_s = data[\"time\"]\n                avg_call = time_s / calls if calls else 0.0\n\n                table_data.append(\n                    [\n                        eff,\n                        calls,\n                        lines,\n                        f\"{time_s:.3f}\",\n                        f\"{avg_call:.3f}\",\n                    ]\n                )\n\n            headers = [\n                \"Name\",\n                \"Calls\",\n                \"Lines\",\n                \"Time (s)\",\n                \"Avg/Call (s)\",\n                \"Avg/Line (s)\",\n            ]\n            print(\n                tabulate(\n                    table_data,\n                    headers=headers,\n                    tablefmt=\"rounded_grid\",\n                    numalign=\"right\",\n                )\n            )\n\n    def open_aegisub(self) -&gt; bool:\n        \"\"\"Attempt to open the output ASS file in Aegisub.\n\n        Returns:\n            bool: True if the output file is successfully opened in Aegisub, False otherwise.\n\n        Notes:\n            Make sure to call the save() method before invoking open_aegisub, or the output file may not exist.\n\n        See Also:\n            `open_mpv`\n        \"\"\"\n\n        # Check if it was saved\n        if not self._saved:\n            print(\n                \"[WARNING] You've tried to open the output with Aegisub before having saved. Check your code.\"\n            )\n            return False\n\n        if sys.platform == \"win32\":\n            os.startfile(self.path_output)\n        else:\n            try:\n                subprocess.call([\"aegisub\", os.path.abspath(self.path_output)])\n            except FileNotFoundError:\n                print(\"[WARNING] Aegisub not found.\")\n                return False\n\n        return True\n\n    def open_mpv(\n        self,\n        video_path: str | None = None,\n        *,\n        video_start: str | None = None,\n        full_screen: bool = False,\n        extra_mpv_options: list[str] = [],\n        aegisub_fallback: bool = True,\n    ) -&gt; bool:\n        \"\"\"Open the output subtitle file in MPV media player along with the associated video.\n\n        This method attempts to play the output ASS file using MPV and automatically handles subtitle hot-reload via an IPC socket.\n        If an existing MPV instance is detected, it sends a command to reload the subtitles;\n        if not, it launches a new MPV process with IPC enabled.\n\n        Args:\n            video_path: The absolute path to the video file to be played. If None, the video path from meta.video is used.\n            video_start: The starting time for video playback (e.g., \"00:01:23\"); if None, playback starts from the beginning.\n            full_screen: If True, launches MPV in full-screen mode; otherwise, in windowed mode.\n            extra_mpv_options: Additional command-line options to pass to MPV.\n            aegisub_fallback: If True, falls back to opening the output with Aegisub when MPV is not found.\n\n        Returns:\n            bool: True if MPV successfully launches or hot-reloads the subtitles; False otherwise.\n\n        Examples:\n            &gt;&gt;&gt; io.open_mpv(video_path=\"/path/to/video.mp4\", full_screen=True)\n\n        See Also:\n            [open_aegisub][pyonfx.ass_core.Ass.open_aegisub]\n        \"\"\"\n        if not self._saved:\n            print(\n                \"[ERROR] You've tried to open the output with MPV before having saved. Check your code.\"\n            )\n            return False\n\n        if not shutil.which(\"mpv\"):\n            if aegisub_fallback:\n                print(\n                    \"[WARNING] MPV not found in your environment variables\"\n                    \"(please refer to the documentation's 'Quick Start' section).\\n\\n\"\n                    \"Falling back to Aegisub.\"\n                )\n                self.open_aegisub()\n            else:\n                print(\n                    \"[ERROR] MPV not found in your environment variables\"\n                    \"(please refer to the documentation's 'Quick Start' section).\\n\\n\"\n                    \"Exiting.\"\n                )\n            return False\n\n        if video_path is None:\n            if self.meta.video and not self.meta.video.startswith(\"?dummy\"):\n                video_path = self.meta.video\n            else:\n                print(\n                    \"[ERROR] No video file specified and meta.video is None or is a dummy video.\"\n                )\n                return False\n\n        # Define IPC socket path for mpv communication\n        ipc_socket = (\n            r\"\\\\.\\pipe\\mpv_pyonfx\" if sys.platform == \"win32\" else \"/tmp/mpv_pyonfx\"\n        )\n\n        # Attempt hot-reload\n        if (\n            sys.platform == \"win32\" and \"mpv_pyonfx\" in os.listdir(r\"\\\\.\\pipe\")\n        ) or os.path.exists(ipc_socket):\n            try:\n                if sys.platform == \"win32\":\n                    with open(ipc_socket, \"r+b\", buffering=0) as pipe:\n                        pipe.write(\n                            json.dumps({\"command\": [\"sub-reload\"]}).encode(\"utf-8\")\n                            + b\"\\n\"\n                        )\n                else:\n                    with socket.socket(socket.AF_UNIX, socket.SOCK_STREAM) as sock:\n                        sock.connect(ipc_socket)\n                        sock.sendall(\n                            json.dumps({\"command\": [\"sub-reload\"]}).encode(\"utf-8\")\n                            + b\"\\n\"\n                        )\n                print(\"Hot-reload: Subtitles reloaded in existing mpv instance.\")\n                return True\n            except OSError as e:\n                print(\"Hot-reload failed with OSError:\", e)\n                return False\n\n        # Build command to launch mpv with IPC enabled\n        cmd = [\"mpv\", \"--input-ipc-server=\" + ipc_socket]\n        cmd.append(video_path)\n        if video_start is not None:\n            cmd.append(\"--start=\" + video_start)\n        if full_screen:\n            cmd.append(\"--fs\")\n        cmd.append(\"--sub-file=\" + self.path_output)\n        cmd.extend(extra_mpv_options)\n\n        try:\n            subprocess.Popen(cmd)\n        except FileNotFoundError:\n            print(\n                \"[WARNING] MPV not found in your environment variables.\\n\"\n                \"Please refer to the documentation's 'Quick Start' section.\"\n            )\n            return False\n\n        return True\n\n    def track(self, func: Callable[..., Any]) -&gt; Callable[..., Any]:\n        \"\"\"Decorator to track function performance, gathering timing statistics and monitoring progress.\n\n        This decorator automatically measures execution time, counts function calls,\n        and tracks the number of lines produced by the decorated function.\n        All statistics are displayed in the final output when save() is called.\n\n        Usage::\n\n            @io.track\n            def my_function(...):\n                ...\n        \"\"\"\n\n        def wrapper(*args: Any, **kwargs: Any):\n            prev_produced_lines = self._plines\n            start = time.perf_counter()\n\n            try:\n                return func(*args, **kwargs)\n            finally:\n                end = time.perf_counter()\n                stats = self._stats_by_effect[func.__name__]\n                stats[\"calls\"] += 1\n                stats[\"lines\"] += self._plines - prev_produced_lines\n                stats[\"time\"] += end - start\n\n        return wrapper\n</code></pre>"},{"location":"reference/ass_core/#pyonfx.ass_core.Ass.PIXEL_STYLE","title":"<code>PIXEL_STYLE = Style(name='p', fontname='Arial', fontsize=20, color1='FFFFFF', alpha1='00', color2='FFFFFF', alpha2='00', color3='000000', alpha3='0000', color4='000000', alpha4='0000', bold=False, italic=False, underline=False, strikeout=False, scale_x=100, scale_y=100, spacing=0, angle=0, border_style=False, outline=0, shadow=0, alignment=7, margin_l=0, margin_r=0, margin_v=0, encoding=1)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Lightweight style for pixels.</p>"},{"location":"reference/ass_core/#pyonfx.ass_core.Ass.__init__","title":"<code>__init__(path_input, path_output='output.ass', keep_original=True, extended=True, vertical_kanji=False)</code>","text":"<p>Initialize the ASS object.</p> <p>Parameters:</p> Name Type Description Default <code>path_input</code> <code>str</code> <p>The path for the input ASS file, which can be relative or absolute.</p> required <code>path_output</code> <code>str</code> <p>The path for the output ASS file (default: \"output.ass\").</p> <code>'output.ass'</code> <code>keep_original</code> <code>bool</code> <p>If True, the original lines are kept as comments in the output.</p> <code>True</code> <code>extended</code> <code>bool</code> <p>If True, extended information (including positioning, metrics, words, syllables, and characters) will be computed.</p> <code>True</code> <code>vertical_kanji</code> <code>bool</code> <p>If True, lines with alignment 4, 5 or 6 will be repositioned vertically.</p> <code>False</code> Source code in <code>pyonfx/ass_core.py</code> <pre><code>def __init__(\n    self,\n    path_input: str,\n    path_output: str = \"output.ass\",\n    keep_original: bool = True,\n    extended: bool = True,\n    vertical_kanji: bool = False,\n):\n    \"\"\"Initialize the ASS object.\n\n    Args:\n        path_input: The path for the input ASS file, which can be relative or absolute.\n        path_output: The path for the output ASS file (default: \"output.ass\").\n        keep_original: If True, the original lines are kept as comments in the output.\n        extended: If True, extended information (including positioning, metrics, words, syllables, and characters) will be computed.\n        vertical_kanji: If True, lines with alignment 4, 5 or 6 will be repositioned vertically.\n    \"\"\"\n    # Progress/statistics\n    self._saved = False\n    self._plines = 0  # Total produced lines\n    self._ptime = time.time()  # Total processing time\n    self._stats_by_effect: defaultdict[str, dict[str, float | int]] = defaultdict(\n        lambda: {\"lines\": 0, \"time\": 0.0, \"calls\": 0}\n    )\n\n    # Output buffers\n    self._output: list[str] = []\n    self._output_extradata: list[str] = []\n\n    # Public attributes\n    self.meta: Meta = Meta(\n        wrap_style=None,\n        scaled_border_and_shadow=None,\n        play_res_x=None,\n        play_res_y=None,\n        audio=None,\n        video=None,\n        timestamps=None,\n    )\n    self.styles: dict[str, Style] = {}\n    self.lines: list[Line] = []\n\n    # Getting absolute sub file path\n    self.path_input: str = _resolve_path(sys.argv[0], path_input)\n    if not os.path.isfile(self.path_input):\n        raise FileNotFoundError(\n            \"Invalid path for the Subtitle file: %s\" % self.path_input\n        )\n    self.path_output: str = _resolve_path(sys.argv[0], path_output)\n\n    # Parse the ASS file\n    current_section = \"\"\n    line_index = 0\n\n    with open(self.path_input, encoding=\"utf-8-sig\") as file:\n        for line in file:\n            # New section?\n            section_match = re.match(r\"^\\[([^\\]]*)\\]\", line)\n            if section_match:\n                current_section = section_match.group(1)\n                if current_section != \"Aegisub Extradata\":\n                    self._output.append(line)\n                continue\n\n            # Copy-paste lines\n            elif line.startswith(\"Format\") or not line.strip():\n                self._output.append(line)\n            # Sections parsers\n            elif current_section in (\"Script Info\", \"Aegisub Project Garbage\"):\n                line = self.meta.parse_line(line, self.path_input)\n                self._output.append(line)\n            elif current_section == \"V4+ Styles\":\n                style = Style.from_ass_line(line)\n                self.styles[style.name] = style\n                self._output.append(line)\n            elif current_section == \"Events\":\n                self.lines.append(Line.from_ass_line(line, line_index, self.styles))\n                if keep_original:\n                    self._output.append(\n                        re.sub(r\"^(Dialogue|Comment):\", \"Comment:\", line, count=1)\n                    )\n                line_index += 1\n            elif current_section == \"Aegisub Extradata\":\n                self._output_extradata.append(line)\n            elif (\n                current_section and line.strip()\n            ):  # Non-empty line in unknown section\n                raise ValueError(\n                    f\"Unexpected section in the input file: [{current_section}]\"\n                )\n\n    # Add extended information to lines and meta?\n    if extended:\n        self._process_extended_line_data(vertical_kanji)\n</code></pre>"},{"location":"reference/ass_core/#pyonfx.ass_core.Ass.replace_meta","title":"<code>replace_meta(meta)</code>","text":"<p>Replace metadata in the ASS output file.</p> <p>Parameters:</p> Name Type Description Default <code>meta</code> <code>Meta</code> <p>A Meta object containing the updated metadata.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; meta, _, _ = io.get_data()\n&gt;&gt;&gt; meta.wrap_style = 2\n&gt;&gt;&gt; io.replace_meta(meta)\n</code></pre> Source code in <code>pyonfx/ass_core.py</code> <pre><code>def replace_meta(self, meta: Meta) -&gt; None:\n    \"\"\"Replace metadata in the ASS output file.\n\n    Args:\n        meta: A Meta object containing the updated metadata.\n\n    Examples:\n        &gt;&gt;&gt; meta, _, _ = io.get_data()\n        &gt;&gt;&gt; meta.wrap_style = 2\n        &gt;&gt;&gt; io.replace_meta(meta)\n    \"\"\"\n    self.meta = meta\n    new_script_lines, new_garbage_lines = meta.serialize()\n\n    def get_key(line: str) -&gt; str:\n        return line.split(\":\", 1)[0].strip() if \":\" in line else \"\"\n\n    def update_section(section: str, new_lines: list[str]) -&gt; None:\n        # Build a dictionary of new meta lines keyed by their meta key\n        new_meta = {get_key(line): line for line in new_lines if get_key(line)}\n\n        # Locate the section header in the _output list\n        try:\n            header_idx = next(\n                i\n                for i, line in enumerate(self._output)\n                if line.strip().startswith(section)\n            )\n        except StopIteration:\n            if section == \"[Aegisub Project Garbage]\":\n                # Insert the Aegisub Project Garbage section after [Script Info] if available\n                try:\n                    script_idx = next(\n                        i\n                        for i, line in enumerate(self._output)\n                        if line.strip().startswith(\"[Script Info]\")\n                    )\n                    end_script_idx = next(\n                        (\n                            j\n                            for j, line in enumerate(\n                                self._output[script_idx + 1 :], start=script_idx + 1\n                            )\n                            if line.strip().startswith(\"[\")\n                        ),\n                        len(self._output),\n                    )\n                    insert_idx = end_script_idx\n                except StopIteration:\n                    insert_idx = len(self._output)\n                self._output.insert(insert_idx, f\"{section}\\n\")\n                self._output.insert(insert_idx + 1, \"\\n\")\n                header_idx = insert_idx\n            else:\n                raise ValueError(f\"{section} is not a valid section.\")\n\n        # Determine the end of the section (first line starting with '[' after header)\n        end_idx = (\n            next(\n                (\n                    j\n                    for j, line in enumerate(\n                        self._output[header_idx + 1 :], start=header_idx + 1\n                    )\n                    if line.strip().startswith(\"[\")\n                ),\n                len(self._output),\n            )\n            - 1\n        )\n\n        # Update only the meta-related lines in this section\n        updated_block = [\n            new_meta.pop(get_key(line), line) if get_key(line) else line\n            for line in self._output[header_idx + 1 : end_idx]\n        ]\n\n        # Append any new meta lines not already present\n        updated_block.extend(new_meta.values())\n        self._output[:] = (\n            self._output[: header_idx + 1] + updated_block + self._output[end_idx:]\n        )\n\n    update_section(\"[Script Info]\", new_script_lines)\n    update_section(\"[Aegisub Project Garbage]\", new_garbage_lines)\n</code></pre>"},{"location":"reference/ass_core/#pyonfx.ass_core.Ass.replace_style","title":"<code>replace_style(style_name, style)</code>","text":"<p>Replace an existing style in the ASS output file.</p> <p>Parameters:</p> Name Type Description Default <code>style_name</code> <code>str</code> <p>The name of the style to be replaced.</p> required <code>style</code> <code>Style</code> <p>A Style object containing the updated style parameters.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; style = styles['Default']\n&gt;&gt;&gt; style.fontname = 'Helvetica'\n&gt;&gt;&gt; io.replace_style('Default', style)\n</code></pre> See Also <p>add_style</p> Source code in <code>pyonfx/ass_core.py</code> <pre><code>def replace_style(self, style_name: str, style: Style) -&gt; None:\n    \"\"\"Replace an existing style in the ASS output file.\n\n    Args:\n        style_name: The name of the style to be replaced.\n        style: A Style object containing the updated style parameters.\n\n    Examples:\n        &gt;&gt;&gt; style = styles['Default']\n        &gt;&gt;&gt; style.fontname = 'Helvetica'\n        &gt;&gt;&gt; io.replace_style('Default', style)\n\n    See Also:\n        [add_style][pyonfx.ass_core.Ass.add_style]\n    \"\"\"\n    if style_name not in self.styles:\n        raise ValueError(f\"Style {style_name} does not exist.\")\n\n    # Update the style in the dictionary\n    self.styles[style_name] = style\n\n    # Serialize the new style\n    new_style_line = style.serialize(style_name)\n\n    # Update the corresponding style line in the _output list\n    for idx, line in enumerate(self._output):\n        stripped_line = line.lstrip()\n        if stripped_line.startswith(\"Style:\"):\n            parts = stripped_line[len(\"Style:\") :].split(\",\", 1)\n            if parts and parts[0].strip() == style_name:\n                self._output[idx] = new_style_line\n                break\n</code></pre>"},{"location":"reference/ass_core/#pyonfx.ass_core.Ass.add_style","title":"<code>add_style(style_name, style)</code>","text":"<p>Add a new style to the ASS output file.</p> <p>Parameters:</p> Name Type Description Default <code>style_name</code> <code>str</code> <p>The name for the new style. This name must be unique within the ASS file.</p> required <code>style</code> <code>Style</code> <p>A Style object containing the styling parameters for the new style.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; new_style = Style(name=\"NewStyle\", fontname=\"Arial\", fontsize=20, color1=\"FFFFFF\", alpha1=\"00\",\n...                    color2=\"FFFFFF\", alpha2=\"00\", color3=\"000000\", alpha3=\"0000\",\n...                    color4=\"000000\", alpha4=\"0000\", bold=False, italic=False, underline=False,\n...                    strikeout=False, scale_x=100, scale_y=100, spacing=0, angle=0, border_style=False,\n...                    outline=0, shadow=0, alignment=7, margin_l=0, margin_r=0, margin_v=0, encoding=1)\n&gt;&gt;&gt; io.add_style(\"NewStyle\", new_style)\n</code></pre> Notes <p>Ensure that the style name is unique in the current styles mapping.</p> See Also <p>replace_style</p> Source code in <code>pyonfx/ass_core.py</code> <pre><code>def add_style(self, style_name: str, style: Style) -&gt; None:\n    \"\"\"Add a new style to the ASS output file.\n\n    Args:\n        style_name: The name for the new style. This name must be unique within the ASS file.\n        style: A Style object containing the styling parameters for the new style.\n\n    Examples:\n        &gt;&gt;&gt; new_style = Style(name=\"NewStyle\", fontname=\"Arial\", fontsize=20, color1=\"FFFFFF\", alpha1=\"00\",\n        ...                    color2=\"FFFFFF\", alpha2=\"00\", color3=\"000000\", alpha3=\"0000\",\n        ...                    color4=\"000000\", alpha4=\"0000\", bold=False, italic=False, underline=False,\n        ...                    strikeout=False, scale_x=100, scale_y=100, spacing=0, angle=0, border_style=False,\n        ...                    outline=0, shadow=0, alignment=7, margin_l=0, margin_r=0, margin_v=0, encoding=1)\n        &gt;&gt;&gt; io.add_style(\"NewStyle\", new_style)\n\n    Notes:\n        Ensure that the style name is unique in the current styles mapping.\n\n    See Also:\n        [replace_style][pyonfx.ass_core.Ass.replace_style]\n    \"\"\"\n    if style_name in self.styles:\n        raise ValueError(f\"Style {style_name} already exists.\")\n\n    insertion_index = None\n    in_styles_section = False\n    for i, line in enumerate(self._output):\n        stripped = line.strip()\n        if stripped.startswith(\"[\") and \"V4+ Styles\" in stripped:\n            in_styles_section = True\n            continue\n        if in_styles_section and stripped.startswith(\"[\"):\n            insertion_index = i - 1\n            break\n    if insertion_index is None:\n        insertion_index = len(self._output)\n\n    style_line = style.serialize(style_name)\n    self._output.insert(insertion_index, style_line)\n    self.styles[style_name] = style\n</code></pre>"},{"location":"reference/ass_core/#pyonfx.ass_core.Ass.get_data","title":"<code>get_data()</code>","text":"<p>Retrieve metadata, styles, and subtitle lines from the ASS file.</p> <p>This utility method returns the essential components of a parsed ASS file:</p> <ul> <li>meta: A Meta object containing configuration and metadata.</li> <li>styles: A dictionary mapping style names to their corresponding Style objects.</li> <li>lines: A list of Line objects representing the subtitle dialogue events.</li> </ul> <p>Returns:</p> Name Type Description <code>tuple</code> <code>tuple[Meta, dict[str, Style], list[Line]]</code> <p>A tuple containing the meta object, the dictionary of styles, and the list of subtitle lines.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; meta, styles, lines = ass.get_data()\n</code></pre> Source code in <code>pyonfx/ass_core.py</code> <pre><code>def get_data(self) -&gt; tuple[Meta, dict[str, Style], list[Line]]:\n    \"\"\"Retrieve metadata, styles, and subtitle lines from the ASS file.\n\n    This utility method returns the essential components of a parsed ASS file:\n\n    - meta: A Meta object containing configuration and metadata.\n    - styles: A dictionary mapping style names to their corresponding Style objects.\n    - lines: A list of Line objects representing the subtitle dialogue events.\n\n    Returns:\n        tuple: A tuple containing the meta object, the dictionary of styles, and the list of subtitle lines.\n\n    Examples:\n        &gt;&gt;&gt; meta, styles, lines = ass.get_data()\n    \"\"\"\n    return self.meta, self.styles, self.lines\n</code></pre>"},{"location":"reference/ass_core/#pyonfx.ass_core.Ass.write_line","title":"<code>write_line(line)</code>","text":"<p>Write a subtitle line to the output buffer.</p> <p>Parameters:</p> Name Type Description Default <code>line</code> <code>Line</code> <p>A Line object representing a subtitle event.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; line = some_line_object  # a valid Line object\n&gt;&gt;&gt; io.write_line(line)\n</code></pre> Notes <p>This method only updates the internal buffer; you must call save() to persist the changes to disk.</p> See Also <p>save</p> Source code in <code>pyonfx/ass_core.py</code> <pre><code>def write_line(self, line: Line) -&gt; None:\n    \"\"\"Write a subtitle line to the output buffer.\n\n    Args:\n        line: A Line object representing a subtitle event.\n\n    Examples:\n        &gt;&gt;&gt; line = some_line_object  # a valid Line object\n        &gt;&gt;&gt; io.write_line(line)\n\n    Notes:\n        This method only updates the internal buffer; you must call save() to persist the changes to disk.\n\n    See Also:\n        [save][pyonfx.ass_core.Ass.save]\n    \"\"\"\n    self._output.append(line.serialize())\n    self._plines += 1\n</code></pre>"},{"location":"reference/ass_core/#pyonfx.ass_core.Ass.save","title":"<code>save(quiet=False)</code>","text":"<p>Save the processed subtitles to the output ASS file and print performance metrics.</p> <p>Parameters:</p> Name Type Description Default <code>quiet</code> <code>bool</code> <p>If True, suppresses the output messages during the save process. Defaults to False.</p> <code>False</code> Notes <p>Make sure to call this method after all subtitle processing is complete to persist your changes.</p> See Also <p>open_aegisub, open_mpv</p> Source code in <code>pyonfx/ass_core.py</code> <pre><code>def save(self, quiet: bool = False) -&gt; None:\n    \"\"\"Save the processed subtitles to the output ASS file and print performance metrics.\n\n    Args:\n        quiet: If True, suppresses the output messages during the save process. Defaults to False.\n\n    Notes:\n        Make sure to call this method after all subtitle processing is complete to persist your changes.\n\n    See Also:\n        [open_aegisub][pyonfx.ass_core.Ass.open_aegisub], [open_mpv][pyonfx.ass_core.Ass.open_mpv]\n    \"\"\"\n    # Add script generation info\n    header_idx = next(\n        i\n        for i, line in enumerate(self._output)\n        if line.strip().startswith(\"[Script Info]\")\n    )\n    start_idx = header_idx + 1\n    end_idx = next(\n        (\n            i\n            for i in range(start_idx, len(self._output))\n            if self._output[i].startswith(\"[\")\n        ),\n        len(self._output),\n    )\n\n    found_generated = False\n    i = start_idx\n    while i &lt; end_idx:\n        line = self._output[i]\n        stripped = line.lstrip()\n        if stripped.startswith(\"; http:\"):\n            self._output.pop(i)\n            end_idx -= 1\n        elif stripped.startswith(\"; Script generated by\"):\n            self._output[i] = \"; Script generated by PyonFX\\n\"\n            found_generated = True\n            i += 1\n        else:\n            i += 1\n\n    if not found_generated:\n        self._output.insert(start_idx, \"; Script generated by PyonFX\\n\")\n\n    # Writing to file\n    with open(self.path_output, \"w\", encoding=\"utf-8-sig\") as f:\n        f.writelines(self._output)\n        if self._output_extradata:\n            f.write(\"\\n[Aegisub Extradata]\\n\")\n            f.writelines(self._output_extradata)\n\n    self._saved = True\n\n    if quiet:\n        return\n\n    total_runtime = time.time() - self._ptime\n    avg_per_gen_line = total_runtime / self._plines if self._plines else 0.0\n\n    print(f\"\ud83d\udc30 Produced lines: {self._plines}\")\n    print(\n        f\"\u23f1\ufe0f  Total runtime: {total_runtime:.1f}s\"\n        f\" (avg {avg_per_gen_line:.3f}s per generated line)\"\n    )\n\n    if self._stats_by_effect:\n        print(\"\\n\ud83d\udcca STATISTICS\")\n\n        table_data = []\n        for eff, data in self._stats_by_effect.items():\n            calls = data[\"calls\"]\n            lines = data[\"lines\"]\n            time_s = data[\"time\"]\n            avg_call = time_s / calls if calls else 0.0\n\n            table_data.append(\n                [\n                    eff,\n                    calls,\n                    lines,\n                    f\"{time_s:.3f}\",\n                    f\"{avg_call:.3f}\",\n                ]\n            )\n\n        headers = [\n            \"Name\",\n            \"Calls\",\n            \"Lines\",\n            \"Time (s)\",\n            \"Avg/Call (s)\",\n            \"Avg/Line (s)\",\n        ]\n        print(\n            tabulate(\n                table_data,\n                headers=headers,\n                tablefmt=\"rounded_grid\",\n                numalign=\"right\",\n            )\n        )\n</code></pre>"},{"location":"reference/ass_core/#pyonfx.ass_core.Ass.open_aegisub","title":"<code>open_aegisub()</code>","text":"<p>Attempt to open the output ASS file in Aegisub.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the output file is successfully opened in Aegisub, False otherwise.</p> Notes <p>Make sure to call the save() method before invoking open_aegisub, or the output file may not exist.</p> See Also <p><code>open_mpv</code></p> Source code in <code>pyonfx/ass_core.py</code> <pre><code>def open_aegisub(self) -&gt; bool:\n    \"\"\"Attempt to open the output ASS file in Aegisub.\n\n    Returns:\n        bool: True if the output file is successfully opened in Aegisub, False otherwise.\n\n    Notes:\n        Make sure to call the save() method before invoking open_aegisub, or the output file may not exist.\n\n    See Also:\n        `open_mpv`\n    \"\"\"\n\n    # Check if it was saved\n    if not self._saved:\n        print(\n            \"[WARNING] You've tried to open the output with Aegisub before having saved. Check your code.\"\n        )\n        return False\n\n    if sys.platform == \"win32\":\n        os.startfile(self.path_output)\n    else:\n        try:\n            subprocess.call([\"aegisub\", os.path.abspath(self.path_output)])\n        except FileNotFoundError:\n            print(\"[WARNING] Aegisub not found.\")\n            return False\n\n    return True\n</code></pre>"},{"location":"reference/ass_core/#pyonfx.ass_core.Ass.open_mpv","title":"<code>open_mpv(video_path=None, *, video_start=None, full_screen=False, extra_mpv_options=[], aegisub_fallback=True)</code>","text":"<p>Open the output subtitle file in MPV media player along with the associated video.</p> <p>This method attempts to play the output ASS file using MPV and automatically handles subtitle hot-reload via an IPC socket. If an existing MPV instance is detected, it sends a command to reload the subtitles; if not, it launches a new MPV process with IPC enabled.</p> <p>Parameters:</p> Name Type Description Default <code>video_path</code> <code>str | None</code> <p>The absolute path to the video file to be played. If None, the video path from meta.video is used.</p> <code>None</code> <code>video_start</code> <code>str | None</code> <p>The starting time for video playback (e.g., \"00:01:23\"); if None, playback starts from the beginning.</p> <code>None</code> <code>full_screen</code> <code>bool</code> <p>If True, launches MPV in full-screen mode; otherwise, in windowed mode.</p> <code>False</code> <code>extra_mpv_options</code> <code>list[str]</code> <p>Additional command-line options to pass to MPV.</p> <code>[]</code> <code>aegisub_fallback</code> <code>bool</code> <p>If True, falls back to opening the output with Aegisub when MPV is not found.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if MPV successfully launches or hot-reloads the subtitles; False otherwise.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; io.open_mpv(video_path=\"/path/to/video.mp4\", full_screen=True)\n</code></pre> See Also <p>open_aegisub</p> Source code in <code>pyonfx/ass_core.py</code> <pre><code>def open_mpv(\n    self,\n    video_path: str | None = None,\n    *,\n    video_start: str | None = None,\n    full_screen: bool = False,\n    extra_mpv_options: list[str] = [],\n    aegisub_fallback: bool = True,\n) -&gt; bool:\n    \"\"\"Open the output subtitle file in MPV media player along with the associated video.\n\n    This method attempts to play the output ASS file using MPV and automatically handles subtitle hot-reload via an IPC socket.\n    If an existing MPV instance is detected, it sends a command to reload the subtitles;\n    if not, it launches a new MPV process with IPC enabled.\n\n    Args:\n        video_path: The absolute path to the video file to be played. If None, the video path from meta.video is used.\n        video_start: The starting time for video playback (e.g., \"00:01:23\"); if None, playback starts from the beginning.\n        full_screen: If True, launches MPV in full-screen mode; otherwise, in windowed mode.\n        extra_mpv_options: Additional command-line options to pass to MPV.\n        aegisub_fallback: If True, falls back to opening the output with Aegisub when MPV is not found.\n\n    Returns:\n        bool: True if MPV successfully launches or hot-reloads the subtitles; False otherwise.\n\n    Examples:\n        &gt;&gt;&gt; io.open_mpv(video_path=\"/path/to/video.mp4\", full_screen=True)\n\n    See Also:\n        [open_aegisub][pyonfx.ass_core.Ass.open_aegisub]\n    \"\"\"\n    if not self._saved:\n        print(\n            \"[ERROR] You've tried to open the output with MPV before having saved. Check your code.\"\n        )\n        return False\n\n    if not shutil.which(\"mpv\"):\n        if aegisub_fallback:\n            print(\n                \"[WARNING] MPV not found in your environment variables\"\n                \"(please refer to the documentation's 'Quick Start' section).\\n\\n\"\n                \"Falling back to Aegisub.\"\n            )\n            self.open_aegisub()\n        else:\n            print(\n                \"[ERROR] MPV not found in your environment variables\"\n                \"(please refer to the documentation's 'Quick Start' section).\\n\\n\"\n                \"Exiting.\"\n            )\n        return False\n\n    if video_path is None:\n        if self.meta.video and not self.meta.video.startswith(\"?dummy\"):\n            video_path = self.meta.video\n        else:\n            print(\n                \"[ERROR] No video file specified and meta.video is None or is a dummy video.\"\n            )\n            return False\n\n    # Define IPC socket path for mpv communication\n    ipc_socket = (\n        r\"\\\\.\\pipe\\mpv_pyonfx\" if sys.platform == \"win32\" else \"/tmp/mpv_pyonfx\"\n    )\n\n    # Attempt hot-reload\n    if (\n        sys.platform == \"win32\" and \"mpv_pyonfx\" in os.listdir(r\"\\\\.\\pipe\")\n    ) or os.path.exists(ipc_socket):\n        try:\n            if sys.platform == \"win32\":\n                with open(ipc_socket, \"r+b\", buffering=0) as pipe:\n                    pipe.write(\n                        json.dumps({\"command\": [\"sub-reload\"]}).encode(\"utf-8\")\n                        + b\"\\n\"\n                    )\n            else:\n                with socket.socket(socket.AF_UNIX, socket.SOCK_STREAM) as sock:\n                    sock.connect(ipc_socket)\n                    sock.sendall(\n                        json.dumps({\"command\": [\"sub-reload\"]}).encode(\"utf-8\")\n                        + b\"\\n\"\n                    )\n            print(\"Hot-reload: Subtitles reloaded in existing mpv instance.\")\n            return True\n        except OSError as e:\n            print(\"Hot-reload failed with OSError:\", e)\n            return False\n\n    # Build command to launch mpv with IPC enabled\n    cmd = [\"mpv\", \"--input-ipc-server=\" + ipc_socket]\n    cmd.append(video_path)\n    if video_start is not None:\n        cmd.append(\"--start=\" + video_start)\n    if full_screen:\n        cmd.append(\"--fs\")\n    cmd.append(\"--sub-file=\" + self.path_output)\n    cmd.extend(extra_mpv_options)\n\n    try:\n        subprocess.Popen(cmd)\n    except FileNotFoundError:\n        print(\n            \"[WARNING] MPV not found in your environment variables.\\n\"\n            \"Please refer to the documentation's 'Quick Start' section.\"\n        )\n        return False\n\n    return True\n</code></pre>"},{"location":"reference/ass_core/#pyonfx.ass_core.Ass.track","title":"<code>track(func)</code>","text":"<p>Decorator to track function performance, gathering timing statistics and monitoring progress.</p> <p>This decorator automatically measures execution time, counts function calls, and tracks the number of lines produced by the decorated function. All statistics are displayed in the final output when save() is called.</p> <p>Usage::</p> <pre><code>@io.track\ndef my_function(...):\n    ...\n</code></pre> Source code in <code>pyonfx/ass_core.py</code> <pre><code>def track(self, func: Callable[..., Any]) -&gt; Callable[..., Any]:\n    \"\"\"Decorator to track function performance, gathering timing statistics and monitoring progress.\n\n    This decorator automatically measures execution time, counts function calls,\n    and tracks the number of lines produced by the decorated function.\n    All statistics are displayed in the final output when save() is called.\n\n    Usage::\n\n        @io.track\n        def my_function(...):\n            ...\n    \"\"\"\n\n    def wrapper(*args: Any, **kwargs: Any):\n        prev_produced_lines = self._plines\n        start = time.perf_counter()\n\n        try:\n            return func(*args, **kwargs)\n        finally:\n            end = time.perf_counter()\n            stats = self._stats_by_effect[func.__name__]\n            stats[\"calls\"] += 1\n            stats[\"lines\"] += self._plines - prev_produced_lines\n            stats[\"time\"] += end - start\n\n    return wrapper\n</code></pre>"},{"location":"reference/convert/","title":"Convert","text":""},{"location":"reference/convert/#pyonfx.convert.Convert","title":"<code>Convert</code>","text":"<p>A collection of static conversion utilities for ASS formatting.</p> <p>It contains a variety of methods to convert between different representations used in the ASS format, such as timestamps, colors, text-to-shape transformations, and pixel generation from shapes and images. Although all methods are static, this class is maintained as a single unit for backward compatibility with earlier versions of the library.</p> Source code in <code>pyonfx/convert.py</code> <pre><code>class Convert:\n    \"\"\"A collection of static conversion utilities for ASS formatting.\n\n    It contains a variety of methods to convert between different representations used in the ASS format, such as timestamps, colors, text-to-shape transformations, and pixel generation from shapes and images.\n    Although all methods are static, this class is maintained as a single unit for backward compatibility with earlier versions of the library.\n    \"\"\"\n\n    @overload\n    @staticmethod\n    def time(ass_ms: int) -&gt; str: ...\n\n    @overload\n    @staticmethod\n    def time(ass_ms: str) -&gt; int: ...\n\n    @staticmethod\n    def time(ass_ms: int | str) -&gt; int | str:\n        \"\"\"Convert between milliseconds and ASS timestamp.\n\n        It rounds the milliseconds to the nearest centisecond when formatting an ASS timestamp, following the convention used in Aegisub.\n        Typically, you won't use this function directly for KFX or typesetting generation.\n\n        Args:\n            ass_ms: An integer representing time in milliseconds (must be non-negative) or a string formatted as an ASS timestamp (\"H:MM:SS.CS\").\n\n        Returns:\n            str or int: If an integer is provided, returns a string representing the converted ASS timestamp. If a string is provided, returns an integer representing the time in milliseconds.\n\n        Examples:\n            &gt;&gt;&gt; Convert.time(5000)\n            '0:00:05.00'\n            &gt;&gt;&gt; Convert.time('0:00:05.00')\n            5000\n        \"\"\"\n        # Milliseconds?\n        if isinstance(ass_ms, int) and ass_ms &gt;= 0:\n            # It round ms to cs. From https://github.com/Aegisub/Aegisub/blob/6f546951b4f004da16ce19ba638bf3eedefb9f31/libaegisub/include/libaegisub/ass/time.h#L32\n            # Ex: 49 ms to 50 ms\n            ass_ms = (ass_ms + 5) - (ass_ms + 5) % 10\n\n            return \"{:d}:{:02d}:{:02d}.{:02d}\".format(\n                math.floor(ass_ms / 3600000) % 10,\n                math.floor(ass_ms % 3600000 / 60000),\n                math.floor(ass_ms % 60000 / 1000),\n                math.floor(ass_ms % 1000 / 10),\n            )\n        # ASS timestamp?\n        elif isinstance(ass_ms, str) and re.fullmatch(r\"\\d:\\d+:\\d+\\.\\d+\", ass_ms):\n            return (\n                int(ass_ms[0]) * 3600000\n                + int(ass_ms[2:4]) * 60000\n                + int(ass_ms[5:7]) * 1000\n                + int(ass_ms[8:10]) * 10\n            )\n        else:\n            raise ValueError(\"Milliseconds or ASS timestamp expected\")\n\n    @staticmethod\n    def alpha_ass_to_dec(alpha_ass: str) -&gt; int:\n        \"\"\"Convert an ASS alpha string to a decimal value.\n\n        Args:\n            alpha_ass: A string with the ASS alpha value in the format '&amp;HXX&amp;'.\n\n        Returns:\n            int: The decimal value of the alpha component in the range [0, 255].\n\n        Examples:\n            &gt;&gt;&gt; Convert.alpha_ass_to_dec(\"&amp;HFF&amp;\")\n            255\n        \"\"\"\n        match = re.fullmatch(r\"&amp;H([0-9A-F]{2})&amp;\", alpha_ass)\n        if match is None:\n            raise ValueError(\n                f\"Provided ASS alpha string '{alpha_ass}' is not in the expected format '&amp;HXX&amp;'.\"\n            )\n        return int(match.group(1), 16)\n\n    @staticmethod\n    def alpha_dec_to_ass(alpha_dec: int | float) -&gt; str:\n        \"\"\"Convert a decimal alpha value to an ASS alpha string.\n\n        Args:\n            alpha_dec: An integer or float in the range [0, 255] representing an alpha value.\n\n        Returns:\n            str: The corresponding ASS alpha string in the format '&amp;HXX&amp;'.\n\n        Examples:\n            &gt;&gt;&gt; Convert.alpha_dec_to_ass(255)\n            '&amp;HFF&amp;'\n        \"\"\"\n        try:\n            if not 0 &lt;= alpha_dec &lt;= 255:\n                raise ValueError(\n                    f\"Provided alpha decimal '{alpha_dec}' is out of the range [0, 255].\"\n                )\n        except TypeError as e:\n            raise TypeError(\n                f\"Provided alpha decimal was expected of type 'int' or 'float', but you provided a '{type(alpha_dec)}'.\"\n            ) from e\n        return f\"&amp;H{round(alpha_dec):02X}&amp;\"\n\n    @staticmethod\n    def color(\n        c: (\n            str\n            | tuple[int, int, int]\n            | tuple[int, int, int, int]\n            | tuple[float, float, float]\n            | tuple[float, float, float, float]\n        ),\n        input_format: ColorModel,\n        output_format: ColorModel,\n        round_output: bool = True,\n    ) -&gt; (\n        str\n        | tuple[int, int, int]\n        | tuple[int, int, int, int]\n        | tuple[float, float, float]\n    ):\n        \"\"\"Convert a color value between different color models.\n\n        It supports various formats such as ASS, RGB, RGBA, HSV, and OKLAB.\n\n        Args:\n            c: A color value in the input format. This can be a string or a tuple of numbers.\n            input_format: A ColorModel enum indicating the format of the input color.\n            output_format: A ColorModel enum indicating the desired format of the output color.\n            round_output: A boolean that determines if numerical results should be rounded.\n\n        Returns:\n            The color converted to the specified output format, either as a string or as a tuple.\n\n        Examples:\n            &gt;&gt;&gt; Convert.color(\"&amp;H0000FF&amp;\", ColorModel.ASS, ColorModel.RGB)\n            (255, 0, 0)\n\n        See Also:\n            [`Convert.color_ass_to_rgb`][pyonfx.convert.Convert.color_ass_to_rgb], [`Convert.color_rgb_to_ass`][pyonfx.convert.Convert.color_rgb_to_ass]\n        \"\"\"\n        try:\n            # Text for exception if input is out of ranges\n            input_range_e = f\"Provided input '{c}' has value(s) out of the range \"\n\n            # Parse input, obtaining its corresponding (r,g,b,a) values\n            if input_format == ColorModel.ASS:\n                if not isinstance(c, str):\n                    raise TypeError(\"ASS color format requires string input\")\n                match = re.fullmatch(r\"&amp;H([0-9A-F]{2})([0-9A-F]{2})([0-9A-F]{2})&amp;\", c)\n                if match is None:\n                    raise ValueError(f\"Invalid ASS color format: {c}\")\n                (b, g, r), a = map(lambda x: int(x, 16), match.groups()), 255\n            elif input_format == ColorModel.ASS_STYLE:\n                if not isinstance(c, str):\n                    raise TypeError(\"ASS_STYLE color format requires string input\")\n                match = re.fullmatch(\"&amp;H\" + r\"([0-9A-F]{2})\" * 4, c)\n                if match is None:\n                    raise ValueError(f\"Invalid ASS_STYLE color format: {c}\")\n                a, b, g, r = map(lambda x: int(x, 16), match.groups())\n            elif input_format == ColorModel.RGB:\n                if not isinstance(c, tuple) or len(c) != 3:\n                    raise TypeError(\"RGB color format requires tuple of 3 values\")\n                if not all(0 &lt;= n &lt;= 255 for n in c):\n                    raise ValueError(input_range_e + \"[0, 255].\")\n                (r, g, b), a = map(int, c), 255\n            elif input_format == ColorModel.RGB_STR:\n                if not isinstance(c, str):\n                    raise TypeError(\"RGB_STR color format requires string input\")\n                match = re.fullmatch(r\"#?([0-9A-Fa-f]{2})\" * 3, c)\n                if match is None:\n                    raise ValueError(f\"Invalid RGB_STR color format: {c}\")\n                (r, g, b), a = map(lambda x: int(x, 16), match.groups()), 255\n            elif input_format == ColorModel.RGBA:\n                if not isinstance(c, tuple) or len(c) != 4:\n                    raise TypeError(\"RGBA color format requires tuple of 4 values\")\n                if not all(0 &lt;= n &lt;= 255 for n in c):\n                    raise ValueError(input_range_e + \"[0, 255].\")\n                r, g, b, a = map(int, c)\n            elif input_format == ColorModel.RGBA_STR:\n                if not isinstance(c, str):\n                    raise TypeError(\"RGBA_STR color format requires string input\")\n                match = re.fullmatch(r\"#?([0-9A-Fa-f]{2})\" * 4, c)\n                if match is None:\n                    raise ValueError(f\"Invalid RGBA_STR color format: {c}\")\n                r, g, b, a = map(lambda x: int(x, 16), match.groups())\n            elif input_format == ColorModel.HSV:\n                if not isinstance(c, tuple) or len(c) != 3:\n                    raise TypeError(\"HSV color format requires tuple of 3 values\")\n                h, s, v = c\n                if not (0 &lt;= h &lt; 360 and 0 &lt;= s &lt;= 100 and 0 &lt;= v &lt;= 100):\n                    raise ValueError(\n                        input_range_e + \"( [0, 360), [0, 100], [0, 100] ).\"\n                    )\n                h, s, v = h / 360, s / 100, v / 100\n                (r, g, b), a = (\n                    map(lambda x: int(255 * x), colorsys.hsv_to_rgb(h, s, v)),\n                    255,\n                )\n            elif input_format == ColorModel.OKLAB:\n                if not (isinstance(c, tuple) and len(c) == 3):\n                    raise TypeError(\"OKLAB color format requires tuple of 3 values\")\n                r, g, b = Convert.color_oklab_to_rgb(c)\n                a = 255\n        except (AttributeError, ValueError, TypeError) as e:\n            # AttributeError -&gt; re.fullmatch failed\n            # ValueError     -&gt; too many values to unpack\n            # TypeError      -&gt; in case the provided tuple is not a list of numbers\n            raise ValueError(\n                f\"Provided input '{c}' is not in the format '{input_format}'.\"\n            ) from e\n\n        # Convert (r,g,b,a) to the desired output_format\n        try:\n            if output_format == ColorModel.ASS:\n                return f\"&amp;H{round(b):02X}{round(g):02X}{round(r):02X}&amp;\"\n            elif output_format == ColorModel.ASS_STYLE:\n                return f\"&amp;H{round(a):02X}{round(b):02X}{round(g):02X}{round(r):02X}\"\n            elif output_format == ColorModel.RGB:\n                return (r, g, b)\n            elif output_format == ColorModel.RGB_STR:\n                return f\"#{round(r):02X}{round(g):02X}{round(b):02X}\"\n            elif output_format == ColorModel.RGBA:\n                return (r, g, b, a)\n            elif output_format == ColorModel.RGBA_STR:\n                return f\"#{round(r):02X}{round(g):02X}{round(b):02X}{round(a):02X}\"\n            elif output_format == ColorModel.HSV:\n                method = round if round_output else float\n                h, s, v = colorsys.rgb_to_hsv(r / 255, g / 255, b / 255)\n                return cast(\n                    tuple[float, float, float],\n                    (method(h * 360) % 360, method(s * 100), method(v * 100)),\n                )\n            elif output_format == ColorModel.OKLAB:\n                method = round if round_output else float\n                L, a, b = Convert.color_rgb_to_oklab((r, g, b))\n                return cast(\n                    tuple[float, float, float],\n                    (method(L), method(a), method(b)),\n                )\n            else:\n                raise ValueError(f\"Unsupported output_format: {output_format}\")\n        except NameError as e:\n            raise ValueError(f\"Unsupported input_format ('{input_format}').\") from e\n\n    @staticmethod\n    def color_ass_to_rgb(\n        color_ass: str, as_str: bool = False\n    ) -&gt; str | tuple[int, int, int]:\n        \"\"\"Convert an ASS color string to its RGB representation.\n\n        Args:\n            color_ass: A string in the ASS color format \"&amp;HBBGGRR&amp;\".\n            as_str: A boolean flag that, if True, returns the color as a hexadecimal string in the format \"#RRGGBB\"; otherwise returns a tuple (R, G, B).\n\n        Returns:\n            The RGB representation of the color either as a tuple of integers or as a hexadecimal string.\n\n        Examples:\n            &gt;&gt;&gt; Convert.color_ass_to_rgb(\"&amp;HABCDEF&amp;\")\n            (239, 205, 171)\n            &gt;&gt;&gt; Convert.color_ass_to_rgb(\"&amp;HABCDEF&amp;\", as_str=True)\n            \"#EFCDAB\"\n\n        See Also:\n            [`Convert.color_rgb_to_ass`][pyonfx.convert.Convert.color_rgb_to_ass]\n        \"\"\"\n        result = Convert.color(\n            color_ass, ColorModel.ASS, ColorModel.RGB_STR if as_str else ColorModel.RGB\n        )\n        if as_str:\n            return cast(str, result)\n        return cast(tuple[int, int, int], result)\n\n    @staticmethod\n    def color_ass_to_hsv(\n        color_ass: str, round_output: bool = True\n    ) -&gt; tuple[int, int, int] | tuple[float, float, float]:\n        \"\"\"Convert an ASS color string to its HSV representation.\n\n        Args:\n            color_ass: A string representing the ASS color (format \"&amp;HBBGGRR&amp;\").\n            round_output: A boolean that determines if numerical results should be rounded.\n\n        Returns:\n            A tuple representing the HSV values. The values are integers if round_output is True, or floats otherwise.\n\n        Examples:\n            &gt;&gt;&gt; Convert.color_ass_to_hsv(\"&amp;HABCDEF&amp;\")\n            (30, 28, 94)\n            &gt;&gt;&gt; Convert.color_ass_to_hsv(\"&amp;HABCDEF&amp;\", round_output=False)\n            (30.000000000000014, 28.451882845188294, 93.72549019607843)\n\n                print(Convert.color_ass_to_hsv(\"&amp;HABCDEF&amp;\"))\n                print(Convert.color_ass_to_hsv(\"&amp;HABCDEF&amp;\", round_output=False))\n\n        See Also:\n            [`Convert.color_rgb_to_hsv`][pyonfx.convert.Convert.color_rgb_to_hsv]\n        \"\"\"\n        result = Convert.color(color_ass, ColorModel.ASS, ColorModel.HSV, round_output)\n        return cast(tuple[int, int, int] | tuple[float, float, float], result)\n\n    @staticmethod\n    def color_ass_to_oklab(color_ass: str) -&gt; tuple[float, float, float]:\n        \"\"\"Convert an ASS color string to its OKLab representation.\n\n        Args:\n            color_ass: A string containing the ASS color in the format \"&amp;HBBGGRR&amp;\".\n\n        Returns:\n            A tuple of three floats corresponding to the OKLab color values.\n\n        Examples:\n            &gt;&gt;&gt; Convert.color_ass_to_oklab(\"&amp;HABCDEF&amp;\")\n            (0.8686973182678561, 0.023239204013187575, 0.054516093943155375)\n\n        See Also:\n            [`Convert.color_oklab_to_rgb`][pyonfx.convert.Convert.color_oklab_to_rgb]\n        \"\"\"\n        result = Convert.color(\n            color_ass, ColorModel.ASS, ColorModel.OKLAB, round_output=False\n        )\n        return cast(tuple[float, float, float], result)\n\n    @staticmethod\n    def color_rgb_to_ass(\n        color_rgb: str | tuple[int, int, int],\n    ) -&gt; str:\n        \"\"\"Convert an RGB color value to its ASS representation.\n\n        Args:\n            color_rgb: An RGB color value as a hexadecimal string or a tuple of three integers.\n\n        Returns:\n            str: The ASS color string in the format \"&amp;HBBGGRR&amp;\".\n\n        Examples:\n            &gt;&gt;&gt; Convert.color_rgb_to_ass(\"#ABCDEF\")\n            \"&amp;HEFCDAB&amp;\"\n\n        See Also:\n            [`Convert.color_ass_to_rgb`][pyonfx.convert.Convert.color_ass_to_rgb]\n        \"\"\"\n        result = Convert.color(\n            color_rgb,\n            ColorModel.RGB_STR if isinstance(color_rgb, str) else ColorModel.RGB,\n            ColorModel.ASS,\n        )\n        return cast(str, result)\n\n    @staticmethod\n    def color_rgb_to_hsv(\n        color_rgb: str | tuple[int | float, int | float, int | float],\n        round_output: bool = True,\n    ) -&gt; tuple[int, int, int] | tuple[float, float, float]:\n        \"\"\"Convert an RGB color value to its HSV representation.\n\n        Args:\n            color_rgb: An RGB color value as a hexadecimal string or a tuple of three numbers.\n            round_output: A boolean that determines if numerical results should be rounded.\n\n        Returns:\n            A tuple representing the HSV values. If round_output is True, the components are integers; otherwise, they are floats.\n\n        Examples:\n            &gt;&gt;&gt; Convert.color_rgb_to_hsv(\"#ABCDEF\")\n            (210, 28, 94)\n            &gt;&gt;&gt; Convert.color_rgb_to_hsv(\"#ABCDEF\", round_output=False)\n            (210.0, 28.45, 93.73)\n\n        See Also:\n            [`Convert.color_hsv_to_rgb`][pyonfx.convert.Convert.color_hsv_to_rgb]\n        \"\"\"\n        result = Convert.color(\n            color_rgb,\n            ColorModel.RGB_STR if isinstance(color_rgb, str) else ColorModel.RGB,\n            ColorModel.HSV,\n            round_output,\n        )\n        return cast(tuple[int, int, int] | tuple[float, float, float], result)\n\n    @staticmethod\n    def color_rgb_to_oklab(\n        color_rgb: tuple[int, int, int],\n    ) -&gt; tuple[float, float, float]:\n        \"\"\"Convert an sRGB color value to its OKLab representation.\n\n        Args:\n            color_rgb: A tuple (R, G, B) with each value in the range [0, 255].\n\n        Returns:\n            A tuple of three floats corresponding to the OKLab values (L, a, b) in the range [0, 1].\n\n        Examples:\n            &gt;&gt;&gt; Convert.color_rgb_to_oklab((255, 0, 0))\n            (0.6279553606145516, 0.22486306106597398, 0.1258462985307351)\n\n        See Also:\n            [`Convert.color_oklab_to_rgb`][pyonfx.convert.Convert.color_oklab_to_rgb]\n        \"\"\"\n        r, g, b = [x / 255 for x in color_rgb]\n\n        def srgb_to_linear(u: float) -&gt; float:\n            if u &lt;= 0.04045:\n                return u / 12.92\n            else:\n                return ((u + 0.055) / 1.055) ** 2.4\n\n        r_lin = srgb_to_linear(r)\n        g_lin = srgb_to_linear(g)\n        b_lin = srgb_to_linear(b)\n\n        # Linear sRGB to LMS\n        L_val = 0.4122214708 * r_lin + 0.5363325363 * g_lin + 0.0514459929 * b_lin\n        M_val = 0.2119034982 * r_lin + 0.6806995451 * g_lin + 0.1073969566 * b_lin\n        S_val = 0.0883024619 * r_lin + 0.2817188376 * g_lin + 0.6299787005 * b_lin\n\n        # Non-linear adaptation (cube root)\n        L_cbrt = L_val ** (1 / 3)\n        M_cbrt = M_val ** (1 / 3)\n        S_cbrt = S_val ** (1 / 3)\n\n        # LMS to OKLab\n        L_ok = 0.2104542553 * L_cbrt + 0.7936177850 * M_cbrt - 0.0040720468 * S_cbrt\n        a_ok = 1.9779984951 * L_cbrt - 2.4285922050 * M_cbrt + 0.4505937099 * S_cbrt\n        b_ok = 0.0259040371 * L_cbrt + 0.7827717662 * M_cbrt - 0.8086757660 * S_cbrt\n\n        return (L_ok, a_ok, b_ok)\n\n    @staticmethod\n    def color_hsv_to_ass(\n        color_hsv: tuple[int | float, int | float, int | float],\n    ) -&gt; str:\n        \"\"\"Convert an HSV color value to its ASS representation.\n\n        Args:\n            color_hsv: A tuple (H, S, V) representing the HSV color.\n\n        Returns:\n            str: The ASS color string corresponding to the given HSV value.\n\n        Examples:\n            &gt;&gt;&gt; Convert.color_hsv_to_ass((100, 100, 100))\n            \"&amp;H00FF55&amp;\"\n\n        See Also:\n            [`Convert.color_ass_to_hsv`][pyonfx.convert.Convert.color_ass_to_hsv]\n        \"\"\"\n        result = Convert.color(color_hsv, ColorModel.HSV, ColorModel.ASS)\n        return cast(str, result)\n\n    @staticmethod\n    def color_hsv_to_rgb(\n        color_hsv: tuple[int | float, int | float, int | float],\n        as_str: bool = False,\n        round_output: bool = True,\n    ) -&gt; str | tuple[int, int, int] | tuple[float, float, float]:\n        \"\"\"Convert an HSV color value to its RGB representation.\n\n        Args:\n            color_hsv: A tuple representing the HSV color with H in [0, 360), S and V in [0, 100].\n            as_str: A boolean flag that, if True, returns the RGB value as a hexadecimal string \"#RRGGBB\"; otherwise as a tuple (R, G, B).\n            round_output: A boolean that determines if numerical results should be rounded.\n\n        Returns:\n            Either a tuple (R, G, B) or a string \"#RRGGBB\" representing the RGB color.\n\n        Examples:\n            &gt;&gt;&gt; Convert.color_hsv_to_rgb((100, 100, 100))\n            (85, 255, 0)\n            &gt;&gt;&gt; Convert.color_hsv_to_rgb((100, 100, 100), as_str=True)\n            \"#55FF00\"\n            &gt;&gt;&gt; Convert.color_hsv_to_rgb((100, 100, 100), round_output=False)\n            (84.99999999999999, 255.0, 0.0)\n\n        See Also:\n            [`Convert.color_rgb_to_hsv`][pyonfx.convert.Convert.color_rgb_to_hsv]\n        \"\"\"\n        result = Convert.color(\n            color_hsv,\n            ColorModel.HSV,\n            ColorModel.RGB_STR if as_str else ColorModel.RGB,\n            round_output,\n        )\n        if as_str:\n            return cast(str, result)\n        return cast(tuple[int, int, int] | tuple[float, float, float], result)\n\n    @staticmethod\n    def color_oklab_to_rgb(\n        color_oklab: tuple[float, float, float],\n    ) -&gt; tuple[int, int, int]:\n        \"\"\"Convert an OKLab color value to its sRGB representation.\n\n        Args:\n            color_oklab: A tuple (L, a, b) representing the OKLab color, with values typically in the range [0, 1].\n\n        Returns:\n            A tuple of three integers (R, G, B) in the range [0, 255] representing the sRGB color.\n\n        Examples:\n            &gt;&gt;&gt; Convert.color_oklab_to_rgb((0.627, 0.224, 0.125))\n            (255, 0, 0)  # example output\n\n        See Also:\n            [`Convert.color_rgb_to_oklab`][pyonfx.convert.Convert.color_rgb_to_oklab]\n        \"\"\"\n        L, a_val, b_val = color_oklab\n\n        # OKLab to LMS\n        l_ = L + 0.3963377774 * a_val + 0.2158037573 * b_val\n        m_ = L - 0.1055613458 * a_val - 0.0638541728 * b_val\n        s_ = L - 0.0894841775 * a_val - 1.2914855480 * b_val\n\n        # LMS to linear RGB\n        L_lin = l_**3\n        M_lin = m_**3\n        S_lin = s_**3\n\n        def linear_to_srgb(u: float) -&gt; float:\n            if u &lt;= 0.0031308:\n                return 12.92 * u\n            else:\n                return 1.055 * (u ** (1 / 2.4)) - 0.055\n\n        # Linear RGB to sRGB\n        r = linear_to_srgb(\n            4.0767416621 * L_lin - 3.3077115913 * M_lin + 0.2309699292 * S_lin\n        )\n        g = linear_to_srgb(\n            -1.2684380046 * L_lin + 2.6097574011 * M_lin - 0.3413193965 * S_lin\n        )\n        b = linear_to_srgb(\n            -0.0041960863 * L_lin - 0.7034186147 * M_lin + 1.7076147010 * S_lin\n        )\n\n        # Clamp and convert to 8-bit\n        r = max(0.0, min(1.0, r))\n        g = max(0.0, min(1.0, g))\n        b = max(0.0, min(1.0, b))\n\n        return (round(r * 255), round(g * 255), round(b * 255))\n\n    @staticmethod\n    def color_oklab_to_ass(color_oklab: tuple[float, float, float]) -&gt; str:\n        \"\"\"Convert an OKLab color value to its ASS representation.\n\n        Args:\n            color_oklab: A tuple of three floats representing the OKLab color.\n\n        Returns:\n            str: The ASS color string in the format \"&amp;HBBGGRR&amp;\" corresponding to the provided OKLab color.\n\n        Examples:\n            &gt;&gt;&gt; Convert.color_oklab_to_ass((0.627, 0.224, 0.125))\n            \"&amp;H00FF55&amp;\"  # example output\n\n        See Also:\n            [`Convert.color_ass_to_oklab`][pyonfx.convert.Convert.color_ass_to_oklab]\n        \"\"\"\n        result = Convert.color(color_oklab, ColorModel.OKLAB, ColorModel.ASS)\n        return cast(str, result)\n\n    @staticmethod\n    def text_to_shape(\n        obj: \"Line | Word | Syllable | Char\",\n        fscx: float | None = None,\n        fscy: float | None = None,\n    ) -&gt; \"Shape\":\n        \"\"\"Convert text with style information to an ASS shape.\n\n        Converting text to a shape converts the text into a detailed geometry representation,\n        exposing individual control points that can be manipulated for precise deformations.\n\n        Args:\n            obj: An instance of a Line, Word, Syllable, or Char that contains both text content and style information.\n            fscx: Optional; a float representing an override for the style's horizontal scale (scale_x) during conversion.\n            fscy: Optional; a float representing an override for the style's vertical scale (scale_y) during conversion.\n\n        Returns:\n            Shape: An ASS shape object corresponding to the rendered text with applied style attributes.\n\n        Examples:\n            &gt;&gt;&gt; l.text = \"{\\\\an7\\\\pos(%.3f,%.3f)\\\\p1}%s\" % (line.left, line.top, Convert.text_to_shape(line))\n            &gt;&gt;&gt; io.write_line(l)\n\n        Notes:\n            A known limitation is that the output line must use '\\\\an7' and '\\\\pos(.left, .top)' for accurate displacement.\n\n        See Also:\n            [`Convert.text_to_clip`][pyonfx.convert.Convert.text_to_clip]\n        \"\"\"\n        if obj.styleref is None:\n            raise ValueError(\"Object must have a style reference and text content\")\n\n        # Obtaining information and editing values of style if requested\n        original_scale_x = obj.styleref.scale_x\n        original_scale_y = obj.styleref.scale_y\n\n        # Editing temporary the style to properly get the shape\n        if fscx is not None:\n            obj.styleref.scale_x = fscx\n        if fscy is not None:\n            obj.styleref.scale_y = fscy\n\n        # Obtaining font information from style and obtaining shape\n        font = Font(obj.styleref)\n        shape = font.text_to_shape(obj.text)\n        # Clearing resources to not let overflow errors take over\n        del font\n\n        # Restoring values of style and returning the shape converted\n        if fscx is not None:\n            obj.styleref.scale_x = original_scale_x\n        if fscy is not None:\n            obj.styleref.scale_y = original_scale_y\n        return shape\n\n    @staticmethod\n    def text_to_clip(\n        obj: \"Line | Word | Syllable | Char\",\n        an: int = 5,\n        fscx: float | None = None,\n        fscy: float | None = None,\n    ) -&gt; \"Shape\":\n        \"\"\"Convert text with style information to an ASS shape for clipping.\n\n        Because a shape used in a clip cannot be directly positioned using the \\\\pos() command,\n        the function applies additional translation and scaling to ensure proper alignment.\n\n        Args:\n            obj: An instance of Line, Word, Syllable, or Char that carries text content and associated style information.\n            an: An integer specifying the desired alignment for the shape. Must be between 1 and 9.\n            fscx: Optional; a float overriding the style's horizontal scale (scale_x) during conversion.\n            fscy: Optional; a float overriding the style's vertical scale (scale_y) during conversion.\n\n        Returns:\n            Shape: An ASS shape object generated from the text, adjusted for clipping use.\n\n        Examples:\n            &gt;&gt;&gt; l.text = \"{\\\\an5\\\\pos(%.3f,%.3f)\\\\clip(%s)}%s\" % (line.center, line.middle, Convert.text_to_clip(line), Shape.circle(20).move(line.center, line.middle))\n            &gt;&gt;&gt; io.write_line(l)\n\n        See Also:\n            [`Convert.text_to_shape`][pyonfx.convert.Convert.text_to_shape]\n        \"\"\"\n        if obj.styleref is None:\n            raise ValueError(\"Object must have a style reference\")\n\n        # Checking for errors\n        if an &lt; 1 or an &gt; 9:\n            raise ValueError(\"Alignment value must be an integer between 1 and 9\")\n\n        # Setting default values\n        if fscx is None:\n            fscx = obj.styleref.scale_x\n        if fscy is None:\n            fscy = obj.styleref.scale_y\n\n        # Obtaining text converted to shape\n        shape = Convert.text_to_shape(obj, fscx, fscy)\n\n        # Setting mult_x based on alignment\n        if an % 3 == 1:  # an=1 or an=4 or an=7\n            mult_x = 0\n        elif an % 3 == 2:  # an=2 or an=5 or an=8\n            mult_x = 1 / 2\n        else:\n            mult_x = 1\n\n        # Setting mult_y based on alignment\n        if an &lt; 4:\n            mult_y = 1\n        elif an &lt; 7:\n            mult_y = 1 / 2\n        else:\n            mult_y = 0\n\n        # Calculating offsets\n        cx = (\n            obj.left\n            - obj.width * mult_x * (fscx - obj.styleref.scale_x) / obj.styleref.scale_x\n        )\n        cy = (\n            obj.top\n            - obj.height * mult_y * (fscy - obj.styleref.scale_y) / obj.styleref.scale_y\n        )\n\n        return shape.move(cx, cy)\n\n    @staticmethod\n    def text_to_pixels(\n        obj: \"Line | Word | Syllable | Char\",\n        supersampling: int = 8,\n        output_rgba: bool = False,\n    ) -&gt; PixelCollection:\n        \"\"\"Convert styled text into a pixel representation.\n\n        This conversion is useful for creating effects like decaying text or light effects.\n\n        Args:\n            obj: A text object (Line, Word, Syllable, or Char) containing both content and style data.\n            supersampling: An integer supersampling factor that controls the anti-aliasing quality. Higher values yield smoother edges but require more processing time.\n            output_rgba: A boolean flag indicating the format of the alpha value. If True, the alpha value for each pixel will be a numeric value between 0 and 255; otherwise, it will be returned as an ASS alpha string.\n\n        Returns:\n            PixelCollection: A collection of pixels, where each pixel includes x and y coordinates and an alpha value representing transparency.\n\n        Examples:\n            &gt;&gt;&gt; io.add_style(\"p\", Ass.PIXEL_STYLE)\n            &gt;&gt;&gt; l.style = \"p\"\n            &gt;&gt;&gt; for pixel in Convert.text_to_pixels(l):\n            ...     x, y = l.left + pixel.x, l.top + pixel.y\n            ...     alpha = \"\\\\alpha\" + str(pixel.alpha) if str(pixel.alpha) != \"&amp;HFF&amp;\" else \"\"\n            ...     l.text = \"{\\\\p1\\\\pos(%d,%d)%s}%s\" % (x, y, alpha, Shape.PIXEL)\n            ...     io.write_line(l)\n\n        Notes:\n            To optimize the ASS file size, it is recommended to use a dedicated pixel style.\n            A pre-made pixel style ([`Ass.PIXEL_STYLE`][pyonfx.ass_core.Ass.PIXEL_STYLE]) is provided in the Ass class and can be added to your ASS output using the [`add_style`][pyonfx.ass_core.Ass.add_style] method.\n\n        See Also:\n            [`Convert.shape_to_pixels`][pyonfx.convert.Convert.shape_to_pixels]\n        \"\"\"\n        shape = Convert.text_to_shape(obj).move(obj.left % 1, obj.top % 1)\n        return Convert.shape_to_pixels(shape, supersampling, output_rgba)\n\n    @staticmethod\n    def shape_to_pixels(\n        shape: \"Shape\", supersampling: int = 8, output_rgba: bool = False\n    ) -&gt; PixelCollection:\n        \"\"\"Convert a Shape object into a pixel representation.\n\n        This conversion is useful for creating effects like decaying shapes or light effects.\n\n        Args:\n            shape: A Shape object representing the geometric outline to be sampled.\n            supersampling: An integer (\u2265 1) that controls the anti-aliasing resolution. Higher values yield smoother results but increase processing time.\n            output_rgba: A boolean flag indicating the format of the alpha value. If True, the alpha value for each pixel will be a numeric value between 0 and 255; otherwise, it will be returned as an ASS alpha string.\n\n        Returns:\n            PixelCollection: A collection of Pixel objects, where each pixel includes x and y coordinates and an alpha value representing transparency.\n\n        Examples:\n            &gt;&gt;&gt; io.add_style(\"p\", Ass.PIXEL_STYLE)\n            &gt;&gt;&gt; l.style = \"p\"\n            &gt;&gt;&gt; for pixel in Convert.shape_to_pixels(Shape.polygon(4, 20)):\n            ...     x, y = l.left + pixel.x, l.top + pixel.y\n            ...     alpha = \"\\\\alpha\" + str(pixel.alpha) if str(pixel.alpha) != \"&amp;HFF&amp;\" else \"\"\n            ...     l.text = \"{\\\\p1\\\\pos(%d,%d)%s}%s\" % (x, y, alpha, Shape.PIXEL)\n            ...     io.write_line(l)\n\n        Notes:\n            To optimize the ASS file size, it is recommended to use a dedicated pixel style.\n            A pre-made pixel style ([`Ass.PIXEL_STYLE`][pyonfx.ass_core.Ass.PIXEL_STYLE]) is provided in the Ass class and can be added to your ASS output using the [`add_style`][pyonfx.ass_core.Ass.add_style] method.\n\n        See Also:\n            [`Convert.text_to_pixels`][pyonfx.convert.Convert.text_to_pixels]\n        \"\"\"\n        # Validate input\n        if supersampling &lt; 1 or not isinstance(supersampling, int):\n            raise ValueError(\n                \"supersampling must be a positive integer (got %r)\" % supersampling\n            )\n\n        # Convert to Shapely geometry\n        multipolygon = shape.to_multipolygon()\n        if multipolygon.is_empty:\n            return PixelCollection([])\n\n        # Upscale and shift so the bbox is in +ve quadrant\n        multipolygon = _shapely_scale(\n            multipolygon, xfact=supersampling, yfact=supersampling, origin=(0.0, 0.0)\n        )\n\n        min_x, min_y, max_x, max_y = multipolygon.bounds\n        shift_x = -1 * (min_x - (min_x % supersampling))\n        shift_y = -1 * (min_y - (min_y % supersampling))\n        multipolygon = _shapely_translate(multipolygon, xoff=shift_x, yoff=shift_y)\n\n        # Compute high-res grid size (multiple of supersampling)\n        _, _, max_x, max_y = multipolygon.bounds\n        high_w = int(math.ceil(max_x))\n        high_h = int(math.ceil(max_y))\n        if high_w % supersampling:\n            high_w += supersampling - (high_w % supersampling)\n        if high_h % supersampling:\n            high_h += supersampling - (high_h % supersampling)\n\n        # Mark which high-res pixels fall inside the geometry (centre sampling)\n        xs = np.arange(0.5, high_w + 0.5, 1.0, dtype=np.float64)\n        ys = np.arange(0.5, high_h + 0.5, 1.0, dtype=np.float64)\n        X, Y = np.meshgrid(xs, ys)\n        mask = _shapely_contains(multipolygon, X, Y)\n\n        # Downsample mask to screen resolution\n        low_h = high_h // supersampling\n        low_w = high_w // supersampling\n        mask_rs = mask.reshape(low_h, supersampling, low_w, supersampling)\n        coverage_cnt = mask_rs.sum(axis=(1, 3))\n\n        # Convert coverage to alpha\n        denom = supersampling * supersampling\n        alpha_arr = np.rint((denom - coverage_cnt) * 255 / denom).astype(np.int16)\n\n        # Build output PixelCollection, skipping fully transparent pixels using vectorized selection\n        downscale = 1 / supersampling\n        shift_x_low = shift_x * downscale\n        shift_y_low = shift_y * downscale\n\n        non_transparent = np.argwhere(alpha_arr &lt; 255)\n        pixels = [\n            Pixel(\n                x=int(xi - shift_x_low),\n                y=int(yi - shift_y_low),\n                alpha=(\n                    int(alpha_arr[yi, xi])\n                    if output_rgba\n                    else Convert.alpha_dec_to_ass(int(alpha_arr[yi, xi]))\n                ),\n            )\n            for yi, xi in non_transparent\n        ]\n\n        return PixelCollection(pixels)\n\n    @staticmethod\n    def image_to_pixels(\n        image_path: str,\n        width: int | None = None,\n        height: int | None = None,\n        skip_transparent: bool = True,\n        output_rgba: bool = False,\n    ) -&gt; PixelCollection:\n        \"\"\"Convert an image file to a pixel representation.\n\n        Args:\n            image_path: A file path to an image (absolute or relative to the script).\n            width: Optional; an integer specifying the target width for rescaling. If None, the original width is used.\n            height: Optional; an integer specifying the target height for rescaling. If None, the original height is used. If only one dimension is provided, the aspect ratio is preserved.\n            skip_transparent: A boolean flag indicating whether fully transparent pixels (alpha == 0) should be skipped.\n            output_rgba: A boolean flag indicating the format of the alpha value. If True, each pixel's alpha value will be a number between 0 and 255 and the color as an RGB tuple; otherwise, the pixel's color is an ASS formatted string and the alpha is an ASS alpha string.\n\n        Returns:\n            PixelCollection: A collection of Pixel objects, where each pixel includes x and y coordinates and an alpha value representing transparency.\n\n        Examples:\n            &gt;&gt;&gt; pixels = Convert.image_to_pixels(\"path_to_image/sample.png\", width=50)\n            &gt;&gt;&gt; for pixel in pixels:\n            ...     print(pixel.x, pixel.y, pixel.alpha)\n\n        Notes:\n            To optimize the ASS file size, it is recommended to use a dedicated pixel style.\n            A pre-made pixel style ([`Ass.PIXEL_STYLE`][pyonfx.ass_core.Ass.PIXEL_STYLE]) is provided in the Ass class and can be added to your ASS output using the [`add_style`][pyonfx.ass_core.Ass.add_style] method.\n\n        See Also:\n            [`PixelCollection.apply_texture`][pyonfx.pixel.PixelCollection.apply_texture]\n        \"\"\"\n        dirname = os.path.dirname(os.path.abspath(sys.argv[0]))\n        if not os.path.isabs(image_path):\n            image_path = os.path.join(dirname, image_path)\n        try:\n            img = Image.open(image_path)\n        except Exception as e:\n            raise ValueError(f\"Could not open image at '{image_path}': {e}\")\n        if img.mode != \"RGBA\":\n            img = img.convert(\"RGBA\")\n\n        # Rescale image if width or height is specified\n        if width is not None or height is not None:\n            try:\n                # If only one dimension is specified, maintain aspect ratio\n                original_width, original_height = img.size\n                if width is not None and height is None:\n                    ratio = width / original_width\n                    height = int(original_height * ratio)\n                elif height is not None and width is None:\n                    ratio = height / original_height\n                    width = int(original_width * ratio)\n\n                if width is not None and height is not None:\n                    img = img.resize((width, height), Image.Resampling.LANCZOS)\n            except Exception as e:\n                raise ValueError(f\"Error resizing image: {e}\")\n\n        width, height = img.size\n        pixels_data = list(img.getdata())  # type: ignore[arg-type]\n\n        pixels = []\n        for i, (r, g, b, a) in enumerate(pixels_data):\n            if skip_transparent and a == 0:\n                continue\n            x = i % width\n            y = i // width\n            if output_rgba:\n                pixel_color = (r, g, b)\n                pixel_alpha = 255 - a\n            else:\n                pixel_color = Convert.color_rgb_to_ass((r, g, b))\n                pixel_alpha = Convert.alpha_dec_to_ass(255 - a)\n            pixels.append(Pixel(x=x, y=y, color=pixel_color, alpha=pixel_alpha))\n\n        return PixelCollection(pixels)\n</code></pre>"},{"location":"reference/convert/#pyonfx.convert.Convert.time","title":"<code>time(ass_ms)</code>  <code>staticmethod</code>","text":"<pre><code>time(ass_ms: int) -&gt; str\n</code></pre><pre><code>time(ass_ms: str) -&gt; int\n</code></pre> <p>Convert between milliseconds and ASS timestamp.</p> <p>It rounds the milliseconds to the nearest centisecond when formatting an ASS timestamp, following the convention used in Aegisub. Typically, you won't use this function directly for KFX or typesetting generation.</p> <p>Parameters:</p> Name Type Description Default <code>ass_ms</code> <code>int | str</code> <p>An integer representing time in milliseconds (must be non-negative) or a string formatted as an ASS timestamp (\"H:MM:SS.CS\").</p> required <p>Returns:</p> Type Description <code>int | str</code> <p>str or int: If an integer is provided, returns a string representing the converted ASS timestamp. If a string is provided, returns an integer representing the time in milliseconds.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; Convert.time(5000)\n'0:00:05.00'\n&gt;&gt;&gt; Convert.time('0:00:05.00')\n5000\n</code></pre> Source code in <code>pyonfx/convert.py</code> <pre><code>@staticmethod\ndef time(ass_ms: int | str) -&gt; int | str:\n    \"\"\"Convert between milliseconds and ASS timestamp.\n\n    It rounds the milliseconds to the nearest centisecond when formatting an ASS timestamp, following the convention used in Aegisub.\n    Typically, you won't use this function directly for KFX or typesetting generation.\n\n    Args:\n        ass_ms: An integer representing time in milliseconds (must be non-negative) or a string formatted as an ASS timestamp (\"H:MM:SS.CS\").\n\n    Returns:\n        str or int: If an integer is provided, returns a string representing the converted ASS timestamp. If a string is provided, returns an integer representing the time in milliseconds.\n\n    Examples:\n        &gt;&gt;&gt; Convert.time(5000)\n        '0:00:05.00'\n        &gt;&gt;&gt; Convert.time('0:00:05.00')\n        5000\n    \"\"\"\n    # Milliseconds?\n    if isinstance(ass_ms, int) and ass_ms &gt;= 0:\n        # It round ms to cs. From https://github.com/Aegisub/Aegisub/blob/6f546951b4f004da16ce19ba638bf3eedefb9f31/libaegisub/include/libaegisub/ass/time.h#L32\n        # Ex: 49 ms to 50 ms\n        ass_ms = (ass_ms + 5) - (ass_ms + 5) % 10\n\n        return \"{:d}:{:02d}:{:02d}.{:02d}\".format(\n            math.floor(ass_ms / 3600000) % 10,\n            math.floor(ass_ms % 3600000 / 60000),\n            math.floor(ass_ms % 60000 / 1000),\n            math.floor(ass_ms % 1000 / 10),\n        )\n    # ASS timestamp?\n    elif isinstance(ass_ms, str) and re.fullmatch(r\"\\d:\\d+:\\d+\\.\\d+\", ass_ms):\n        return (\n            int(ass_ms[0]) * 3600000\n            + int(ass_ms[2:4]) * 60000\n            + int(ass_ms[5:7]) * 1000\n            + int(ass_ms[8:10]) * 10\n        )\n    else:\n        raise ValueError(\"Milliseconds or ASS timestamp expected\")\n</code></pre>"},{"location":"reference/convert/#pyonfx.convert.Convert.alpha_ass_to_dec","title":"<code>alpha_ass_to_dec(alpha_ass)</code>  <code>staticmethod</code>","text":"<p>Convert an ASS alpha string to a decimal value.</p> <p>Parameters:</p> Name Type Description Default <code>alpha_ass</code> <code>str</code> <p>A string with the ASS alpha value in the format '&amp;HXX&amp;'.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The decimal value of the alpha component in the range [0, 255].</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; Convert.alpha_ass_to_dec(\"&amp;HFF&amp;\")\n255\n</code></pre> Source code in <code>pyonfx/convert.py</code> <pre><code>@staticmethod\ndef alpha_ass_to_dec(alpha_ass: str) -&gt; int:\n    \"\"\"Convert an ASS alpha string to a decimal value.\n\n    Args:\n        alpha_ass: A string with the ASS alpha value in the format '&amp;HXX&amp;'.\n\n    Returns:\n        int: The decimal value of the alpha component in the range [0, 255].\n\n    Examples:\n        &gt;&gt;&gt; Convert.alpha_ass_to_dec(\"&amp;HFF&amp;\")\n        255\n    \"\"\"\n    match = re.fullmatch(r\"&amp;H([0-9A-F]{2})&amp;\", alpha_ass)\n    if match is None:\n        raise ValueError(\n            f\"Provided ASS alpha string '{alpha_ass}' is not in the expected format '&amp;HXX&amp;'.\"\n        )\n    return int(match.group(1), 16)\n</code></pre>"},{"location":"reference/convert/#pyonfx.convert.Convert.alpha_dec_to_ass","title":"<code>alpha_dec_to_ass(alpha_dec)</code>  <code>staticmethod</code>","text":"<p>Convert a decimal alpha value to an ASS alpha string.</p> <p>Parameters:</p> Name Type Description Default <code>alpha_dec</code> <code>int | float</code> <p>An integer or float in the range [0, 255] representing an alpha value.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The corresponding ASS alpha string in the format '&amp;HXX&amp;'.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; Convert.alpha_dec_to_ass(255)\n'&amp;HFF&amp;'\n</code></pre> Source code in <code>pyonfx/convert.py</code> <pre><code>@staticmethod\ndef alpha_dec_to_ass(alpha_dec: int | float) -&gt; str:\n    \"\"\"Convert a decimal alpha value to an ASS alpha string.\n\n    Args:\n        alpha_dec: An integer or float in the range [0, 255] representing an alpha value.\n\n    Returns:\n        str: The corresponding ASS alpha string in the format '&amp;HXX&amp;'.\n\n    Examples:\n        &gt;&gt;&gt; Convert.alpha_dec_to_ass(255)\n        '&amp;HFF&amp;'\n    \"\"\"\n    try:\n        if not 0 &lt;= alpha_dec &lt;= 255:\n            raise ValueError(\n                f\"Provided alpha decimal '{alpha_dec}' is out of the range [0, 255].\"\n            )\n    except TypeError as e:\n        raise TypeError(\n            f\"Provided alpha decimal was expected of type 'int' or 'float', but you provided a '{type(alpha_dec)}'.\"\n        ) from e\n    return f\"&amp;H{round(alpha_dec):02X}&amp;\"\n</code></pre>"},{"location":"reference/convert/#pyonfx.convert.Convert.color","title":"<code>color(c, input_format, output_format, round_output=True)</code>  <code>staticmethod</code>","text":"<p>Convert a color value between different color models.</p> <p>It supports various formats such as ASS, RGB, RGBA, HSV, and OKLAB.</p> <p>Parameters:</p> Name Type Description Default <code>c</code> <code>str | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]</code> <p>A color value in the input format. This can be a string or a tuple of numbers.</p> required <code>input_format</code> <code>ColorModel</code> <p>A ColorModel enum indicating the format of the input color.</p> required <code>output_format</code> <code>ColorModel</code> <p>A ColorModel enum indicating the desired format of the output color.</p> required <code>round_output</code> <code>bool</code> <p>A boolean that determines if numerical results should be rounded.</p> <code>True</code> <p>Returns:</p> Type Description <code>str | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float]</code> <p>The color converted to the specified output format, either as a string or as a tuple.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; Convert.color(\"&amp;H0000FF&amp;\", ColorModel.ASS, ColorModel.RGB)\n(255, 0, 0)\n</code></pre> See Also <p><code>Convert.color_ass_to_rgb</code>, <code>Convert.color_rgb_to_ass</code></p> Source code in <code>pyonfx/convert.py</code> <pre><code>@staticmethod\ndef color(\n    c: (\n        str\n        | tuple[int, int, int]\n        | tuple[int, int, int, int]\n        | tuple[float, float, float]\n        | tuple[float, float, float, float]\n    ),\n    input_format: ColorModel,\n    output_format: ColorModel,\n    round_output: bool = True,\n) -&gt; (\n    str\n    | tuple[int, int, int]\n    | tuple[int, int, int, int]\n    | tuple[float, float, float]\n):\n    \"\"\"Convert a color value between different color models.\n\n    It supports various formats such as ASS, RGB, RGBA, HSV, and OKLAB.\n\n    Args:\n        c: A color value in the input format. This can be a string or a tuple of numbers.\n        input_format: A ColorModel enum indicating the format of the input color.\n        output_format: A ColorModel enum indicating the desired format of the output color.\n        round_output: A boolean that determines if numerical results should be rounded.\n\n    Returns:\n        The color converted to the specified output format, either as a string or as a tuple.\n\n    Examples:\n        &gt;&gt;&gt; Convert.color(\"&amp;H0000FF&amp;\", ColorModel.ASS, ColorModel.RGB)\n        (255, 0, 0)\n\n    See Also:\n        [`Convert.color_ass_to_rgb`][pyonfx.convert.Convert.color_ass_to_rgb], [`Convert.color_rgb_to_ass`][pyonfx.convert.Convert.color_rgb_to_ass]\n    \"\"\"\n    try:\n        # Text for exception if input is out of ranges\n        input_range_e = f\"Provided input '{c}' has value(s) out of the range \"\n\n        # Parse input, obtaining its corresponding (r,g,b,a) values\n        if input_format == ColorModel.ASS:\n            if not isinstance(c, str):\n                raise TypeError(\"ASS color format requires string input\")\n            match = re.fullmatch(r\"&amp;H([0-9A-F]{2})([0-9A-F]{2})([0-9A-F]{2})&amp;\", c)\n            if match is None:\n                raise ValueError(f\"Invalid ASS color format: {c}\")\n            (b, g, r), a = map(lambda x: int(x, 16), match.groups()), 255\n        elif input_format == ColorModel.ASS_STYLE:\n            if not isinstance(c, str):\n                raise TypeError(\"ASS_STYLE color format requires string input\")\n            match = re.fullmatch(\"&amp;H\" + r\"([0-9A-F]{2})\" * 4, c)\n            if match is None:\n                raise ValueError(f\"Invalid ASS_STYLE color format: {c}\")\n            a, b, g, r = map(lambda x: int(x, 16), match.groups())\n        elif input_format == ColorModel.RGB:\n            if not isinstance(c, tuple) or len(c) != 3:\n                raise TypeError(\"RGB color format requires tuple of 3 values\")\n            if not all(0 &lt;= n &lt;= 255 for n in c):\n                raise ValueError(input_range_e + \"[0, 255].\")\n            (r, g, b), a = map(int, c), 255\n        elif input_format == ColorModel.RGB_STR:\n            if not isinstance(c, str):\n                raise TypeError(\"RGB_STR color format requires string input\")\n            match = re.fullmatch(r\"#?([0-9A-Fa-f]{2})\" * 3, c)\n            if match is None:\n                raise ValueError(f\"Invalid RGB_STR color format: {c}\")\n            (r, g, b), a = map(lambda x: int(x, 16), match.groups()), 255\n        elif input_format == ColorModel.RGBA:\n            if not isinstance(c, tuple) or len(c) != 4:\n                raise TypeError(\"RGBA color format requires tuple of 4 values\")\n            if not all(0 &lt;= n &lt;= 255 for n in c):\n                raise ValueError(input_range_e + \"[0, 255].\")\n            r, g, b, a = map(int, c)\n        elif input_format == ColorModel.RGBA_STR:\n            if not isinstance(c, str):\n                raise TypeError(\"RGBA_STR color format requires string input\")\n            match = re.fullmatch(r\"#?([0-9A-Fa-f]{2})\" * 4, c)\n            if match is None:\n                raise ValueError(f\"Invalid RGBA_STR color format: {c}\")\n            r, g, b, a = map(lambda x: int(x, 16), match.groups())\n        elif input_format == ColorModel.HSV:\n            if not isinstance(c, tuple) or len(c) != 3:\n                raise TypeError(\"HSV color format requires tuple of 3 values\")\n            h, s, v = c\n            if not (0 &lt;= h &lt; 360 and 0 &lt;= s &lt;= 100 and 0 &lt;= v &lt;= 100):\n                raise ValueError(\n                    input_range_e + \"( [0, 360), [0, 100], [0, 100] ).\"\n                )\n            h, s, v = h / 360, s / 100, v / 100\n            (r, g, b), a = (\n                map(lambda x: int(255 * x), colorsys.hsv_to_rgb(h, s, v)),\n                255,\n            )\n        elif input_format == ColorModel.OKLAB:\n            if not (isinstance(c, tuple) and len(c) == 3):\n                raise TypeError(\"OKLAB color format requires tuple of 3 values\")\n            r, g, b = Convert.color_oklab_to_rgb(c)\n            a = 255\n    except (AttributeError, ValueError, TypeError) as e:\n        # AttributeError -&gt; re.fullmatch failed\n        # ValueError     -&gt; too many values to unpack\n        # TypeError      -&gt; in case the provided tuple is not a list of numbers\n        raise ValueError(\n            f\"Provided input '{c}' is not in the format '{input_format}'.\"\n        ) from e\n\n    # Convert (r,g,b,a) to the desired output_format\n    try:\n        if output_format == ColorModel.ASS:\n            return f\"&amp;H{round(b):02X}{round(g):02X}{round(r):02X}&amp;\"\n        elif output_format == ColorModel.ASS_STYLE:\n            return f\"&amp;H{round(a):02X}{round(b):02X}{round(g):02X}{round(r):02X}\"\n        elif output_format == ColorModel.RGB:\n            return (r, g, b)\n        elif output_format == ColorModel.RGB_STR:\n            return f\"#{round(r):02X}{round(g):02X}{round(b):02X}\"\n        elif output_format == ColorModel.RGBA:\n            return (r, g, b, a)\n        elif output_format == ColorModel.RGBA_STR:\n            return f\"#{round(r):02X}{round(g):02X}{round(b):02X}{round(a):02X}\"\n        elif output_format == ColorModel.HSV:\n            method = round if round_output else float\n            h, s, v = colorsys.rgb_to_hsv(r / 255, g / 255, b / 255)\n            return cast(\n                tuple[float, float, float],\n                (method(h * 360) % 360, method(s * 100), method(v * 100)),\n            )\n        elif output_format == ColorModel.OKLAB:\n            method = round if round_output else float\n            L, a, b = Convert.color_rgb_to_oklab((r, g, b))\n            return cast(\n                tuple[float, float, float],\n                (method(L), method(a), method(b)),\n            )\n        else:\n            raise ValueError(f\"Unsupported output_format: {output_format}\")\n    except NameError as e:\n        raise ValueError(f\"Unsupported input_format ('{input_format}').\") from e\n</code></pre>"},{"location":"reference/convert/#pyonfx.convert.Convert.color_ass_to_rgb","title":"<code>color_ass_to_rgb(color_ass, as_str=False)</code>  <code>staticmethod</code>","text":"<p>Convert an ASS color string to its RGB representation.</p> <p>Parameters:</p> Name Type Description Default <code>color_ass</code> <code>str</code> <p>A string in the ASS color format \"&amp;HBBGGRR&amp;\".</p> required <code>as_str</code> <code>bool</code> <p>A boolean flag that, if True, returns the color as a hexadecimal string in the format \"#RRGGBB\"; otherwise returns a tuple (R, G, B).</p> <code>False</code> <p>Returns:</p> Type Description <code>str | tuple[int, int, int]</code> <p>The RGB representation of the color either as a tuple of integers or as a hexadecimal string.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; Convert.color_ass_to_rgb(\"&amp;HABCDEF&amp;\")\n(239, 205, 171)\n&gt;&gt;&gt; Convert.color_ass_to_rgb(\"&amp;HABCDEF&amp;\", as_str=True)\n\"#EFCDAB\"\n</code></pre> See Also <p><code>Convert.color_rgb_to_ass</code></p> Source code in <code>pyonfx/convert.py</code> <pre><code>@staticmethod\ndef color_ass_to_rgb(\n    color_ass: str, as_str: bool = False\n) -&gt; str | tuple[int, int, int]:\n    \"\"\"Convert an ASS color string to its RGB representation.\n\n    Args:\n        color_ass: A string in the ASS color format \"&amp;HBBGGRR&amp;\".\n        as_str: A boolean flag that, if True, returns the color as a hexadecimal string in the format \"#RRGGBB\"; otherwise returns a tuple (R, G, B).\n\n    Returns:\n        The RGB representation of the color either as a tuple of integers or as a hexadecimal string.\n\n    Examples:\n        &gt;&gt;&gt; Convert.color_ass_to_rgb(\"&amp;HABCDEF&amp;\")\n        (239, 205, 171)\n        &gt;&gt;&gt; Convert.color_ass_to_rgb(\"&amp;HABCDEF&amp;\", as_str=True)\n        \"#EFCDAB\"\n\n    See Also:\n        [`Convert.color_rgb_to_ass`][pyonfx.convert.Convert.color_rgb_to_ass]\n    \"\"\"\n    result = Convert.color(\n        color_ass, ColorModel.ASS, ColorModel.RGB_STR if as_str else ColorModel.RGB\n    )\n    if as_str:\n        return cast(str, result)\n    return cast(tuple[int, int, int], result)\n</code></pre>"},{"location":"reference/convert/#pyonfx.convert.Convert.color_ass_to_hsv","title":"<code>color_ass_to_hsv(color_ass, round_output=True)</code>  <code>staticmethod</code>","text":"<p>Convert an ASS color string to its HSV representation.</p> <p>Parameters:</p> Name Type Description Default <code>color_ass</code> <code>str</code> <p>A string representing the ASS color (format \"&amp;HBBGGRR&amp;\").</p> required <code>round_output</code> <code>bool</code> <p>A boolean that determines if numerical results should be rounded.</p> <code>True</code> <p>Returns:</p> Type Description <code>tuple[int, int, int] | tuple[float, float, float]</code> <p>A tuple representing the HSV values. The values are integers if round_output is True, or floats otherwise.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; Convert.color_ass_to_hsv(\"&amp;HABCDEF&amp;\")\n(30, 28, 94)\n&gt;&gt;&gt; Convert.color_ass_to_hsv(\"&amp;HABCDEF&amp;\", round_output=False)\n(30.000000000000014, 28.451882845188294, 93.72549019607843)\n</code></pre> <pre><code>print(Convert.color_ass_to_hsv(\"&amp;HABCDEF&amp;\"))\nprint(Convert.color_ass_to_hsv(\"&amp;HABCDEF&amp;\", round_output=False))\n</code></pre> See Also <p><code>Convert.color_rgb_to_hsv</code></p> Source code in <code>pyonfx/convert.py</code> <pre><code>@staticmethod\ndef color_ass_to_hsv(\n    color_ass: str, round_output: bool = True\n) -&gt; tuple[int, int, int] | tuple[float, float, float]:\n    \"\"\"Convert an ASS color string to its HSV representation.\n\n    Args:\n        color_ass: A string representing the ASS color (format \"&amp;HBBGGRR&amp;\").\n        round_output: A boolean that determines if numerical results should be rounded.\n\n    Returns:\n        A tuple representing the HSV values. The values are integers if round_output is True, or floats otherwise.\n\n    Examples:\n        &gt;&gt;&gt; Convert.color_ass_to_hsv(\"&amp;HABCDEF&amp;\")\n        (30, 28, 94)\n        &gt;&gt;&gt; Convert.color_ass_to_hsv(\"&amp;HABCDEF&amp;\", round_output=False)\n        (30.000000000000014, 28.451882845188294, 93.72549019607843)\n\n            print(Convert.color_ass_to_hsv(\"&amp;HABCDEF&amp;\"))\n            print(Convert.color_ass_to_hsv(\"&amp;HABCDEF&amp;\", round_output=False))\n\n    See Also:\n        [`Convert.color_rgb_to_hsv`][pyonfx.convert.Convert.color_rgb_to_hsv]\n    \"\"\"\n    result = Convert.color(color_ass, ColorModel.ASS, ColorModel.HSV, round_output)\n    return cast(tuple[int, int, int] | tuple[float, float, float], result)\n</code></pre>"},{"location":"reference/convert/#pyonfx.convert.Convert.color_ass_to_oklab","title":"<code>color_ass_to_oklab(color_ass)</code>  <code>staticmethod</code>","text":"<p>Convert an ASS color string to its OKLab representation.</p> <p>Parameters:</p> Name Type Description Default <code>color_ass</code> <code>str</code> <p>A string containing the ASS color in the format \"&amp;HBBGGRR&amp;\".</p> required <p>Returns:</p> Type Description <code>tuple[float, float, float]</code> <p>A tuple of three floats corresponding to the OKLab color values.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; Convert.color_ass_to_oklab(\"&amp;HABCDEF&amp;\")\n(0.8686973182678561, 0.023239204013187575, 0.054516093943155375)\n</code></pre> See Also <p><code>Convert.color_oklab_to_rgb</code></p> Source code in <code>pyonfx/convert.py</code> <pre><code>@staticmethod\ndef color_ass_to_oklab(color_ass: str) -&gt; tuple[float, float, float]:\n    \"\"\"Convert an ASS color string to its OKLab representation.\n\n    Args:\n        color_ass: A string containing the ASS color in the format \"&amp;HBBGGRR&amp;\".\n\n    Returns:\n        A tuple of three floats corresponding to the OKLab color values.\n\n    Examples:\n        &gt;&gt;&gt; Convert.color_ass_to_oklab(\"&amp;HABCDEF&amp;\")\n        (0.8686973182678561, 0.023239204013187575, 0.054516093943155375)\n\n    See Also:\n        [`Convert.color_oklab_to_rgb`][pyonfx.convert.Convert.color_oklab_to_rgb]\n    \"\"\"\n    result = Convert.color(\n        color_ass, ColorModel.ASS, ColorModel.OKLAB, round_output=False\n    )\n    return cast(tuple[float, float, float], result)\n</code></pre>"},{"location":"reference/convert/#pyonfx.convert.Convert.color_rgb_to_ass","title":"<code>color_rgb_to_ass(color_rgb)</code>  <code>staticmethod</code>","text":"<p>Convert an RGB color value to its ASS representation.</p> <p>Parameters:</p> Name Type Description Default <code>color_rgb</code> <code>str | tuple[int, int, int]</code> <p>An RGB color value as a hexadecimal string or a tuple of three integers.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The ASS color string in the format \"&amp;HBBGGRR&amp;\".</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; Convert.color_rgb_to_ass(\"#ABCDEF\")\n\"&amp;HEFCDAB&amp;\"\n</code></pre> See Also <p><code>Convert.color_ass_to_rgb</code></p> Source code in <code>pyonfx/convert.py</code> <pre><code>@staticmethod\ndef color_rgb_to_ass(\n    color_rgb: str | tuple[int, int, int],\n) -&gt; str:\n    \"\"\"Convert an RGB color value to its ASS representation.\n\n    Args:\n        color_rgb: An RGB color value as a hexadecimal string or a tuple of three integers.\n\n    Returns:\n        str: The ASS color string in the format \"&amp;HBBGGRR&amp;\".\n\n    Examples:\n        &gt;&gt;&gt; Convert.color_rgb_to_ass(\"#ABCDEF\")\n        \"&amp;HEFCDAB&amp;\"\n\n    See Also:\n        [`Convert.color_ass_to_rgb`][pyonfx.convert.Convert.color_ass_to_rgb]\n    \"\"\"\n    result = Convert.color(\n        color_rgb,\n        ColorModel.RGB_STR if isinstance(color_rgb, str) else ColorModel.RGB,\n        ColorModel.ASS,\n    )\n    return cast(str, result)\n</code></pre>"},{"location":"reference/convert/#pyonfx.convert.Convert.color_rgb_to_hsv","title":"<code>color_rgb_to_hsv(color_rgb, round_output=True)</code>  <code>staticmethod</code>","text":"<p>Convert an RGB color value to its HSV representation.</p> <p>Parameters:</p> Name Type Description Default <code>color_rgb</code> <code>str | tuple[int | float, int | float, int | float]</code> <p>An RGB color value as a hexadecimal string or a tuple of three numbers.</p> required <code>round_output</code> <code>bool</code> <p>A boolean that determines if numerical results should be rounded.</p> <code>True</code> <p>Returns:</p> Type Description <code>tuple[int, int, int] | tuple[float, float, float]</code> <p>A tuple representing the HSV values. If round_output is True, the components are integers; otherwise, they are floats.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; Convert.color_rgb_to_hsv(\"#ABCDEF\")\n(210, 28, 94)\n&gt;&gt;&gt; Convert.color_rgb_to_hsv(\"#ABCDEF\", round_output=False)\n(210.0, 28.45, 93.73)\n</code></pre> See Also <p><code>Convert.color_hsv_to_rgb</code></p> Source code in <code>pyonfx/convert.py</code> <pre><code>@staticmethod\ndef color_rgb_to_hsv(\n    color_rgb: str | tuple[int | float, int | float, int | float],\n    round_output: bool = True,\n) -&gt; tuple[int, int, int] | tuple[float, float, float]:\n    \"\"\"Convert an RGB color value to its HSV representation.\n\n    Args:\n        color_rgb: An RGB color value as a hexadecimal string or a tuple of three numbers.\n        round_output: A boolean that determines if numerical results should be rounded.\n\n    Returns:\n        A tuple representing the HSV values. If round_output is True, the components are integers; otherwise, they are floats.\n\n    Examples:\n        &gt;&gt;&gt; Convert.color_rgb_to_hsv(\"#ABCDEF\")\n        (210, 28, 94)\n        &gt;&gt;&gt; Convert.color_rgb_to_hsv(\"#ABCDEF\", round_output=False)\n        (210.0, 28.45, 93.73)\n\n    See Also:\n        [`Convert.color_hsv_to_rgb`][pyonfx.convert.Convert.color_hsv_to_rgb]\n    \"\"\"\n    result = Convert.color(\n        color_rgb,\n        ColorModel.RGB_STR if isinstance(color_rgb, str) else ColorModel.RGB,\n        ColorModel.HSV,\n        round_output,\n    )\n    return cast(tuple[int, int, int] | tuple[float, float, float], result)\n</code></pre>"},{"location":"reference/convert/#pyonfx.convert.Convert.color_rgb_to_oklab","title":"<code>color_rgb_to_oklab(color_rgb)</code>  <code>staticmethod</code>","text":"<p>Convert an sRGB color value to its OKLab representation.</p> <p>Parameters:</p> Name Type Description Default <code>color_rgb</code> <code>tuple[int, int, int]</code> <p>A tuple (R, G, B) with each value in the range [0, 255].</p> required <p>Returns:</p> Type Description <code>tuple[float, float, float]</code> <p>A tuple of three floats corresponding to the OKLab values (L, a, b) in the range [0, 1].</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; Convert.color_rgb_to_oklab((255, 0, 0))\n(0.6279553606145516, 0.22486306106597398, 0.1258462985307351)\n</code></pre> See Also <p><code>Convert.color_oklab_to_rgb</code></p> Source code in <code>pyonfx/convert.py</code> <pre><code>@staticmethod\ndef color_rgb_to_oklab(\n    color_rgb: tuple[int, int, int],\n) -&gt; tuple[float, float, float]:\n    \"\"\"Convert an sRGB color value to its OKLab representation.\n\n    Args:\n        color_rgb: A tuple (R, G, B) with each value in the range [0, 255].\n\n    Returns:\n        A tuple of three floats corresponding to the OKLab values (L, a, b) in the range [0, 1].\n\n    Examples:\n        &gt;&gt;&gt; Convert.color_rgb_to_oklab((255, 0, 0))\n        (0.6279553606145516, 0.22486306106597398, 0.1258462985307351)\n\n    See Also:\n        [`Convert.color_oklab_to_rgb`][pyonfx.convert.Convert.color_oklab_to_rgb]\n    \"\"\"\n    r, g, b = [x / 255 for x in color_rgb]\n\n    def srgb_to_linear(u: float) -&gt; float:\n        if u &lt;= 0.04045:\n            return u / 12.92\n        else:\n            return ((u + 0.055) / 1.055) ** 2.4\n\n    r_lin = srgb_to_linear(r)\n    g_lin = srgb_to_linear(g)\n    b_lin = srgb_to_linear(b)\n\n    # Linear sRGB to LMS\n    L_val = 0.4122214708 * r_lin + 0.5363325363 * g_lin + 0.0514459929 * b_lin\n    M_val = 0.2119034982 * r_lin + 0.6806995451 * g_lin + 0.1073969566 * b_lin\n    S_val = 0.0883024619 * r_lin + 0.2817188376 * g_lin + 0.6299787005 * b_lin\n\n    # Non-linear adaptation (cube root)\n    L_cbrt = L_val ** (1 / 3)\n    M_cbrt = M_val ** (1 / 3)\n    S_cbrt = S_val ** (1 / 3)\n\n    # LMS to OKLab\n    L_ok = 0.2104542553 * L_cbrt + 0.7936177850 * M_cbrt - 0.0040720468 * S_cbrt\n    a_ok = 1.9779984951 * L_cbrt - 2.4285922050 * M_cbrt + 0.4505937099 * S_cbrt\n    b_ok = 0.0259040371 * L_cbrt + 0.7827717662 * M_cbrt - 0.8086757660 * S_cbrt\n\n    return (L_ok, a_ok, b_ok)\n</code></pre>"},{"location":"reference/convert/#pyonfx.convert.Convert.color_hsv_to_ass","title":"<code>color_hsv_to_ass(color_hsv)</code>  <code>staticmethod</code>","text":"<p>Convert an HSV color value to its ASS representation.</p> <p>Parameters:</p> Name Type Description Default <code>color_hsv</code> <code>tuple[int | float, int | float, int | float]</code> <p>A tuple (H, S, V) representing the HSV color.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The ASS color string corresponding to the given HSV value.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; Convert.color_hsv_to_ass((100, 100, 100))\n\"&amp;H00FF55&amp;\"\n</code></pre> See Also <p><code>Convert.color_ass_to_hsv</code></p> Source code in <code>pyonfx/convert.py</code> <pre><code>@staticmethod\ndef color_hsv_to_ass(\n    color_hsv: tuple[int | float, int | float, int | float],\n) -&gt; str:\n    \"\"\"Convert an HSV color value to its ASS representation.\n\n    Args:\n        color_hsv: A tuple (H, S, V) representing the HSV color.\n\n    Returns:\n        str: The ASS color string corresponding to the given HSV value.\n\n    Examples:\n        &gt;&gt;&gt; Convert.color_hsv_to_ass((100, 100, 100))\n        \"&amp;H00FF55&amp;\"\n\n    See Also:\n        [`Convert.color_ass_to_hsv`][pyonfx.convert.Convert.color_ass_to_hsv]\n    \"\"\"\n    result = Convert.color(color_hsv, ColorModel.HSV, ColorModel.ASS)\n    return cast(str, result)\n</code></pre>"},{"location":"reference/convert/#pyonfx.convert.Convert.color_hsv_to_rgb","title":"<code>color_hsv_to_rgb(color_hsv, as_str=False, round_output=True)</code>  <code>staticmethod</code>","text":"<p>Convert an HSV color value to its RGB representation.</p> <p>Parameters:</p> Name Type Description Default <code>color_hsv</code> <code>tuple[int | float, int | float, int | float]</code> <p>A tuple representing the HSV color with H in [0, 360), S and V in [0, 100].</p> required <code>as_str</code> <code>bool</code> <p>A boolean flag that, if True, returns the RGB value as a hexadecimal string \"#RRGGBB\"; otherwise as a tuple (R, G, B).</p> <code>False</code> <code>round_output</code> <code>bool</code> <p>A boolean that determines if numerical results should be rounded.</p> <code>True</code> <p>Returns:</p> Type Description <code>str | tuple[int, int, int] | tuple[float, float, float]</code> <p>Either a tuple (R, G, B) or a string \"#RRGGBB\" representing the RGB color.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; Convert.color_hsv_to_rgb((100, 100, 100))\n(85, 255, 0)\n&gt;&gt;&gt; Convert.color_hsv_to_rgb((100, 100, 100), as_str=True)\n\"#55FF00\"\n&gt;&gt;&gt; Convert.color_hsv_to_rgb((100, 100, 100), round_output=False)\n(84.99999999999999, 255.0, 0.0)\n</code></pre> See Also <p><code>Convert.color_rgb_to_hsv</code></p> Source code in <code>pyonfx/convert.py</code> <pre><code>@staticmethod\ndef color_hsv_to_rgb(\n    color_hsv: tuple[int | float, int | float, int | float],\n    as_str: bool = False,\n    round_output: bool = True,\n) -&gt; str | tuple[int, int, int] | tuple[float, float, float]:\n    \"\"\"Convert an HSV color value to its RGB representation.\n\n    Args:\n        color_hsv: A tuple representing the HSV color with H in [0, 360), S and V in [0, 100].\n        as_str: A boolean flag that, if True, returns the RGB value as a hexadecimal string \"#RRGGBB\"; otherwise as a tuple (R, G, B).\n        round_output: A boolean that determines if numerical results should be rounded.\n\n    Returns:\n        Either a tuple (R, G, B) or a string \"#RRGGBB\" representing the RGB color.\n\n    Examples:\n        &gt;&gt;&gt; Convert.color_hsv_to_rgb((100, 100, 100))\n        (85, 255, 0)\n        &gt;&gt;&gt; Convert.color_hsv_to_rgb((100, 100, 100), as_str=True)\n        \"#55FF00\"\n        &gt;&gt;&gt; Convert.color_hsv_to_rgb((100, 100, 100), round_output=False)\n        (84.99999999999999, 255.0, 0.0)\n\n    See Also:\n        [`Convert.color_rgb_to_hsv`][pyonfx.convert.Convert.color_rgb_to_hsv]\n    \"\"\"\n    result = Convert.color(\n        color_hsv,\n        ColorModel.HSV,\n        ColorModel.RGB_STR if as_str else ColorModel.RGB,\n        round_output,\n    )\n    if as_str:\n        return cast(str, result)\n    return cast(tuple[int, int, int] | tuple[float, float, float], result)\n</code></pre>"},{"location":"reference/convert/#pyonfx.convert.Convert.color_oklab_to_rgb","title":"<code>color_oklab_to_rgb(color_oklab)</code>  <code>staticmethod</code>","text":"<p>Convert an OKLab color value to its sRGB representation.</p> <p>Parameters:</p> Name Type Description Default <code>color_oklab</code> <code>tuple[float, float, float]</code> <p>A tuple (L, a, b) representing the OKLab color, with values typically in the range [0, 1].</p> required <p>Returns:</p> Type Description <code>tuple[int, int, int]</code> <p>A tuple of three integers (R, G, B) in the range [0, 255] representing the sRGB color.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; Convert.color_oklab_to_rgb((0.627, 0.224, 0.125))\n(255, 0, 0)  # example output\n</code></pre> See Also <p><code>Convert.color_rgb_to_oklab</code></p> Source code in <code>pyonfx/convert.py</code> <pre><code>@staticmethod\ndef color_oklab_to_rgb(\n    color_oklab: tuple[float, float, float],\n) -&gt; tuple[int, int, int]:\n    \"\"\"Convert an OKLab color value to its sRGB representation.\n\n    Args:\n        color_oklab: A tuple (L, a, b) representing the OKLab color, with values typically in the range [0, 1].\n\n    Returns:\n        A tuple of three integers (R, G, B) in the range [0, 255] representing the sRGB color.\n\n    Examples:\n        &gt;&gt;&gt; Convert.color_oklab_to_rgb((0.627, 0.224, 0.125))\n        (255, 0, 0)  # example output\n\n    See Also:\n        [`Convert.color_rgb_to_oklab`][pyonfx.convert.Convert.color_rgb_to_oklab]\n    \"\"\"\n    L, a_val, b_val = color_oklab\n\n    # OKLab to LMS\n    l_ = L + 0.3963377774 * a_val + 0.2158037573 * b_val\n    m_ = L - 0.1055613458 * a_val - 0.0638541728 * b_val\n    s_ = L - 0.0894841775 * a_val - 1.2914855480 * b_val\n\n    # LMS to linear RGB\n    L_lin = l_**3\n    M_lin = m_**3\n    S_lin = s_**3\n\n    def linear_to_srgb(u: float) -&gt; float:\n        if u &lt;= 0.0031308:\n            return 12.92 * u\n        else:\n            return 1.055 * (u ** (1 / 2.4)) - 0.055\n\n    # Linear RGB to sRGB\n    r = linear_to_srgb(\n        4.0767416621 * L_lin - 3.3077115913 * M_lin + 0.2309699292 * S_lin\n    )\n    g = linear_to_srgb(\n        -1.2684380046 * L_lin + 2.6097574011 * M_lin - 0.3413193965 * S_lin\n    )\n    b = linear_to_srgb(\n        -0.0041960863 * L_lin - 0.7034186147 * M_lin + 1.7076147010 * S_lin\n    )\n\n    # Clamp and convert to 8-bit\n    r = max(0.0, min(1.0, r))\n    g = max(0.0, min(1.0, g))\n    b = max(0.0, min(1.0, b))\n\n    return (round(r * 255), round(g * 255), round(b * 255))\n</code></pre>"},{"location":"reference/convert/#pyonfx.convert.Convert.color_oklab_to_ass","title":"<code>color_oklab_to_ass(color_oklab)</code>  <code>staticmethod</code>","text":"<p>Convert an OKLab color value to its ASS representation.</p> <p>Parameters:</p> Name Type Description Default <code>color_oklab</code> <code>tuple[float, float, float]</code> <p>A tuple of three floats representing the OKLab color.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The ASS color string in the format \"&amp;HBBGGRR&amp;\" corresponding to the provided OKLab color.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; Convert.color_oklab_to_ass((0.627, 0.224, 0.125))\n\"&amp;H00FF55&amp;\"  # example output\n</code></pre> See Also <p><code>Convert.color_ass_to_oklab</code></p> Source code in <code>pyonfx/convert.py</code> <pre><code>@staticmethod\ndef color_oklab_to_ass(color_oklab: tuple[float, float, float]) -&gt; str:\n    \"\"\"Convert an OKLab color value to its ASS representation.\n\n    Args:\n        color_oklab: A tuple of three floats representing the OKLab color.\n\n    Returns:\n        str: The ASS color string in the format \"&amp;HBBGGRR&amp;\" corresponding to the provided OKLab color.\n\n    Examples:\n        &gt;&gt;&gt; Convert.color_oklab_to_ass((0.627, 0.224, 0.125))\n        \"&amp;H00FF55&amp;\"  # example output\n\n    See Also:\n        [`Convert.color_ass_to_oklab`][pyonfx.convert.Convert.color_ass_to_oklab]\n    \"\"\"\n    result = Convert.color(color_oklab, ColorModel.OKLAB, ColorModel.ASS)\n    return cast(str, result)\n</code></pre>"},{"location":"reference/convert/#pyonfx.convert.Convert.text_to_shape","title":"<code>text_to_shape(obj, fscx=None, fscy=None)</code>  <code>staticmethod</code>","text":"<p>Convert text with style information to an ASS shape.</p> <p>Converting text to a shape converts the text into a detailed geometry representation, exposing individual control points that can be manipulated for precise deformations.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>Line | Word | Syllable | Char</code> <p>An instance of a Line, Word, Syllable, or Char that contains both text content and style information.</p> required <code>fscx</code> <code>float | None</code> <p>Optional; a float representing an override for the style's horizontal scale (scale_x) during conversion.</p> <code>None</code> <code>fscy</code> <code>float | None</code> <p>Optional; a float representing an override for the style's vertical scale (scale_y) during conversion.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Shape</code> <code>Shape</code> <p>An ASS shape object corresponding to the rendered text with applied style attributes.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; l.text = \"{\\an7\\pos(%.3f,%.3f)\\p1}%s\" % (line.left, line.top, Convert.text_to_shape(line))\n&gt;&gt;&gt; io.write_line(l)\n</code></pre> Notes <p>A known limitation is that the output line must use '\\an7' and '\\pos(.left, .top)' for accurate displacement.</p> See Also <p><code>Convert.text_to_clip</code></p> Source code in <code>pyonfx/convert.py</code> <pre><code>@staticmethod\ndef text_to_shape(\n    obj: \"Line | Word | Syllable | Char\",\n    fscx: float | None = None,\n    fscy: float | None = None,\n) -&gt; \"Shape\":\n    \"\"\"Convert text with style information to an ASS shape.\n\n    Converting text to a shape converts the text into a detailed geometry representation,\n    exposing individual control points that can be manipulated for precise deformations.\n\n    Args:\n        obj: An instance of a Line, Word, Syllable, or Char that contains both text content and style information.\n        fscx: Optional; a float representing an override for the style's horizontal scale (scale_x) during conversion.\n        fscy: Optional; a float representing an override for the style's vertical scale (scale_y) during conversion.\n\n    Returns:\n        Shape: An ASS shape object corresponding to the rendered text with applied style attributes.\n\n    Examples:\n        &gt;&gt;&gt; l.text = \"{\\\\an7\\\\pos(%.3f,%.3f)\\\\p1}%s\" % (line.left, line.top, Convert.text_to_shape(line))\n        &gt;&gt;&gt; io.write_line(l)\n\n    Notes:\n        A known limitation is that the output line must use '\\\\an7' and '\\\\pos(.left, .top)' for accurate displacement.\n\n    See Also:\n        [`Convert.text_to_clip`][pyonfx.convert.Convert.text_to_clip]\n    \"\"\"\n    if obj.styleref is None:\n        raise ValueError(\"Object must have a style reference and text content\")\n\n    # Obtaining information and editing values of style if requested\n    original_scale_x = obj.styleref.scale_x\n    original_scale_y = obj.styleref.scale_y\n\n    # Editing temporary the style to properly get the shape\n    if fscx is not None:\n        obj.styleref.scale_x = fscx\n    if fscy is not None:\n        obj.styleref.scale_y = fscy\n\n    # Obtaining font information from style and obtaining shape\n    font = Font(obj.styleref)\n    shape = font.text_to_shape(obj.text)\n    # Clearing resources to not let overflow errors take over\n    del font\n\n    # Restoring values of style and returning the shape converted\n    if fscx is not None:\n        obj.styleref.scale_x = original_scale_x\n    if fscy is not None:\n        obj.styleref.scale_y = original_scale_y\n    return shape\n</code></pre>"},{"location":"reference/convert/#pyonfx.convert.Convert.text_to_clip","title":"<code>text_to_clip(obj, an=5, fscx=None, fscy=None)</code>  <code>staticmethod</code>","text":"<p>Convert text with style information to an ASS shape for clipping.</p> <p>Because a shape used in a clip cannot be directly positioned using the \\pos() command, the function applies additional translation and scaling to ensure proper alignment.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>Line | Word | Syllable | Char</code> <p>An instance of Line, Word, Syllable, or Char that carries text content and associated style information.</p> required <code>an</code> <code>int</code> <p>An integer specifying the desired alignment for the shape. Must be between 1 and 9.</p> <code>5</code> <code>fscx</code> <code>float | None</code> <p>Optional; a float overriding the style's horizontal scale (scale_x) during conversion.</p> <code>None</code> <code>fscy</code> <code>float | None</code> <p>Optional; a float overriding the style's vertical scale (scale_y) during conversion.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Shape</code> <code>Shape</code> <p>An ASS shape object generated from the text, adjusted for clipping use.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; l.text = \"{\\an5\\pos(%.3f,%.3f)\\clip(%s)}%s\" % (line.center, line.middle, Convert.text_to_clip(line), Shape.circle(20).move(line.center, line.middle))\n&gt;&gt;&gt; io.write_line(l)\n</code></pre> See Also <p><code>Convert.text_to_shape</code></p> Source code in <code>pyonfx/convert.py</code> <pre><code>@staticmethod\ndef text_to_clip(\n    obj: \"Line | Word | Syllable | Char\",\n    an: int = 5,\n    fscx: float | None = None,\n    fscy: float | None = None,\n) -&gt; \"Shape\":\n    \"\"\"Convert text with style information to an ASS shape for clipping.\n\n    Because a shape used in a clip cannot be directly positioned using the \\\\pos() command,\n    the function applies additional translation and scaling to ensure proper alignment.\n\n    Args:\n        obj: An instance of Line, Word, Syllable, or Char that carries text content and associated style information.\n        an: An integer specifying the desired alignment for the shape. Must be between 1 and 9.\n        fscx: Optional; a float overriding the style's horizontal scale (scale_x) during conversion.\n        fscy: Optional; a float overriding the style's vertical scale (scale_y) during conversion.\n\n    Returns:\n        Shape: An ASS shape object generated from the text, adjusted for clipping use.\n\n    Examples:\n        &gt;&gt;&gt; l.text = \"{\\\\an5\\\\pos(%.3f,%.3f)\\\\clip(%s)}%s\" % (line.center, line.middle, Convert.text_to_clip(line), Shape.circle(20).move(line.center, line.middle))\n        &gt;&gt;&gt; io.write_line(l)\n\n    See Also:\n        [`Convert.text_to_shape`][pyonfx.convert.Convert.text_to_shape]\n    \"\"\"\n    if obj.styleref is None:\n        raise ValueError(\"Object must have a style reference\")\n\n    # Checking for errors\n    if an &lt; 1 or an &gt; 9:\n        raise ValueError(\"Alignment value must be an integer between 1 and 9\")\n\n    # Setting default values\n    if fscx is None:\n        fscx = obj.styleref.scale_x\n    if fscy is None:\n        fscy = obj.styleref.scale_y\n\n    # Obtaining text converted to shape\n    shape = Convert.text_to_shape(obj, fscx, fscy)\n\n    # Setting mult_x based on alignment\n    if an % 3 == 1:  # an=1 or an=4 or an=7\n        mult_x = 0\n    elif an % 3 == 2:  # an=2 or an=5 or an=8\n        mult_x = 1 / 2\n    else:\n        mult_x = 1\n\n    # Setting mult_y based on alignment\n    if an &lt; 4:\n        mult_y = 1\n    elif an &lt; 7:\n        mult_y = 1 / 2\n    else:\n        mult_y = 0\n\n    # Calculating offsets\n    cx = (\n        obj.left\n        - obj.width * mult_x * (fscx - obj.styleref.scale_x) / obj.styleref.scale_x\n    )\n    cy = (\n        obj.top\n        - obj.height * mult_y * (fscy - obj.styleref.scale_y) / obj.styleref.scale_y\n    )\n\n    return shape.move(cx, cy)\n</code></pre>"},{"location":"reference/convert/#pyonfx.convert.Convert.text_to_pixels","title":"<code>text_to_pixels(obj, supersampling=8, output_rgba=False)</code>  <code>staticmethod</code>","text":"<p>Convert styled text into a pixel representation.</p> <p>This conversion is useful for creating effects like decaying text or light effects.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>Line | Word | Syllable | Char</code> <p>A text object (Line, Word, Syllable, or Char) containing both content and style data.</p> required <code>supersampling</code> <code>int</code> <p>An integer supersampling factor that controls the anti-aliasing quality. Higher values yield smoother edges but require more processing time.</p> <code>8</code> <code>output_rgba</code> <code>bool</code> <p>A boolean flag indicating the format of the alpha value. If True, the alpha value for each pixel will be a numeric value between 0 and 255; otherwise, it will be returned as an ASS alpha string.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>PixelCollection</code> <code>PixelCollection</code> <p>A collection of pixels, where each pixel includes x and y coordinates and an alpha value representing transparency.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; io.add_style(\"p\", Ass.PIXEL_STYLE)\n&gt;&gt;&gt; l.style = \"p\"\n&gt;&gt;&gt; for pixel in Convert.text_to_pixels(l):\n...     x, y = l.left + pixel.x, l.top + pixel.y\n...     alpha = \"\\alpha\" + str(pixel.alpha) if str(pixel.alpha) != \"&amp;HFF&amp;\" else \"\"\n...     l.text = \"{\\p1\\pos(%d,%d)%s}%s\" % (x, y, alpha, Shape.PIXEL)\n...     io.write_line(l)\n</code></pre> Notes <p>To optimize the ASS file size, it is recommended to use a dedicated pixel style. A pre-made pixel style (<code>Ass.PIXEL_STYLE</code>) is provided in the Ass class and can be added to your ASS output using the <code>add_style</code> method.</p> See Also <p><code>Convert.shape_to_pixels</code></p> Source code in <code>pyonfx/convert.py</code> <pre><code>@staticmethod\ndef text_to_pixels(\n    obj: \"Line | Word | Syllable | Char\",\n    supersampling: int = 8,\n    output_rgba: bool = False,\n) -&gt; PixelCollection:\n    \"\"\"Convert styled text into a pixel representation.\n\n    This conversion is useful for creating effects like decaying text or light effects.\n\n    Args:\n        obj: A text object (Line, Word, Syllable, or Char) containing both content and style data.\n        supersampling: An integer supersampling factor that controls the anti-aliasing quality. Higher values yield smoother edges but require more processing time.\n        output_rgba: A boolean flag indicating the format of the alpha value. If True, the alpha value for each pixel will be a numeric value between 0 and 255; otherwise, it will be returned as an ASS alpha string.\n\n    Returns:\n        PixelCollection: A collection of pixels, where each pixel includes x and y coordinates and an alpha value representing transparency.\n\n    Examples:\n        &gt;&gt;&gt; io.add_style(\"p\", Ass.PIXEL_STYLE)\n        &gt;&gt;&gt; l.style = \"p\"\n        &gt;&gt;&gt; for pixel in Convert.text_to_pixels(l):\n        ...     x, y = l.left + pixel.x, l.top + pixel.y\n        ...     alpha = \"\\\\alpha\" + str(pixel.alpha) if str(pixel.alpha) != \"&amp;HFF&amp;\" else \"\"\n        ...     l.text = \"{\\\\p1\\\\pos(%d,%d)%s}%s\" % (x, y, alpha, Shape.PIXEL)\n        ...     io.write_line(l)\n\n    Notes:\n        To optimize the ASS file size, it is recommended to use a dedicated pixel style.\n        A pre-made pixel style ([`Ass.PIXEL_STYLE`][pyonfx.ass_core.Ass.PIXEL_STYLE]) is provided in the Ass class and can be added to your ASS output using the [`add_style`][pyonfx.ass_core.Ass.add_style] method.\n\n    See Also:\n        [`Convert.shape_to_pixels`][pyonfx.convert.Convert.shape_to_pixels]\n    \"\"\"\n    shape = Convert.text_to_shape(obj).move(obj.left % 1, obj.top % 1)\n    return Convert.shape_to_pixels(shape, supersampling, output_rgba)\n</code></pre>"},{"location":"reference/convert/#pyonfx.convert.Convert.shape_to_pixels","title":"<code>shape_to_pixels(shape, supersampling=8, output_rgba=False)</code>  <code>staticmethod</code>","text":"<p>Convert a Shape object into a pixel representation.</p> <p>This conversion is useful for creating effects like decaying shapes or light effects.</p> <p>Parameters:</p> Name Type Description Default <code>shape</code> <code>Shape</code> <p>A Shape object representing the geometric outline to be sampled.</p> required <code>supersampling</code> <code>int</code> <p>An integer (\u2265 1) that controls the anti-aliasing resolution. Higher values yield smoother results but increase processing time.</p> <code>8</code> <code>output_rgba</code> <code>bool</code> <p>A boolean flag indicating the format of the alpha value. If True, the alpha value for each pixel will be a numeric value between 0 and 255; otherwise, it will be returned as an ASS alpha string.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>PixelCollection</code> <code>PixelCollection</code> <p>A collection of Pixel objects, where each pixel includes x and y coordinates and an alpha value representing transparency.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; io.add_style(\"p\", Ass.PIXEL_STYLE)\n&gt;&gt;&gt; l.style = \"p\"\n&gt;&gt;&gt; for pixel in Convert.shape_to_pixels(Shape.polygon(4, 20)):\n...     x, y = l.left + pixel.x, l.top + pixel.y\n...     alpha = \"\\alpha\" + str(pixel.alpha) if str(pixel.alpha) != \"&amp;HFF&amp;\" else \"\"\n...     l.text = \"{\\p1\\pos(%d,%d)%s}%s\" % (x, y, alpha, Shape.PIXEL)\n...     io.write_line(l)\n</code></pre> Notes <p>To optimize the ASS file size, it is recommended to use a dedicated pixel style. A pre-made pixel style (<code>Ass.PIXEL_STYLE</code>) is provided in the Ass class and can be added to your ASS output using the <code>add_style</code> method.</p> See Also <p><code>Convert.text_to_pixels</code></p> Source code in <code>pyonfx/convert.py</code> <pre><code>@staticmethod\ndef shape_to_pixels(\n    shape: \"Shape\", supersampling: int = 8, output_rgba: bool = False\n) -&gt; PixelCollection:\n    \"\"\"Convert a Shape object into a pixel representation.\n\n    This conversion is useful for creating effects like decaying shapes or light effects.\n\n    Args:\n        shape: A Shape object representing the geometric outline to be sampled.\n        supersampling: An integer (\u2265 1) that controls the anti-aliasing resolution. Higher values yield smoother results but increase processing time.\n        output_rgba: A boolean flag indicating the format of the alpha value. If True, the alpha value for each pixel will be a numeric value between 0 and 255; otherwise, it will be returned as an ASS alpha string.\n\n    Returns:\n        PixelCollection: A collection of Pixel objects, where each pixel includes x and y coordinates and an alpha value representing transparency.\n\n    Examples:\n        &gt;&gt;&gt; io.add_style(\"p\", Ass.PIXEL_STYLE)\n        &gt;&gt;&gt; l.style = \"p\"\n        &gt;&gt;&gt; for pixel in Convert.shape_to_pixels(Shape.polygon(4, 20)):\n        ...     x, y = l.left + pixel.x, l.top + pixel.y\n        ...     alpha = \"\\\\alpha\" + str(pixel.alpha) if str(pixel.alpha) != \"&amp;HFF&amp;\" else \"\"\n        ...     l.text = \"{\\\\p1\\\\pos(%d,%d)%s}%s\" % (x, y, alpha, Shape.PIXEL)\n        ...     io.write_line(l)\n\n    Notes:\n        To optimize the ASS file size, it is recommended to use a dedicated pixel style.\n        A pre-made pixel style ([`Ass.PIXEL_STYLE`][pyonfx.ass_core.Ass.PIXEL_STYLE]) is provided in the Ass class and can be added to your ASS output using the [`add_style`][pyonfx.ass_core.Ass.add_style] method.\n\n    See Also:\n        [`Convert.text_to_pixels`][pyonfx.convert.Convert.text_to_pixels]\n    \"\"\"\n    # Validate input\n    if supersampling &lt; 1 or not isinstance(supersampling, int):\n        raise ValueError(\n            \"supersampling must be a positive integer (got %r)\" % supersampling\n        )\n\n    # Convert to Shapely geometry\n    multipolygon = shape.to_multipolygon()\n    if multipolygon.is_empty:\n        return PixelCollection([])\n\n    # Upscale and shift so the bbox is in +ve quadrant\n    multipolygon = _shapely_scale(\n        multipolygon, xfact=supersampling, yfact=supersampling, origin=(0.0, 0.0)\n    )\n\n    min_x, min_y, max_x, max_y = multipolygon.bounds\n    shift_x = -1 * (min_x - (min_x % supersampling))\n    shift_y = -1 * (min_y - (min_y % supersampling))\n    multipolygon = _shapely_translate(multipolygon, xoff=shift_x, yoff=shift_y)\n\n    # Compute high-res grid size (multiple of supersampling)\n    _, _, max_x, max_y = multipolygon.bounds\n    high_w = int(math.ceil(max_x))\n    high_h = int(math.ceil(max_y))\n    if high_w % supersampling:\n        high_w += supersampling - (high_w % supersampling)\n    if high_h % supersampling:\n        high_h += supersampling - (high_h % supersampling)\n\n    # Mark which high-res pixels fall inside the geometry (centre sampling)\n    xs = np.arange(0.5, high_w + 0.5, 1.0, dtype=np.float64)\n    ys = np.arange(0.5, high_h + 0.5, 1.0, dtype=np.float64)\n    X, Y = np.meshgrid(xs, ys)\n    mask = _shapely_contains(multipolygon, X, Y)\n\n    # Downsample mask to screen resolution\n    low_h = high_h // supersampling\n    low_w = high_w // supersampling\n    mask_rs = mask.reshape(low_h, supersampling, low_w, supersampling)\n    coverage_cnt = mask_rs.sum(axis=(1, 3))\n\n    # Convert coverage to alpha\n    denom = supersampling * supersampling\n    alpha_arr = np.rint((denom - coverage_cnt) * 255 / denom).astype(np.int16)\n\n    # Build output PixelCollection, skipping fully transparent pixels using vectorized selection\n    downscale = 1 / supersampling\n    shift_x_low = shift_x * downscale\n    shift_y_low = shift_y * downscale\n\n    non_transparent = np.argwhere(alpha_arr &lt; 255)\n    pixels = [\n        Pixel(\n            x=int(xi - shift_x_low),\n            y=int(yi - shift_y_low),\n            alpha=(\n                int(alpha_arr[yi, xi])\n                if output_rgba\n                else Convert.alpha_dec_to_ass(int(alpha_arr[yi, xi]))\n            ),\n        )\n        for yi, xi in non_transparent\n    ]\n\n    return PixelCollection(pixels)\n</code></pre>"},{"location":"reference/convert/#pyonfx.convert.Convert.image_to_pixels","title":"<code>image_to_pixels(image_path, width=None, height=None, skip_transparent=True, output_rgba=False)</code>  <code>staticmethod</code>","text":"<p>Convert an image file to a pixel representation.</p> <p>Parameters:</p> Name Type Description Default <code>image_path</code> <code>str</code> <p>A file path to an image (absolute or relative to the script).</p> required <code>width</code> <code>int | None</code> <p>Optional; an integer specifying the target width for rescaling. If None, the original width is used.</p> <code>None</code> <code>height</code> <code>int | None</code> <p>Optional; an integer specifying the target height for rescaling. If None, the original height is used. If only one dimension is provided, the aspect ratio is preserved.</p> <code>None</code> <code>skip_transparent</code> <code>bool</code> <p>A boolean flag indicating whether fully transparent pixels (alpha == 0) should be skipped.</p> <code>True</code> <code>output_rgba</code> <code>bool</code> <p>A boolean flag indicating the format of the alpha value. If True, each pixel's alpha value will be a number between 0 and 255 and the color as an RGB tuple; otherwise, the pixel's color is an ASS formatted string and the alpha is an ASS alpha string.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>PixelCollection</code> <code>PixelCollection</code> <p>A collection of Pixel objects, where each pixel includes x and y coordinates and an alpha value representing transparency.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; pixels = Convert.image_to_pixels(\"path_to_image/sample.png\", width=50)\n&gt;&gt;&gt; for pixel in pixels:\n...     print(pixel.x, pixel.y, pixel.alpha)\n</code></pre> Notes <p>To optimize the ASS file size, it is recommended to use a dedicated pixel style. A pre-made pixel style (<code>Ass.PIXEL_STYLE</code>) is provided in the Ass class and can be added to your ASS output using the <code>add_style</code> method.</p> See Also <p><code>PixelCollection.apply_texture</code></p> Source code in <code>pyonfx/convert.py</code> <pre><code>@staticmethod\ndef image_to_pixels(\n    image_path: str,\n    width: int | None = None,\n    height: int | None = None,\n    skip_transparent: bool = True,\n    output_rgba: bool = False,\n) -&gt; PixelCollection:\n    \"\"\"Convert an image file to a pixel representation.\n\n    Args:\n        image_path: A file path to an image (absolute or relative to the script).\n        width: Optional; an integer specifying the target width for rescaling. If None, the original width is used.\n        height: Optional; an integer specifying the target height for rescaling. If None, the original height is used. If only one dimension is provided, the aspect ratio is preserved.\n        skip_transparent: A boolean flag indicating whether fully transparent pixels (alpha == 0) should be skipped.\n        output_rgba: A boolean flag indicating the format of the alpha value. If True, each pixel's alpha value will be a number between 0 and 255 and the color as an RGB tuple; otherwise, the pixel's color is an ASS formatted string and the alpha is an ASS alpha string.\n\n    Returns:\n        PixelCollection: A collection of Pixel objects, where each pixel includes x and y coordinates and an alpha value representing transparency.\n\n    Examples:\n        &gt;&gt;&gt; pixels = Convert.image_to_pixels(\"path_to_image/sample.png\", width=50)\n        &gt;&gt;&gt; for pixel in pixels:\n        ...     print(pixel.x, pixel.y, pixel.alpha)\n\n    Notes:\n        To optimize the ASS file size, it is recommended to use a dedicated pixel style.\n        A pre-made pixel style ([`Ass.PIXEL_STYLE`][pyonfx.ass_core.Ass.PIXEL_STYLE]) is provided in the Ass class and can be added to your ASS output using the [`add_style`][pyonfx.ass_core.Ass.add_style] method.\n\n    See Also:\n        [`PixelCollection.apply_texture`][pyonfx.pixel.PixelCollection.apply_texture]\n    \"\"\"\n    dirname = os.path.dirname(os.path.abspath(sys.argv[0]))\n    if not os.path.isabs(image_path):\n        image_path = os.path.join(dirname, image_path)\n    try:\n        img = Image.open(image_path)\n    except Exception as e:\n        raise ValueError(f\"Could not open image at '{image_path}': {e}\")\n    if img.mode != \"RGBA\":\n        img = img.convert(\"RGBA\")\n\n    # Rescale image if width or height is specified\n    if width is not None or height is not None:\n        try:\n            # If only one dimension is specified, maintain aspect ratio\n            original_width, original_height = img.size\n            if width is not None and height is None:\n                ratio = width / original_width\n                height = int(original_height * ratio)\n            elif height is not None and width is None:\n                ratio = height / original_height\n                width = int(original_width * ratio)\n\n            if width is not None and height is not None:\n                img = img.resize((width, height), Image.Resampling.LANCZOS)\n        except Exception as e:\n            raise ValueError(f\"Error resizing image: {e}\")\n\n    width, height = img.size\n    pixels_data = list(img.getdata())  # type: ignore[arg-type]\n\n    pixels = []\n    for i, (r, g, b, a) in enumerate(pixels_data):\n        if skip_transparent and a == 0:\n            continue\n        x = i % width\n        y = i // width\n        if output_rgba:\n            pixel_color = (r, g, b)\n            pixel_alpha = 255 - a\n        else:\n            pixel_color = Convert.color_rgb_to_ass((r, g, b))\n            pixel_alpha = Convert.alpha_dec_to_ass(255 - a)\n        pixels.append(Pixel(x=x, y=y, color=pixel_color, alpha=pixel_alpha))\n\n    return PixelCollection(pixels)\n</code></pre>"},{"location":"reference/pixel/","title":"Pixel","text":""},{"location":"reference/pixel/#pyonfx.pixel.PixelCollection","title":"<code>PixelCollection</code>","text":"Source code in <code>pyonfx/pixel.py</code> <pre><code>class PixelCollection:\n    def __init__(self, pixels: Iterable[Pixel]):\n        self._pixels = list(pixels)\n\n    def __iter__(self) -&gt; Iterator[Pixel]:\n        return iter(self._pixels)\n\n    def __len__(self) -&gt; int:\n        return len(self._pixels)\n\n    def __getitem__(self, index: int | slice) -&gt; \"Pixel | PixelCollection\":\n        if isinstance(index, slice):\n            return PixelCollection(self._pixels[index])\n        return self._pixels[index]\n\n    def __bool__(self) -&gt; bool:\n        return bool(self._pixels)\n\n    def __repr__(self) -&gt; str:\n        return f\"PixelCollection({len(self._pixels)} pixels)\"\n\n    # Bounds and properties\n    @property\n    def bounds(self) -&gt; tuple[int, int, int, int]:\n        \"\"\"Returns (min_x, min_y, max_x, max_y)\"\"\"\n        if not self._pixels:\n            return (0, 0, 0, 0)\n        xs = [p.x for p in self._pixels]\n        ys = [p.y for p in self._pixels]\n        return (min(xs), min(ys), max(xs), max(ys))\n\n    @property\n    def width(self) -&gt; int:\n        min_x, _, max_x, _ = self.bounds\n        return max_x - min_x + 1\n\n    @property\n    def height(self) -&gt; int:\n        _, min_y, _, max_y = self.bounds\n        return max_y - min_y + 1\n\n    def is_empty(self) -&gt; bool:\n        return len(self._pixels) == 0\n\n    # Filtering and selection\n    def filter(self, predicate: Callable[[Pixel], bool]) -&gt; \"PixelCollection\":\n        return PixelCollection(p for p in self._pixels if predicate(p))\n\n    def filter_by_region(self, x1: int, y1: int, x2: int, y2: int) -&gt; \"PixelCollection\":\n        return self.filter(lambda p: x1 &lt;= p.x &lt;= x2 and y1 &lt;= p.y &lt;= y2)\n\n    def filter_by_color(self, color: str | tuple[int, int, int]) -&gt; \"PixelCollection\":\n        return self.filter(lambda p: p.color == color)\n\n    def at_position(self, x: int, y: int) -&gt; list[Pixel]:\n        \"\"\"Get all pixels at a specific position (there could be multiple)\"\"\"\n        return [p for p in self._pixels if p.x == x and p.y == y]\n\n    # Transformations\n    def map(self, transform: Callable[[Pixel], Pixel]) -&gt; \"PixelCollection\":\n        return PixelCollection(transform(p) for p in self._pixels)\n\n    def move(self, dx: int, dy: int) -&gt; \"PixelCollection\":\n        return self.map(lambda p: p.with_position(p.x + dx, p.y + dy))\n\n    # Texture operations\n    def apply_texture(\n        self,\n        texture: \"str | PixelCollection\",\n        mode: Literal[\"stretch\", \"repeat\", \"repeat_h\", \"repeat_v\"] = \"stretch\",\n        skip_transparent: bool = False,\n        output_rgba: bool = False,\n        blend_mode: Literal[\"replace\", \"multiply\"] = \"replace\",\n        missing_pixel: Literal[\"default\", \"skip\"] = \"default\",\n    ) -&gt; \"PixelCollection\":\n        \"\"\"Applies a texture onto this pixel collection.\n\n        This method maps the provided texture (from image or another PixelCollection) onto\n        the current pixels using the specified mapping mode.\n\n        Parameters:\n            texture (str | PixelCollection): Path to texture image or a PixelCollection to use as texture.\n            mode (str): Texture mapping mode:\n                - \"stretch\": Scale texture to exactly cover the pixel collection's bounding box.\n                - \"repeat\": Use texture's natural resolution and tile it across both dimensions.\n                - \"repeat_h\": Scale texture height to fit bounding box and tile horizontally.\n                - \"repeat_v\": Scale texture width to fit bounding box and tile vertically.\n            skip_transparent (bool): Whether to skip transparent pixels in the texture.\n            output_rgba (bool): If True, returns texture pixels in RGBA tuple format; otherwise in ASS color format.\n            blend_mode (str): How to blend texture with existing pixels:\n                - \"replace\": Replace color, keep original alpha\n                - \"multiply\": Multiply colors together\n            missing_pixel (str): Behavior when the corresponding texture pixel is missing. 'default' uses a default white pixel; 'skip' leaves the base pixel unchanged.\n\n        Returns:\n            PixelCollection: A new PixelCollection with the texture applied.\n        \"\"\"\n        # Import here to avoid circular dependencies\n        from .convert import Convert\n\n        def _load_texture_from_image(\n            image_path: str, mode: str, skip_transparent: bool, output_rgba: bool\n        ) -&gt; \"PixelCollection\":\n            \"\"\"Load texture pixels from image file based on the mapping mode.\"\"\"\n            min_x, min_y, max_x, max_y = self.bounds\n            bb_width = max_x - min_x if (max_x - min_x) != 0 else 1\n            bb_height = max_y - min_y if (max_y - min_y) != 0 else 1\n\n            # Load image with appropriate dimensions based on mode\n            if mode == \"stretch\":\n                return Convert.image_to_pixels(\n                    image_path,\n                    width=bb_width,\n                    height=bb_height,\n                    skip_transparent=skip_transparent,\n                    output_rgba=output_rgba,\n                )\n            elif mode == \"repeat_h\":\n                return Convert.image_to_pixels(\n                    image_path,\n                    height=bb_height,\n                    skip_transparent=skip_transparent,\n                    output_rgba=output_rgba,\n                )\n            elif mode == \"repeat_v\":\n                return Convert.image_to_pixels(\n                    image_path,\n                    width=bb_width,\n                    skip_transparent=skip_transparent,\n                    output_rgba=output_rgba,\n                )\n            elif mode == \"repeat\":\n                return Convert.image_to_pixels(\n                    image_path,\n                    skip_transparent=skip_transparent,\n                    output_rgba=output_rgba,\n                )\n            else:\n                raise ValueError(\n                    f\"Unknown texture mode: {mode}. Use 'stretch', 'repeat', 'repeat_h' or 'repeat_v'.\"\n                )\n\n        def _map_to_texture_coords(\n            pixel_x: int,\n            pixel_y: int,\n            min_x: int,\n            min_y: int,\n            bb_width: int,\n            bb_height: int,\n            tex_width: int,\n            tex_height: int,\n            mode: str,\n        ) -&gt; tuple[int, int]:\n            \"\"\"Map pixel coordinates to texture coordinates based on mode.\"\"\"\n            if mode == \"stretch\":\n                u = (pixel_x - min_x) / bb_width\n                v = (pixel_y - min_y) / bb_height\n                tex_x = int(u * (tex_width - 1))\n                tex_y = int(v * (tex_height - 1))\n            elif mode == \"repeat\":\n                tex_x = (pixel_x - min_x) % tex_width\n                tex_y = (pixel_y - min_y) % tex_height\n            elif mode == \"repeat_h\":\n                v = (pixel_y - min_y) / bb_height\n                tex_y = int(v * (tex_height - 1))\n                tex_x = (pixel_x - min_x) % tex_width\n            elif mode == \"repeat_v\":\n                u = (pixel_x - min_x) / bb_width\n                tex_x = int(u * (tex_width - 1))\n                tex_y = (pixel_y - min_y) % tex_height\n            else:\n                raise ValueError(\n                    f\"Unknown texture mode: {mode}. Use 'stretch', 'repeat', 'repeat_h' or 'repeat_v'.\"\n                )\n\n            return tex_x, tex_y\n\n        def _blend_colors(\n            base_color: str | tuple[int, int, int],\n            texture_color: str | tuple[int, int, int],\n            blend_mode: str,\n        ) -&gt; str | tuple[int, int, int]:\n            \"\"\"Blend base color with texture color using specified blend mode.\"\"\"\n            if blend_mode == \"replace\":\n                return texture_color\n\n            # Convert input colors to RGB tuples if they are in ASS format strings\n            if isinstance(base_color, str):\n                base_rgb = Convert.color_ass_to_rgb(base_color, as_str=False)\n            else:\n                base_rgb = base_color\n            if isinstance(texture_color, str):\n                texture_rgb = Convert.color_ass_to_rgb(texture_color, as_str=False)\n            else:\n                texture_rgb = texture_color\n\n            r1, g1, b1 = int(base_rgb[0]), int(base_rgb[1]), int(base_rgb[2])\n            r2, g2, b2 = int(texture_rgb[0]), int(texture_rgb[1]), int(texture_rgb[2])\n\n            if blend_mode == \"multiply\":\n                new_r = int((r1 * r2) / 255)\n                new_g = int((g1 * g2) / 255)\n                new_b = int((b1 * b2) / 255)\n            else:\n                raise ValueError(\n                    f\"Unknown blend mode: {blend_mode}. Use 'replace' or 'multiply'.\"\n                )\n\n            new_rgb = (min(new_r, 255), min(new_g, 255), min(new_b, 255))\n\n            # Return in the same format as the base color\n            if isinstance(base_color, str):\n                return Convert.color_rgb_to_ass(new_rgb)\n            return new_rgb\n\n        if self.is_empty():\n            return PixelCollection([])\n\n        # Load texture pixels\n        if isinstance(texture, str):\n            # Load from image file\n            texture_pixels = _load_texture_from_image(\n                texture, mode, skip_transparent, output_rgba\n            )\n        else:\n            # Use provided PixelCollection as texture\n            texture_pixels = texture\n\n        if texture_pixels.is_empty():\n            raise ValueError(\"Texture did not produce any pixels.\")\n\n        # Get bounds for mapping\n        min_x, min_y, _, _ = self.bounds\n        bb_width = self.width\n        bb_height = self.height\n\n        # Get texture bounds\n        tex_min_x, tex_min_y, _, _ = texture_pixels.bounds\n        tex_width = texture_pixels.width\n        tex_height = texture_pixels.height\n\n        # Build texture lookup dictionary for efficiency\n        tex_dict = {(p.x - tex_min_x, p.y - tex_min_y): p for p in texture_pixels}\n\n        # Apply texture to each pixel\n        textured_pixels = []\n        for pixel in self._pixels:\n            # Map pixel to texture coordinates based on mode\n            tex_x, tex_y = _map_to_texture_coords(\n                pixel.x,\n                pixel.y,\n                min_x,\n                min_y,\n                bb_width,\n                bb_height,\n                tex_width,\n                tex_height,\n                mode,\n            )\n\n            # Get texture pixel (with fallback based on missing_pixel behavior)\n            texture_pixel = tex_dict.get((tex_x, tex_y))\n            if texture_pixel is None:\n                if missing_pixel == \"default\":\n                    if output_rgba:\n                        texture_pixel = Pixel(\n                            x=tex_x, y=tex_y, color=(255, 255, 255), alpha=255\n                        )\n                    else:\n                        texture_pixel = Pixel(\n                            x=tex_x, y=tex_y, color=\"&amp;HFFFFFF&amp;\", alpha=\"&amp;HFF&amp;\"\n                        )\n                elif missing_pixel == \"skip\":\n                    continue\n\n            # Apply blending\n            new_color = _blend_colors(pixel.color, texture_pixel.color, blend_mode)\n\n            # Keep original alpha (texture affects color, not transparency of the shape)\n            textured_pixels.append(\n                Pixel(x=pixel.x, y=pixel.y, color=new_color, alpha=pixel.alpha)\n            )\n\n        return PixelCollection(textured_pixels)\n</code></pre>"},{"location":"reference/pixel/#pyonfx.pixel.PixelCollection.bounds","title":"<code>bounds</code>  <code>property</code>","text":"<p>Returns (min_x, min_y, max_x, max_y)</p>"},{"location":"reference/pixel/#pyonfx.pixel.PixelCollection.at_position","title":"<code>at_position(x, y)</code>","text":"<p>Get all pixels at a specific position (there could be multiple)</p> Source code in <code>pyonfx/pixel.py</code> <pre><code>def at_position(self, x: int, y: int) -&gt; list[Pixel]:\n    \"\"\"Get all pixels at a specific position (there could be multiple)\"\"\"\n    return [p for p in self._pixels if p.x == x and p.y == y]\n</code></pre>"},{"location":"reference/pixel/#pyonfx.pixel.PixelCollection.apply_texture","title":"<code>apply_texture(texture, mode='stretch', skip_transparent=False, output_rgba=False, blend_mode='replace', missing_pixel='default')</code>","text":"<p>Applies a texture onto this pixel collection.</p> <p>This method maps the provided texture (from image or another PixelCollection) onto the current pixels using the specified mapping mode.</p> <p>Parameters:</p> Name Type Description Default <code>texture</code> <code>str | PixelCollection</code> <p>Path to texture image or a PixelCollection to use as texture.</p> required <code>mode</code> <code>str</code> <p>Texture mapping mode: - \"stretch\": Scale texture to exactly cover the pixel collection's bounding box. - \"repeat\": Use texture's natural resolution and tile it across both dimensions. - \"repeat_h\": Scale texture height to fit bounding box and tile horizontally. - \"repeat_v\": Scale texture width to fit bounding box and tile vertically.</p> <code>'stretch'</code> <code>skip_transparent</code> <code>bool</code> <p>Whether to skip transparent pixels in the texture.</p> <code>False</code> <code>output_rgba</code> <code>bool</code> <p>If True, returns texture pixels in RGBA tuple format; otherwise in ASS color format.</p> <code>False</code> <code>blend_mode</code> <code>str</code> <p>How to blend texture with existing pixels: - \"replace\": Replace color, keep original alpha - \"multiply\": Multiply colors together</p> <code>'replace'</code> <code>missing_pixel</code> <code>str</code> <p>Behavior when the corresponding texture pixel is missing. 'default' uses a default white pixel; 'skip' leaves the base pixel unchanged.</p> <code>'default'</code> <p>Returns:</p> Name Type Description <code>PixelCollection</code> <code>PixelCollection</code> <p>A new PixelCollection with the texture applied.</p> Source code in <code>pyonfx/pixel.py</code> <pre><code>def apply_texture(\n    self,\n    texture: \"str | PixelCollection\",\n    mode: Literal[\"stretch\", \"repeat\", \"repeat_h\", \"repeat_v\"] = \"stretch\",\n    skip_transparent: bool = False,\n    output_rgba: bool = False,\n    blend_mode: Literal[\"replace\", \"multiply\"] = \"replace\",\n    missing_pixel: Literal[\"default\", \"skip\"] = \"default\",\n) -&gt; \"PixelCollection\":\n    \"\"\"Applies a texture onto this pixel collection.\n\n    This method maps the provided texture (from image or another PixelCollection) onto\n    the current pixels using the specified mapping mode.\n\n    Parameters:\n        texture (str | PixelCollection): Path to texture image or a PixelCollection to use as texture.\n        mode (str): Texture mapping mode:\n            - \"stretch\": Scale texture to exactly cover the pixel collection's bounding box.\n            - \"repeat\": Use texture's natural resolution and tile it across both dimensions.\n            - \"repeat_h\": Scale texture height to fit bounding box and tile horizontally.\n            - \"repeat_v\": Scale texture width to fit bounding box and tile vertically.\n        skip_transparent (bool): Whether to skip transparent pixels in the texture.\n        output_rgba (bool): If True, returns texture pixels in RGBA tuple format; otherwise in ASS color format.\n        blend_mode (str): How to blend texture with existing pixels:\n            - \"replace\": Replace color, keep original alpha\n            - \"multiply\": Multiply colors together\n        missing_pixel (str): Behavior when the corresponding texture pixel is missing. 'default' uses a default white pixel; 'skip' leaves the base pixel unchanged.\n\n    Returns:\n        PixelCollection: A new PixelCollection with the texture applied.\n    \"\"\"\n    # Import here to avoid circular dependencies\n    from .convert import Convert\n\n    def _load_texture_from_image(\n        image_path: str, mode: str, skip_transparent: bool, output_rgba: bool\n    ) -&gt; \"PixelCollection\":\n        \"\"\"Load texture pixels from image file based on the mapping mode.\"\"\"\n        min_x, min_y, max_x, max_y = self.bounds\n        bb_width = max_x - min_x if (max_x - min_x) != 0 else 1\n        bb_height = max_y - min_y if (max_y - min_y) != 0 else 1\n\n        # Load image with appropriate dimensions based on mode\n        if mode == \"stretch\":\n            return Convert.image_to_pixels(\n                image_path,\n                width=bb_width,\n                height=bb_height,\n                skip_transparent=skip_transparent,\n                output_rgba=output_rgba,\n            )\n        elif mode == \"repeat_h\":\n            return Convert.image_to_pixels(\n                image_path,\n                height=bb_height,\n                skip_transparent=skip_transparent,\n                output_rgba=output_rgba,\n            )\n        elif mode == \"repeat_v\":\n            return Convert.image_to_pixels(\n                image_path,\n                width=bb_width,\n                skip_transparent=skip_transparent,\n                output_rgba=output_rgba,\n            )\n        elif mode == \"repeat\":\n            return Convert.image_to_pixels(\n                image_path,\n                skip_transparent=skip_transparent,\n                output_rgba=output_rgba,\n            )\n        else:\n            raise ValueError(\n                f\"Unknown texture mode: {mode}. Use 'stretch', 'repeat', 'repeat_h' or 'repeat_v'.\"\n            )\n\n    def _map_to_texture_coords(\n        pixel_x: int,\n        pixel_y: int,\n        min_x: int,\n        min_y: int,\n        bb_width: int,\n        bb_height: int,\n        tex_width: int,\n        tex_height: int,\n        mode: str,\n    ) -&gt; tuple[int, int]:\n        \"\"\"Map pixel coordinates to texture coordinates based on mode.\"\"\"\n        if mode == \"stretch\":\n            u = (pixel_x - min_x) / bb_width\n            v = (pixel_y - min_y) / bb_height\n            tex_x = int(u * (tex_width - 1))\n            tex_y = int(v * (tex_height - 1))\n        elif mode == \"repeat\":\n            tex_x = (pixel_x - min_x) % tex_width\n            tex_y = (pixel_y - min_y) % tex_height\n        elif mode == \"repeat_h\":\n            v = (pixel_y - min_y) / bb_height\n            tex_y = int(v * (tex_height - 1))\n            tex_x = (pixel_x - min_x) % tex_width\n        elif mode == \"repeat_v\":\n            u = (pixel_x - min_x) / bb_width\n            tex_x = int(u * (tex_width - 1))\n            tex_y = (pixel_y - min_y) % tex_height\n        else:\n            raise ValueError(\n                f\"Unknown texture mode: {mode}. Use 'stretch', 'repeat', 'repeat_h' or 'repeat_v'.\"\n            )\n\n        return tex_x, tex_y\n\n    def _blend_colors(\n        base_color: str | tuple[int, int, int],\n        texture_color: str | tuple[int, int, int],\n        blend_mode: str,\n    ) -&gt; str | tuple[int, int, int]:\n        \"\"\"Blend base color with texture color using specified blend mode.\"\"\"\n        if blend_mode == \"replace\":\n            return texture_color\n\n        # Convert input colors to RGB tuples if they are in ASS format strings\n        if isinstance(base_color, str):\n            base_rgb = Convert.color_ass_to_rgb(base_color, as_str=False)\n        else:\n            base_rgb = base_color\n        if isinstance(texture_color, str):\n            texture_rgb = Convert.color_ass_to_rgb(texture_color, as_str=False)\n        else:\n            texture_rgb = texture_color\n\n        r1, g1, b1 = int(base_rgb[0]), int(base_rgb[1]), int(base_rgb[2])\n        r2, g2, b2 = int(texture_rgb[0]), int(texture_rgb[1]), int(texture_rgb[2])\n\n        if blend_mode == \"multiply\":\n            new_r = int((r1 * r2) / 255)\n            new_g = int((g1 * g2) / 255)\n            new_b = int((b1 * b2) / 255)\n        else:\n            raise ValueError(\n                f\"Unknown blend mode: {blend_mode}. Use 'replace' or 'multiply'.\"\n            )\n\n        new_rgb = (min(new_r, 255), min(new_g, 255), min(new_b, 255))\n\n        # Return in the same format as the base color\n        if isinstance(base_color, str):\n            return Convert.color_rgb_to_ass(new_rgb)\n        return new_rgb\n\n    if self.is_empty():\n        return PixelCollection([])\n\n    # Load texture pixels\n    if isinstance(texture, str):\n        # Load from image file\n        texture_pixels = _load_texture_from_image(\n            texture, mode, skip_transparent, output_rgba\n        )\n    else:\n        # Use provided PixelCollection as texture\n        texture_pixels = texture\n\n    if texture_pixels.is_empty():\n        raise ValueError(\"Texture did not produce any pixels.\")\n\n    # Get bounds for mapping\n    min_x, min_y, _, _ = self.bounds\n    bb_width = self.width\n    bb_height = self.height\n\n    # Get texture bounds\n    tex_min_x, tex_min_y, _, _ = texture_pixels.bounds\n    tex_width = texture_pixels.width\n    tex_height = texture_pixels.height\n\n    # Build texture lookup dictionary for efficiency\n    tex_dict = {(p.x - tex_min_x, p.y - tex_min_y): p for p in texture_pixels}\n\n    # Apply texture to each pixel\n    textured_pixels = []\n    for pixel in self._pixels:\n        # Map pixel to texture coordinates based on mode\n        tex_x, tex_y = _map_to_texture_coords(\n            pixel.x,\n            pixel.y,\n            min_x,\n            min_y,\n            bb_width,\n            bb_height,\n            tex_width,\n            tex_height,\n            mode,\n        )\n\n        # Get texture pixel (with fallback based on missing_pixel behavior)\n        texture_pixel = tex_dict.get((tex_x, tex_y))\n        if texture_pixel is None:\n            if missing_pixel == \"default\":\n                if output_rgba:\n                    texture_pixel = Pixel(\n                        x=tex_x, y=tex_y, color=(255, 255, 255), alpha=255\n                    )\n                else:\n                    texture_pixel = Pixel(\n                        x=tex_x, y=tex_y, color=\"&amp;HFFFFFF&amp;\", alpha=\"&amp;HFF&amp;\"\n                    )\n            elif missing_pixel == \"skip\":\n                continue\n\n        # Apply blending\n        new_color = _blend_colors(pixel.color, texture_pixel.color, blend_mode)\n\n        # Keep original alpha (texture affects color, not transparency of the shape)\n        textured_pixels.append(\n            Pixel(x=pixel.x, y=pixel.y, color=new_color, alpha=pixel.alpha)\n        )\n\n    return PixelCollection(textured_pixels)\n</code></pre>"},{"location":"reference/shape/","title":"Shape","text":""},{"location":"reference/shape/#pyonfx.shape.ShapeElement","title":"<code>ShapeElement</code>","text":"<p>Represents a single ASS drawing command and its associated coordinates.</p> <p>This class encapsulates a drawing command used in the ASS format and stores the related coordinates as <code>shapely.geometry.Point</code> objects. It validates the command against allowed values (\"m\", \"n\", \"l\", \"p\", \"b\", \"s\", \"c\") and provides utility methods for creating and representing these commands.</p> <p>Attributes:</p> Name Type Description <code>command</code> <code>str</code> <p>The drawing command (e.g., \"m\", \"n\", \"l\", \"p\", \"b\", \"s\", \"c\").</p> <code>coordinates</code> <code>list[Point]</code> <p>A list of <code>Point</code> objects representing the coordinate pairs.</p> See Also <p><code>Shape</code></p> Source code in <code>pyonfx/shape.py</code> <pre><code>class ShapeElement:\n    \"\"\"Represents a single ASS drawing command and its associated coordinates.\n\n    This class encapsulates a drawing command used in the ASS format and stores the related coordinates\n    as `shapely.geometry.Point` objects. It validates the command against allowed values (\"m\", \"n\", \"l\", \"p\", \"b\", \"s\", \"c\")\n    and provides utility methods for creating and representing these commands.\n\n    Attributes:\n        command: The drawing command (e.g., \"m\", \"n\", \"l\", \"p\", \"b\", \"s\", \"c\").\n        coordinates: A list of `Point` objects representing the coordinate pairs.\n\n    See Also:\n        [`Shape`][pyonfx.shape.Shape]\n    \"\"\"\n\n    command: str\n    \"\"\"The drawing command (one of \"m\", \"n\", \"l\", \"p\", \"b\", \"s\", \"c\").\"\"\"\n    coordinates: list[Point]\n    \"\"\"List of `Point` objects representing the coordinate pairs for this command.\"\"\"\n\n    def __init__(self, command: str, coordinates: list[Point]):\n        \"\"\"Initialize a ShapeElement instance.\n\n        Args:\n            command: The ASS drawing command. Allowed values are \"m\", \"n\", \"l\", \"p\", \"b\", \"s\", \"c\".\n            coordinates: A list of `Point` objects representing the coordinate pairs.\n        \"\"\"\n        if command not in {\"m\", \"n\", \"l\", \"p\", \"b\", \"s\", \"c\"}:\n            raise ValueError(f\"Invalid command '{command}'\")\n        self.command = command\n        self.coordinates = coordinates\n\n    def __repr__(self):\n        coord_strs = [f\"Point({c.x}, {c.y})\" for c in self.coordinates]\n        return f\"ShapeElement('{self.command}', [{', '.join(coord_strs)}])\"\n\n    def __eq__(self, other):\n        return (\n            isinstance(other, ShapeElement)\n            and self.command == other.command\n            and self.coordinates == other.coordinates\n        )\n\n    @classmethod\n    def from_ass_drawing_cmd(cls, command: str, *args: str) -&gt; list[\"ShapeElement\"]:\n        \"\"\"Parse an ASS drawing command into one or more ShapeElement instances.\n\n        Since some commands can be implicit, this method can return more than one element.\n\n        Args:\n            command: The ASS drawing command. Must be one of \"m\", \"n\", \"l\", \"p\", \"b\", \"s\", \"c\".\n            *args: A sequence of string arguments representing numeric values for coordinates.\n\n        Returns:\n            list[ShapeElement]: A list of ShapeElement instances created from the command.\n\n        Notes:\n            - Command 'c' does not accept any arguments.\n            - Command 'l' returns one element for each encountered coordinate.\n            - Command 'b' groups coordinates into sets of three.\n        \"\"\"\n        if len(args) % 2 != 0:\n            raise ValueError(\n                f\"Every ASS drawing command requires an even number of arguments (got {len(args)})\"\n            )\n\n        try:\n            coords = [\n                Point(float(args[i]), float(args[i + 1]))\n                for i in range(0, len(args), 2)\n            ]\n        except ValueError:\n            raise ValueError(\n                f\"Invalid arguments (expected floats) for command '{command}': {args}\"\n            )\n\n        match command:\n            case \"c\":\n                if len(args) != 0:\n                    raise ValueError(f\"Command 'c' does not take any arguments\")\n                return [cls(command, [])]\n\n            case \"m\" | \"n\" | \"p\":\n                if len(coords) != 1:\n                    raise ValueError(\n                        f\"Command '{command}' requires exactly 1 coordinate pair\"\n                    )\n                return [cls(command, coords)]\n\n            case \"s\":\n                if len(coords) &lt; 3:\n                    raise ValueError(\n                        f\"Command 's' requires at least 3 coordinate pairs\"\n                    )\n                return [cls(command, coords)]\n\n            case \"l\":\n                if not coords:\n                    raise ValueError(\"Command 'l' requires at least 1 coordinate pair\")\n                return [cls(command, [c]) for c in coords]\n\n            case \"b\":\n                if len(coords) % 3 != 0 or not coords:\n                    raise ValueError(\n                        \"Command 'b' requires a number of coordinate pairs multiple of 3\"\n                    )\n\n                return [\n                    cls(command, coords[i : i + 3]) for i in range(0, len(coords), 3)\n                ]\n\n            case _:\n                raise ValueError(f\"Unexpected command '{command}'\")\n</code></pre>"},{"location":"reference/shape/#pyonfx.shape.ShapeElement.command","title":"<code>command = command</code>  <code>instance-attribute</code>","text":"<p>The drawing command (one of \"m\", \"n\", \"l\", \"p\", \"b\", \"s\", \"c\").</p>"},{"location":"reference/shape/#pyonfx.shape.ShapeElement.coordinates","title":"<code>coordinates = coordinates</code>  <code>instance-attribute</code>","text":"<p>List of <code>Point</code> objects representing the coordinate pairs for this command.</p>"},{"location":"reference/shape/#pyonfx.shape.ShapeElement.__init__","title":"<code>__init__(command, coordinates)</code>","text":"<p>Initialize a ShapeElement instance.</p> <p>Parameters:</p> Name Type Description Default <code>command</code> <code>str</code> <p>The ASS drawing command. Allowed values are \"m\", \"n\", \"l\", \"p\", \"b\", \"s\", \"c\".</p> required <code>coordinates</code> <code>list[Point]</code> <p>A list of <code>Point</code> objects representing the coordinate pairs.</p> required Source code in <code>pyonfx/shape.py</code> <pre><code>def __init__(self, command: str, coordinates: list[Point]):\n    \"\"\"Initialize a ShapeElement instance.\n\n    Args:\n        command: The ASS drawing command. Allowed values are \"m\", \"n\", \"l\", \"p\", \"b\", \"s\", \"c\".\n        coordinates: A list of `Point` objects representing the coordinate pairs.\n    \"\"\"\n    if command not in {\"m\", \"n\", \"l\", \"p\", \"b\", \"s\", \"c\"}:\n        raise ValueError(f\"Invalid command '{command}'\")\n    self.command = command\n    self.coordinates = coordinates\n</code></pre>"},{"location":"reference/shape/#pyonfx.shape.ShapeElement.from_ass_drawing_cmd","title":"<code>from_ass_drawing_cmd(command, *args)</code>  <code>classmethod</code>","text":"<p>Parse an ASS drawing command into one or more ShapeElement instances.</p> <p>Since some commands can be implicit, this method can return more than one element.</p> <p>Parameters:</p> Name Type Description Default <code>command</code> <code>str</code> <p>The ASS drawing command. Must be one of \"m\", \"n\", \"l\", \"p\", \"b\", \"s\", \"c\".</p> required <code>*args</code> <code>str</code> <p>A sequence of string arguments representing numeric values for coordinates.</p> <code>()</code> <p>Returns:</p> Type Description <code>list[ShapeElement]</code> <p>list[ShapeElement]: A list of ShapeElement instances created from the command.</p> Notes <ul> <li>Command 'c' does not accept any arguments.</li> <li>Command 'l' returns one element for each encountered coordinate.</li> <li>Command 'b' groups coordinates into sets of three.</li> </ul> Source code in <code>pyonfx/shape.py</code> <pre><code>@classmethod\ndef from_ass_drawing_cmd(cls, command: str, *args: str) -&gt; list[\"ShapeElement\"]:\n    \"\"\"Parse an ASS drawing command into one or more ShapeElement instances.\n\n    Since some commands can be implicit, this method can return more than one element.\n\n    Args:\n        command: The ASS drawing command. Must be one of \"m\", \"n\", \"l\", \"p\", \"b\", \"s\", \"c\".\n        *args: A sequence of string arguments representing numeric values for coordinates.\n\n    Returns:\n        list[ShapeElement]: A list of ShapeElement instances created from the command.\n\n    Notes:\n        - Command 'c' does not accept any arguments.\n        - Command 'l' returns one element for each encountered coordinate.\n        - Command 'b' groups coordinates into sets of three.\n    \"\"\"\n    if len(args) % 2 != 0:\n        raise ValueError(\n            f\"Every ASS drawing command requires an even number of arguments (got {len(args)})\"\n        )\n\n    try:\n        coords = [\n            Point(float(args[i]), float(args[i + 1]))\n            for i in range(0, len(args), 2)\n        ]\n    except ValueError:\n        raise ValueError(\n            f\"Invalid arguments (expected floats) for command '{command}': {args}\"\n        )\n\n    match command:\n        case \"c\":\n            if len(args) != 0:\n                raise ValueError(f\"Command 'c' does not take any arguments\")\n            return [cls(command, [])]\n\n        case \"m\" | \"n\" | \"p\":\n            if len(coords) != 1:\n                raise ValueError(\n                    f\"Command '{command}' requires exactly 1 coordinate pair\"\n                )\n            return [cls(command, coords)]\n\n        case \"s\":\n            if len(coords) &lt; 3:\n                raise ValueError(\n                    f\"Command 's' requires at least 3 coordinate pairs\"\n                )\n            return [cls(command, coords)]\n\n        case \"l\":\n            if not coords:\n                raise ValueError(\"Command 'l' requires at least 1 coordinate pair\")\n            return [cls(command, [c]) for c in coords]\n\n        case \"b\":\n            if len(coords) % 3 != 0 or not coords:\n                raise ValueError(\n                    \"Command 'b' requires a number of coordinate pairs multiple of 3\"\n                )\n\n            return [\n                cls(command, coords[i : i + 3]) for i in range(0, len(coords), 3)\n            ]\n\n        case _:\n            raise ValueError(f\"Unexpected command '{command}'\")\n</code></pre>"},{"location":"reference/shape/#pyonfx.shape.Shape","title":"<code>Shape</code>","text":"<p>High-level container for ASS drawing commands.</p> <p>This class represents a vector outline for ASS subtitles, storing its geometry as a sequence of <code>ShapeElement</code> objects. It dynamically generates an ASS drawing command string from its internal elements, ensuring consistency between the geometry and its textual representation. The <code>Shape</code> class provides numerous methods for geometric transformations (e.g., move, scale, rotate, shear), analysis (e.g., bounding box computation), boolean operations, and morphing.</p> <p>Attributes:</p> Name Type Description <code>elements</code> <code>list[ShapeElement]</code> <p>List of drawing command elements representing the shape outline.</p> <code>drawing_cmds</code> <code>str</code> <p>The dynamically generated ASS drawing command string derived from <code>elements</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; shape = Shape(\"m 0 0 l 10 0 10 10\")\n&gt;&gt;&gt; shape.move(5, 5)\n'm 5 5 l 15 5 15 15'\n&gt;&gt;&gt; for element in shape:\n...     print(element)\n</code></pre> Notes <p>Transformations typically return a new <code>Shape</code> instance to allow method chaining.</p> See Also <p><code>ShapeElement</code></p> Source code in <code>pyonfx/shape.py</code> <pre><code>class Shape:\n    \"\"\"High-level container for ASS drawing commands.\n\n    This class represents a vector outline for ASS subtitles, storing its geometry as a sequence of [`ShapeElement`][pyonfx.shape.ShapeElement] objects.\n    It dynamically generates an ASS drawing command string from its internal elements, ensuring consistency between the geometry and its textual representation.\n    The `Shape` class provides numerous methods for geometric transformations (e.g., move, scale, rotate, shear), analysis (e.g., bounding box computation), boolean operations, and morphing.\n\n    Attributes:\n        elements: List of drawing command elements representing the shape outline.\n        drawing_cmds: The dynamically generated ASS drawing command string derived from `elements`.\n\n    Examples:\n        &gt;&gt;&gt; shape = Shape(\"m 0 0 l 10 0 10 10\")\n        &gt;&gt;&gt; shape.move(5, 5)\n        'm 5 5 l 15 5 15 15'\n        &gt;&gt;&gt; for element in shape:\n        ...     print(element)\n\n    Notes:\n        Transformations typically return a new `Shape` instance to allow method chaining.\n\n    See Also:\n        [`ShapeElement`][pyonfx.shape.ShapeElement]\n    \"\"\"\n\n    elements: list[ShapeElement]\n    \"\"\"The shape's elements as a list of :class:`ShapeElement` objects.\"\"\"\n\n    def __init__(self, drawing_cmds: str = \"\", elements: list[ShapeElement] = []):\n        # Assure that drawing_cmds is a string\n        if drawing_cmds and elements:\n            raise ValueError(\"Cannot pass both drawing_cmds and elements.\")\n        if drawing_cmds:\n            self.elements = Shape._cmds_to_elements(drawing_cmds)\n        else:\n            self.elements = elements\n\n    def __repr__(self):\n        # We return drawing commands as a string rapresentation of the object\n        return self.drawing_cmds\n\n    def __eq__(self, other: \"Shape\"):\n        return type(other) is type(self) and self.drawing_cmds == other.drawing_cmds\n\n    def __iter__(self):\n        return iter(self.elements)\n\n    @property\n    def drawing_cmds(self) -&gt; str:\n        \"\"\"The shape's drawing commands in ASS format as a string.\"\"\"\n        return Shape._elements_to_cmds(self.elements)\n\n    @staticmethod\n    def _cmds_to_elements(drawing_cmds: str) -&gt; list[ShapeElement]:\n        \"\"\"Parses the drawing commands string and updates the internal list of ShapeElement objects.\"\"\"\n        cmds_and_points = drawing_cmds.split()\n        if not cmds_and_points:\n            return []\n\n        elements = []\n        all_commands = {\"m\", \"n\", \"l\", \"p\", \"b\", \"s\", \"c\"}\n\n        i = 0\n        while i &lt; len(cmds_and_points):\n            command = cmds_and_points[i]\n            if command not in all_commands:\n                raise ValueError(f\"Unexpected command '{command}'\")\n\n            i += 1\n            start_args = i\n            while i &lt; len(cmds_and_points) and cmds_and_points[i] not in all_commands:\n                i += 1\n\n            args = cmds_and_points[start_args:i]\n\n            for element in ShapeElement.from_ass_drawing_cmd(command, *args):\n                elements.append(element)\n\n        return elements\n\n    @staticmethod\n    def _elements_to_cmds(elements: list[ShapeElement]) -&gt; str:\n        \"\"\"Create a Shape string from a list of ShapeElement objects.\"\"\"\n        if not elements:\n            return \"m 0 0\"\n\n        parts = []\n        prev_command = None\n\n        for element in elements:\n            if element.command in {\"c\"}:\n                # Commands with no coordinates\n                parts.append(element.command)\n                prev_command = element.command\n            else:\n                # Commands with coordinates\n                coord_strs = []\n                for p in element.coordinates:\n                    coord_strs.extend(\n                        [Shape.format_value(p.x), Shape.format_value(p.y)]\n                    )\n\n                # Check if we can use implicit command (for consecutive \"l\" or \"b\" commands)\n                if (\n                    element.command in {\"l\", \"b\"}\n                    and element.command == prev_command\n                    and coord_strs\n                ):\n                    parts.append(\" \".join(coord_strs))\n                else:\n                    parts.append(f\"{element.command} {' '.join(coord_strs)}\")\n\n                prev_command = element.command\n\n        return \" \".join(parts)\n\n    @staticmethod\n    def format_value(x: float, prec: int = 3) -&gt; str:\n        # Utility function to properly format values for shapes also returning them as a string\n        result = f\"{x:.{prec}f}\".rstrip(\"0\").rstrip(\".\")\n        return \"0\" if result == \"-0\" else result\n\n    def to_multipolygon(self, tolerance: float = 1.0) -&gt; MultiPolygon:\n        \"\"\"Convert the shape to a Shapely MultiPolygon.\n\n        It processes the shape into individual closed loops that are then assembled into polygons with proper shell-hole relationships.\n        It automatically calls [`flatten`][pyonfx.shape.Shape.flatten] to convert curves into straight line segments.\n\n        Args:\n            tolerance: The tolerance angle in degrees used to determine when a bezier curve is considered flat. Higher values yield lower accuracy but faster processing.\n\n        Returns:\n            MultiPolygon: A MultiPolygon where each polygon consists of an outer shell (and optional holes) representing distinct contours of the shape.\n\n        Examples:\n            &gt;&gt;&gt; shape = Shape(\"m 0 0 l 10 0 10 10 l 0 10 c\")\n            &gt;&gt;&gt; mp = shape.to_multipolygon(tolerance=1.0)\n        \"\"\"\n        # Work on a copy to avoid modifying the original shape\n        shape_copy = Shape(self.drawing_cmds)\n\n        # 1. Ensure the outline is fully linear by flattening B\u00e9ziers.\n        shape_copy.flatten(tolerance)\n\n        # 2. Extract individual closed loops (contours).\n        loops: list[list[Point]] = []\n        current_loop: list[Point] = []\n\n        for element in shape_copy:\n            cmd = element.command\n            if cmd == \"m\":\n                if current_loop:\n                    loops.append(current_loop)\n                current_loop = [element.coordinates[0]]\n            elif cmd in {\"l\", \"n\"}:\n                current_loop.append(element.coordinates[0])\n\n        if current_loop:\n            loops.append(current_loop)\n\n        # 3. Convert loops to Shapely polygons (without holes yet).\n        loop_polys: list[Polygon] = []\n        for pts in loops:\n            if len(pts) &lt; 3:\n                # Degenerate loop \u2013 ignore.\n                continue\n            loop_polys.append(Polygon(pts))\n\n        if not loop_polys:\n            return MultiPolygon([])\n\n        # 4. Sort by descending area magnitude so that larger shells are processed first.\n        loop_polys.sort(key=lambda p: abs(p.area), reverse=True)\n\n        shells: list[Polygon] = []\n        holes_map: dict[Polygon, set[Polygon]] = {}\n\n        for loop_poly in loop_polys:\n            # Try to place the loop as a hole inside an existing shell.\n            for shell in shells:\n                if shell.contains(loop_poly):\n                    holes_map[shell].add(loop_poly)\n                    break\n            else:\n                # It's a new outer shell.\n                shells.append(loop_poly)\n                holes_map[loop_poly] = set()\n\n        # 5. Build compound polygons with their holes.\n        compounds: list[Polygon] = []\n        for shell in shells:\n            holes = holes_map[shell]\n            if holes:\n                compound = Polygon(shell.exterior, [h.exterior for h in holes])\n            else:\n                compound = shell\n            compounds.append(compound)\n\n        return MultiPolygon(compounds)\n\n    @classmethod\n    def from_multipolygon(\n        cls, multipolygon: MultiPolygon, min_point_spacing: float = 0.5\n    ) -&gt; \"Shape\":\n        \"\"\"Create a Shape instance from a Shapely MultiPolygon.\n\n        Args:\n            multipolygon: The Shapely MultiPolygon geometry to convert.\n            min_point_spacing: Per-axis spacing threshold - a vertex is kept only if both `|\u0394x|` and `|\u0394y|` from the previous vertex are \u2265 this value (increasing it will boost performance during reproduction, but lower accuracy).\n\n        Returns:\n            Shape: A new Shape instance representing the geometry of the provided MultiPolygon.\n\n        Examples:\n            &gt;&gt;&gt; from shapely.geometry import MultiPolygon, Polygon\n            &gt;&gt;&gt; mp = MultiPolygon([Polygon([(0,0), (10,0), (10,10), (0,10)])])\n            &gt;&gt;&gt; shape = Shape.from_multipolygon(mp, min_point_spacing=0.5)\n\n        See Also:\n            [`to_multipolygon`][pyonfx.shape.Shape.to_multipolygon]\n        \"\"\"\n        if not isinstance(multipolygon, MultiPolygon):\n            raise TypeError(\"Expected a MultiPolygon instance\")\n\n        elements: list[ShapeElement] = []\n\n        def _linear_ring_to_elements(linear_ring: LinearRing, is_hole: bool = False):\n            nonlocal elements\n\n            coords = list(linear_ring.coords)\n            if not coords:\n                return\n\n            # Remove duplicate closing point if present\n            if len(coords) &gt; 1 and coords[0] == coords[-1]:\n                coords.pop()\n\n            # Normalize orientation (outer = CW, inner = CCW)\n            if is_hole and not linear_ring.is_ccw:\n                coords = coords[::-1]\n            elif not is_hole and linear_ring.is_ccw:\n                coords = coords[::-1]\n\n            # Consecutive \"m\" commands are overriden, drop last one\n            if elements and elements[-1].command == \"m\":\n                elements.pop()\n\n            first_point = last_point = coords[0]\n            elements.append(ShapeElement(\"m\", [Point(first_point[0], first_point[1])]))\n            if len(coords) &gt; 1:\n                for x, y in coords[1:]:\n                    if (\n                        abs(last_point[0] - x) &gt;= min_point_spacing\n                        or abs(last_point[1] - y) &gt;= min_point_spacing\n                    ):\n                        elements.append(ShapeElement(\"l\", [Point(x, y)]))\n                        last_point = (x, y)\n\n        for polygon in multipolygon.geoms:\n            if not isinstance(polygon, Polygon) or polygon.is_empty:\n                continue\n            _linear_ring_to_elements(polygon.exterior, is_hole=False)\n            for interior in polygon.interiors:\n                _linear_ring_to_elements(interior, is_hole=True)\n\n        # Ending with \"m\" command is not VSFilter compatible, drop it\n        if elements and elements[-1].command == \"m\":\n            elements.pop()\n\n        return cls(elements=elements)\n\n    def bounding(self, exact: bool = False) -&gt; tuple[float, float, float, float]:\n        \"\"\"Calculate the bounding box of the shape.\n\n        Args:\n            exact: If True, perform an exact calculation by considering curve details; if False, use a faster approximation (libass).\n\n        Returns:\n            tuple[float, float, float, float]: A tuple (x_min, y_min, x_max, y_max) representing the bounding coordinates of the shape.\n\n        Examples:\n            &gt;&gt;&gt; shape = Shape(\"m 10 5 l 25 5 25 42 10 42\")\n            &gt;&gt;&gt; shape.bounding()\n            (10.0, 5.0, 25.0, 42.0)  # left, top, right, bottom\n        \"\"\"\n        all_points = [coord for element in self for coord in element.coordinates]\n\n        if not exact:\n            return MultiPoint(all_points).bounds\n\n        def _cubic_bezier_bounds(\n            p0: Point,\n            p1: Point,\n            p2: Point,\n            p3: Point,\n        ) -&gt; tuple[float, float, float, float]:\n            \"\"\"Axis-aligned bounds of a cubic B\u00e9zier curve.\n\n            Implementation adapted from https://stackoverflow.com/a/14429749\n            taking care of degenerate cases (coincident control points).\n            \"\"\"\n\n            def _axis_bounds(c0, c1, c2, c3):\n                # Solve derivative 3*at^2 + 2*bt + c for roots in (0,1)\n                a = -3 * c0 + 9 * c1 - 9 * c2 + 3 * c3\n                b = 6 * c0 - 12 * c1 + 6 * c2\n                c = 3 * (c1 - c0)\n\n                ts: list[float] = []\n\n                if abs(a) &lt; 1e-12:  # Quadratic (or linear) case\n                    if abs(b) &gt; 1e-12:\n                        t = -c / b\n                        if 0 &lt; t &lt; 1:\n                            ts.append(t)\n                else:  # Cubic case\n                    disc = b * b - 4 * a * c\n                    if disc &gt;= 0:\n                        sqrt_disc = math.sqrt(disc)\n                        for sign in (1, -1):\n                            t = (-b + sign * sqrt_disc) / (2 * a)\n                            if 0 &lt; t &lt; 1:\n                                ts.append(t)\n\n                # extrema candidates are the end-points and the roots above\n                vals = [c0, c3]\n                for t in ts:\n                    mt = 1 - t\n                    vals.append(\n                        mt * mt * mt * c0\n                        + 3 * mt * mt * t * c1\n                        + 3 * mt * t * t * c2\n                        + t * t * t * c3\n                    )\n\n                return min(vals), max(vals)\n\n            xmin, xmax = _axis_bounds(p0.x, p1.x, p2.x, p3.x)\n            ymin, ymax = _axis_bounds(p0.y, p1.y, p2.y, p3.y)\n            return xmin, ymin, xmax, ymax\n\n        x_min, y_min = math.inf, math.inf\n        x_max, y_max = -math.inf, -math.inf\n\n        def _update(pt: Point):\n            nonlocal x_min, y_min, x_max, y_max\n            x_min = min(x_min, pt.x)\n            y_min = min(y_min, pt.y)\n            x_max = max(x_max, pt.x)\n            y_max = max(y_max, pt.y)\n\n        prev_element: ShapeElement | None = None\n\n        for element in self:\n            match element.command:\n                case \"m\" | \"n\":\n                    prev_element = element\n                case \"l\":\n                    if prev_element is not None and prev_element.command in {\"m\", \"n\"}:\n                        _update(prev_element.coordinates[-1])\n                    for c in element.coordinates:\n                        _update(c)\n                    prev_element = element\n                case \"b\":\n                    if prev_element is None:\n                        raise ValueError(\n                            \"Bezier command found without an initial point.\"\n                        )\n                    bx_min, by_min, bx_max, by_max = _cubic_bezier_bounds(\n                        prev_element.coordinates[-1], *element.coordinates\n                    )\n                    _update(Point(bx_min, by_min))\n                    _update(Point(bx_max, by_max))\n                    prev_element = element\n                case \"c\":\n                    pass\n                case _:\n                    raise NotImplementedError(\n                        f\"Drawing command '{element.command}' not handled by bounding().\"\n                    )\n\n        if math.inf in (x_min, y_min) or -math.inf in (x_max, y_max):\n            raise ValueError(\"Invalid or empty shape - could not determine bounds.\")\n\n        return x_min, y_min, x_max, y_max\n\n    def boolean(\n        self,\n        other: \"Shape\",\n        op: Literal[\"union\", \"intersection\", \"difference\", \"xor\"],\n        *,\n        tolerance: float = 1.0,\n        min_point_spacing: float = 0.5,\n    ) -&gt; \"Shape\":\n        \"\"\"Perform a boolean operation between two shapes.\n\n        This method converts both shapes to Shapely MultiPolygon objects (flattening any B\u00e9zier curves with the provided tolerance)\n        and performs the specified boolean operation (union, intersection, difference, or symmetric difference).\n        The result is converted back into a Shape instance.\n\n        Args:\n            other: The other shape to combine with this shape.\n            op: The boolean operation to perform. Use \"union\" for combined area, \"intersection\" for overlapping area, \"difference\" for subtraction, or \"xor\" for symmetric difference.\n            tolerance: The tolerance angle in degrees used for flattening curves. Higher tolerance reduces processing time but lowers accuracy.\n            min_point_spacing: The minimum spacing between consecutive points when converting back from polygons to a shape.\n\n        Returns:\n            Shape: A new Shape instance representing the resulting shape after the boolean operation.\n\n        Examples:\n            &gt;&gt;&gt; shape1 = Shape(\"m 0 0 l 10 0 10 10 0 10\")\n            &gt;&gt;&gt; shape2 = Shape(\"m 5 5 l 15 5 15 15 5 15\")\n            &gt;&gt;&gt; shape1.boolean(shape2, op=\"intersection\", tolerance=1.0, min_point_spacing=0.5)\n            m 10 10 l 10 5 5 5 5 10\n\n        See Also:\n            [`to_multipolygon`][pyonfx.shape.Shape.to_multipolygon]\n            [`from_multipolygon`][pyonfx.shape.Shape.from_multipolygon]\n        \"\"\"\n        if not isinstance(other, Shape):\n            raise TypeError(\"other must be a Shape instance\")\n\n        if op not in {\"union\", \"intersection\", \"difference\", \"xor\"}:\n            raise ValueError(\n                \"op must be one of 'union', 'intersection', 'difference', or 'xor'\"\n            )\n\n        # Convert both shapes to MultiPolygon (this flattens curves).\n        mp_self = self.to_multipolygon(tolerance)\n        mp_other = other.to_multipolygon(tolerance)\n\n        # Perform the requested boolean operation.\n        if op == \"union\":\n            result_geom = mp_self.union(mp_other)\n        elif op == \"intersection\":\n            result_geom = mp_self.intersection(mp_other)\n        elif op == \"difference\":\n            result_geom = mp_self.difference(mp_other)\n        else:  # op == \"xor\"\n            result_geom = mp_self.symmetric_difference(mp_other)\n\n        # Normalise to MultiPolygon\n        if isinstance(result_geom, Polygon):\n            result_geom = MultiPolygon([result_geom])\n        elif not isinstance(result_geom, MultiPolygon):\n            # No overlapping geometry \u2013 return an empty shape.\n            return Shape()\n\n        # Convert back to Shape.\n        return Shape.from_multipolygon(result_geom, min_point_spacing)\n\n    def map(\n        self,\n        fun: (\n            Callable[[float, float], tuple[float, float]]\n            | Callable[[float, float, str], tuple[float, float]]\n        ),\n    ) -&gt; \"Shape\":\n        \"\"\"Sends every point of the shape through a transformation function.\n\n        This method applies a user-provided transformation function to each coordinate of the shape's elements, allowing for arbitrary deformations or adjustments.\n        The function can accept two parameters (x and y) or three parameters (x, y, and the command type), providing flexibility in the transformation logic.\n\n        Args:\n            fun: A function that takes the x and y coordinates (and optionally the drawing command as the third argument) and returns a tuple with the transformed (x, y) coordinates.\n\n        Returns:\n            Shape: A new Shape instance with each point transformed according to the provided function.\n\n        Examples:\n            &gt;&gt;&gt; original = Shape(\"m 0 0 l 20 0 20 10 0 10\")\n            &gt;&gt;&gt; original.map(lambda x, y: (x + 10, y + 5))\n            m 10 5 l 30 5 30 15 10 15\n        \"\"\"\n        if not callable(fun):\n            raise TypeError(\"(Lambda) function expected\")\n\n        # Determine the arity of the transformation function\n        n_params = len(signature(fun).parameters)\n        if n_params not in (2, 3):\n            raise ValueError(\"Function must have 2 or 3 parameters\")\n\n        # Create a wrapper function accepting always 3 parameters\n        if n_params == 3:\n            fun = cast(Callable[[float, float, str], tuple[float, float]], fun)\n            _apply = lambda px, py, cmd: fun(px, py, cmd)\n        else:\n            fun = cast(Callable[[float, float], tuple[float, float]], fun)\n            _apply = lambda px, py, _: fun(px, py)\n\n        # Apply the transformation to each element\n        transformed_elements: list[ShapeElement] = []\n        for element in self:\n            if not element.coordinates:\n                transformed_elements.append(element)\n                continue\n\n            transformed_coords = [\n                Point(*_apply(p.x, p.y, element.command)) for p in element.coordinates\n            ]\n            transformed_elements.append(\n                ShapeElement(element.command, transformed_coords)\n            )\n\n        return Shape(elements=transformed_elements)\n\n    def move(self, x: float, y: float) -&gt; \"Shape\":\n        \"\"\"Move the shape by the specified x and y offsets.\n\n        This method translates every point in the shape by adding the given x and y offsets to the corresponding coordinates.\n\n        Args:\n            x: The displacement along the x-axis.\n            y: The displacement along the y-axis.\n\n        Returns:\n            Shape: A new Shape instance with the coordinates moved by the specified offsets.\n\n        Examples:\n            &gt;&gt;&gt; shape = Shape(\"m 0 0 l 30 0 30 20 0 20\")\n            &gt;&gt;&gt; shape.move(-5, 10)\n            m -5 10 l 25 10 25 30 -5 30\n        \"\"\"\n        if x == 0 and y == 0:\n            return self\n\n        return self.map(lambda cx, cy: (cx + x, cy + y))\n\n    def align(self, an: int = 5, anchor: int | None = None) -&gt; \"Shape\":\n        \"\"\"Align the shape based on a specified alignment code and pivot.\n\n        This method adjusts the shape's position so that a chosen pivot inside the shape\n        coincides with the position used for rendering (i.e., the \\\\pos point in ASS).\n\n        Args:\n            an: The alignment of the subtitle line (e.g., 1 through 9 corresponding to positions such as bottom-left, center, top-right, etc.).\n            anchor: The pivot inside the shape to be used for alignment. If not provided, defaults to the value of 'an'.\n\n        Returns:\n            Shape: A new Shape instance with the shape aligned according to the specified parameters.\n\n        Examples:\n            &gt;&gt;&gt; shape = Shape(\"m 10 10 l 30 10 30 20 10 20\")\n            &gt;&gt;&gt; shape.align()\n            m 0 0 l 20 0 20 10 0 10\n        \"\"\"\n        if anchor is None:\n            anchor = an\n\n        if an &lt; 1 or an &gt; 9:\n            raise ValueError(\"Alignment value must be an integer between 1 and 9\")\n\n        if anchor &lt; 1 or anchor &gt; 9:\n            raise ValueError(\"Anchor value must be an integer between 1 and 9\")\n\n        # Keypad decomposition (0: left / bottom, 1: centre, 2: right / top)\n        pivot_row, pivot_col = divmod(anchor - 1, 3)\n        line_row, line_col = divmod(an - 1, 3)\n\n        # Bounding boxes (exact vs. libass)\n        left, top, right, bottom = self.bounding(exact=True)\n        l_left, l_top, l_right, l_bottom = self.bounding(exact=False)\n\n        width, height = right - left, bottom - top\n\n        x_move = -left\n        y_move = -top\n\n        # Centre according to line alignment (libass corrections included)\n        if line_col == 0:  # left\n            x_move -= width / 2\n        elif line_col == 1:  # centre\n            x_move -= width / 2 - (l_right - l_left) / 2\n        elif line_col == 2:  # right\n            x_move += width / 2 - (width - (l_right - l_left))\n\n        if line_row == 0:  # bottom\n            y_move += height / 2 - (height - (l_bottom - l_top))\n        elif line_row == 1:  # middle\n            y_move -= height / 2 - (l_bottom - l_top) / 2\n        elif line_row == 2:  # top\n            y_move -= height / 2\n\n        # Finally shift so that requested pivot is the reference point\n        if pivot_col == 0:  # left\n            x_move += width / 2\n        elif pivot_col == 2:  # right\n            x_move -= width / 2\n\n        if pivot_row == 0:  # bottom\n            y_move -= height / 2\n        elif pivot_row == 2:  # top\n            y_move += height / 2\n\n        return self.move(x_move, y_move)\n\n    def scale(\n        self,\n        fscx: float = 100,\n        fscy: float = 100,\n        origin: tuple[float, float] = (0.0, 0.0),\n    ) -&gt; \"Shape\":\n        \"\"\"Scale the shape by specified horizontal and vertical scale factors, optionally around a given origin.\n\n        This method scales the shape's coordinates relative to a specified origin point, which serves as the pivot for the scaling transformation.\n\n        Args:\n            fscx: The horizontal scaling factor as a percentage (100 means no change).\n            fscy: The vertical scaling factor as a percentage (100 means no change).\n            origin: The pivot point (x, y) around which scaling is performed. Default is (0.0, 0.0).\n\n        Returns:\n            Shape: A new Shape instance with the coordinates scaled accordingly.\n\n        Examples:\n            &gt;&gt;&gt; shape = Shape(\"m 0 50 l 0 0 50 0 50 50\")\n            &gt;&gt;&gt; shape.scale(fscx=200)\n            m 0 50 l 0 0 100 0 100 50\n        \"\"\"\n        if fscx == 100.0 and fscy == 100.0:\n            return self\n\n        scale_x = fscx / 100.0\n        scale_y = fscy / 100.0\n\n        ox, oy = origin\n\n        return self.map(lambda x, y: ((x - ox) * scale_x + ox, (y - oy) * scale_y + oy))\n\n    def rotate(\n        self,\n        *,\n        frx: float = 0.0,\n        fry: float = 0.0,\n        frz: float = 0.0,\n        origin: tuple[float, float] = (0.0, 0.0),\n    ) -&gt; \"Shape\":\n        \"\"\"Rotate the shape by specified angles about given axes around a pivot point.\n\n        This method applies rotation transformations to the shape's coordinates based on the provided angles for the x, y, and z axes, in degrees.\n        The pivot point around which the rotation is applied is specified by the 'origin' parameter.\n\n        Args:\n            frx: The rotation angle around the x-axis (in degrees).\n            fry: The rotation angle around the y-axis (in degrees).\n            frz: The rotation angle around the z-axis (in degrees).\n            origin: The pivot point (x, y) for the rotation.\n\n        Returns:\n            Shape: A new Shape instance with the coordinates rotated as specified.\n\n        Examples:\n            &gt;&gt;&gt; shape = Shape(\"m 0 0 l 30 0 30 20 0 20\")\n            &gt;&gt;&gt; shape.rotate(frx=0, fry=0, frz=45, origin=(15,10))\n            m -2.678 13.536 l 18.536 -7.678 32.678 6.464 11.464 27.678\n\n        Notes:\n            The rotation is applied in the order: X-axis, then Y-axis, then Z-axis.\n        \"\"\"\n        if frx == 0 and fry == 0 and frz == 0:\n            return self\n\n        # Normalise the origin\n        ox, oy = origin\n\n        # Pre-compute sines/cosines\n        # (Mathematical convention is counter-clockwise, but ASS uses clockwise, *sigh*)\n        rx = math.radians(-frx)\n        ry = math.radians(-fry)\n        rz = math.radians(-frz)\n        cosx, sinx = math.cos(rx), math.sin(rx)\n        cosy, siny = math.cos(ry), math.sin(ry)\n        cosz, sinz = math.cos(rz), math.sin(rz)\n\n        def _transform(px: float, py: float) -&gt; tuple[float, float]:\n            # Translate to origin\n            x = px - ox\n            y = py - oy\n            z = 0.0\n\n            # Rotation around X (pitch)\n            y1 = y * cosx - z * sinx\n            z1 = y * sinx + z * cosx\n            x1 = x\n\n            # Rotation around Y (yaw)\n            x2 = x1 * cosy + z1 * siny\n            z2 = -x1 * siny + z1 * cosy\n            y2 = y1\n\n            # Rotation around Z (roll)\n            x3 = x2 * cosz - y2 * sinz\n            y3 = x2 * sinz + y2 * cosz\n            z3 = z2\n\n            # Translate back\n            return x3 + ox, y3 + oy\n\n        # Apply transformation to every point in the shape\n        return self.map(lambda x, y: _transform(x, y))\n\n    def shear(\n        self,\n        *,\n        fax: float = 0.0,\n        fay: float = 0.0,\n        origin: tuple[float, float] = (0.0, 0.0),\n    ) -&gt; \"Shape\":\n        \"\"\"Apply a shear transformation to the shape.\n\n        This method deforms the shape by applying a shear transformation relative to a specified origin, which acts as the pivot.\n\n        Args:\n            fax: The horizontal shear factor. Positive values slant the top of the shape to the right, negative values slant to the left.\n            fay: The vertical shear factor. Positive values slant the right side of the shape downward, negative values slant upward.\n            origin: The pivot point (x, y) for the shear transformation.\n\n        Returns:\n            Shape: A new Shape instance with the coordinates sheared accordingly.\n\n        Examples:\n            &gt;&gt;&gt; shape = Shape(\"m 0 0 l 30 0 30 20 0 20\")\n            &gt;&gt;&gt; shape.shear(fax=0.5, fay=0, origin=(15,10))\n            m -5 0 l 25 0 35 20 5 20\n        \"\"\"\n        if fax == 0.0 and fay == 0.0:\n            return self\n\n        ox, oy = origin\n\n        def _shear(px: float, py: float) -&gt; tuple[float, float]:\n            # Translate to origin\n            x_rel = px - ox\n            y_rel = py - oy\n\n            # Apply shear matrix [[1, fax], [fay, 1]]\n            new_x_rel = x_rel + fax * y_rel\n            new_y_rel = fay * x_rel + y_rel\n\n            # Translate back\n            return new_x_rel + ox, new_y_rel + oy\n\n        return self.map(lambda x, y: _shear(x, y))\n\n    def flatten(self, tolerance: float = 1.0) -&gt; \"Shape\":\n        \"\"\"Flatten the shape's B\u00e9zier curves into line segments.\n\n        This method processes the shape by subdividing B\u00e9zier curves into multiple straight line segments.\n        The subdivision is controlled by the tolerance parameter, which defines the threshold angle (in degrees) at which a curve is considered flat.\n        This conversion is useful for operations that require linear segments, such as detailed transformations or morphing.\n\n        Args:\n            tolerance: The angle in degrees used to determine when a B\u00e9zier curve is flat enough to be approximated by a straight line. Higher values yield fewer segments and faster processing but lower accuracy.\n\n        Returns:\n            Shape: A new Shape instance with the curves converted into line segments.\n\n        Notes:\n            Flattening curves may significantly increase the number of points, which can impact performance for subsequent operations.\n        \"\"\"\n        if tolerance &lt; 0:\n            raise ValueError(\"Tolerance must be a positive number\")\n\n        # Convert tolerance to radians once to avoid repeated conversions\n        tolerance_rad = math.radians(tolerance)\n\n        def _subdivide_bezier(p0x, p0y, p1x, p1y, p2x, p2y, p3x, p3y, t=0.5):\n            \"\"\"De Casteljau subdivision of cubic bezier curve using raw coordinates.\"\"\"\n            # First level\n            q0x = p0x + t * (p1x - p0x)\n            q0y = p0y + t * (p1y - p0y)\n            q1x = p1x + t * (p2x - p1x)\n            q1y = p1y + t * (p2y - p1y)\n            q2x = p2x + t * (p3x - p2x)\n            q2y = p2y + t * (p3y - p2y)\n\n            # Second level\n            r0x = q0x + t * (q1x - q0x)\n            r0y = q0y + t * (q1y - q0y)\n            r1x = q1x + t * (q2x - q1x)\n            r1y = q1y + t * (q2y - q1y)\n\n            # Final point\n            sx = r0x + t * (r1x - r0x)\n            sy = r0y + t * (r1y - r0y)\n\n            return (\n                (p0x, p0y, q0x, q0y, r0x, r0y, sx, sy),\n                (sx, sy, r1x, r1y, q2x, q2y, p3x, p3y),\n            )\n\n        def _is_bezier_flat(p0x, p0y, p1x, p1y, p2x, p2y, p3x, p3y):\n            \"\"\"Check if bezier curve is flat enough based on angle tolerance.\"\"\"\n            points = [(p0x, p0y), (p1x, p1y), (p2x, p2y), (p3x, p3y)]\n\n            vectors = []\n            for i in range(1, len(points)):\n                dx = points[i][0] - points[i - 1][0]\n                dy = points[i][1] - points[i - 1][1]\n                if dx != 0 or dy != 0:\n                    vectors.append((dx, dy))\n\n            if len(vectors) &lt; 2:\n                return True\n\n            # Check angle between consecutive vectors\n            for i in range(1, len(vectors)):\n                v1, v2 = vectors[i - 1], vectors[i]\n\n                angle = math.atan2(\n                    v1[0] * v2[1] - v1[1] * v2[0], v1[0] * v2[0] + v1[1] * v2[1]\n                )\n\n                if abs(angle) &gt; tolerance_rad:\n                    return False\n\n            return True\n\n        def _bezier_to_lines(p0, p1, p2, p3):\n            \"\"\"Convert bezier curve to line segments.\"\"\"\n            stack = [(p0.x, p0.y, p1.x, p1.y, p2.x, p2.y, p3.x, p3.y)]\n\n            line_points = []\n            while stack:\n                coords = stack.pop()\n\n                if _is_bezier_flat(*coords):\n                    # End point\n                    line_points.append(Point(coords[6], coords[7]))\n                else:\n                    # Subdivide and add both halves to stack\n                    left, right = _subdivide_bezier(*coords)\n                    stack.append(right)  # Process right first (stack order)\n                    stack.append(left)\n\n            return (\n                line_points[:-1] if line_points else []\n            )  # Exclude last to avoid duplication\n\n        # Process elements\n        flattened_elements = []\n        current_point = None\n\n        for element in self:\n            if element.command == \"b\":\n                if current_point is None:\n                    raise ValueError(\"Bezier curve found without a starting point\")\n\n                # Convert bezier to line segments\n                p0 = current_point\n                p1, p2, p3 = element.coordinates\n\n                line_points = _bezier_to_lines(p0, p1, p2, p3)\n\n                # Add line segments\n                for point in line_points:\n                    flattened_elements.append(ShapeElement(\"l\", [point]))\n\n                # Add final point\n                flattened_elements.append(ShapeElement(\"l\", [p3]))\n                current_point = p3\n\n            elif element.command == \"c\":\n                # Bezier curves are already converted to lines\n                pass\n\n            else:\n                # Keep other commands as-is and track current point\n                flattened_elements.append(element)\n                if element.coordinates:\n                    current_point = element.coordinates[-1]\n\n        # Return shape with flattened elements\n        return Shape(elements=flattened_elements)\n\n    def split(self, max_len: float = 16, tolerance: float = 1.0) -&gt; \"Shape\":\n        \"\"\"Split the shape into smaller segments.\n\n        This method first flattens any B\u00e9zier curves in the shape, then subdivides the resulting line segments so that no segment exceeds the specified maximum length.\n        This process increases the number of points in the shape, which can be useful for detailed deformations or morphing.\n\n        Args:\n            max_len: The maximum allowed length for any line segment. Segments longer than this value will be subdivided.\n            tolerance: The tolerance angle in degrees used to flatten B\u00e9zier curves before splitting.\n\n        Returns:\n            Shape: A new Shape instance with the split line segments.\n\n        Examples:\n            &gt;&gt;&gt; shape = Shape(\"m 0 50 l 0 0 50 0 50 50\")\n            &gt;&gt;&gt; shape.split()\n            m 0 50 l 0 48 0 32 0 16 0 0 2 0 18 0 34 0 50 0 50 2 50 18 50 34 50 50 48 50 32 50 16 50 0 50\n        \"\"\"\n        if max_len &lt;= 0:\n            raise ValueError(\n                \"The length of segments must be a positive and non-zero value\"\n            )\n\n        def _split_line_segment(p1: Point, p2: Point) -&gt; list[Point]:\n            \"\"\"Split a line segment *p1\u2192p2* into shorter segments of length ``&lt;= max_len``\"\"\"\n            line = LineString([p1, p2])\n            distance = line.length\n\n            # If already short enough, just return the end point\n            if distance &lt;= max_len:\n                return [Point(p2.x, p2.y)]\n\n            # Split the line into segments of max_len, with possibly shorter first segment\n            segments: list[Point] = []\n            distance_rest = distance % max_len\n            cur_distance = distance_rest if distance_rest &gt; 0 else max_len\n\n            while cur_distance &lt;= distance:\n                point = line.interpolate(cur_distance)\n                segments.append(Point(point.x, point.y))\n                cur_distance += max_len\n\n            return segments\n\n        def _close_contour_if_needed(current_pt, first_move_pt):\n            \"\"\"Helper to close a contour by splitting the closing line if needed.\"\"\"\n            if current_pt is None or first_move_pt is None:\n                return []\n\n            if (current_pt.x, current_pt.y) == (first_move_pt.x, first_move_pt.y):\n                return []\n\n            closing_points = _split_line_segment(current_pt, first_move_pt)\n            return [ShapeElement(\"l\", [pt]) for pt in closing_points]\n\n        # First flatten the shape to convert bezier curves to lines\n        flattened_shape = Shape(self.drawing_cmds).flatten(tolerance)\n\n        # Process elements\n        split_elements = []\n        current_point = None\n        first_move_point = None\n\n        for element in flattened_shape:\n            if element.command == \"m\":\n                # Close previous contour if needed\n                split_elements.extend(\n                    _close_contour_if_needed(current_point, first_move_point)\n                )\n\n                # Start new contour\n                split_elements.append(element)\n                current_point = element.coordinates[0]\n                first_move_point = current_point\n\n            elif element.command == \"l\":\n                if current_point is None:\n                    raise ValueError(\"Line command found without a starting point\")\n\n                # Split the line segment\n                line_points = _split_line_segment(current_point, element.coordinates[0])\n\n                # Add each segment as a separate line element\n                for point in line_points:\n                    split_elements.append(ShapeElement(\"l\", [point]))\n\n                # Update current point\n                current_point = (\n                    line_points[-1] if line_points else element.coordinates[0]\n                )\n\n            elif element.command == \"c\":\n                # Close current contour\n                split_elements.extend(\n                    _close_contour_if_needed(current_point, first_move_point)\n                )\n\n                # Reset state for next contour\n                current_point = None\n                first_move_point = None\n\n            else:\n                split_elements.append(element)\n                if element.coordinates:\n                    current_point = element.coordinates[-1]\n\n        # Close the final contour if needed\n        split_elements.extend(_close_contour_if_needed(current_point, first_move_point))\n\n        # Update shape with split elements\n        return Shape(elements=split_elements)\n\n    def buffer(\n        self,\n        dist_xy: float,\n        dist_y: float | None = None,\n        *,\n        kind: Literal[\"fill\", \"border\"] = \"border\",\n        join: Literal[\"round\", \"bevel\", \"mitre\"] = \"round\",\n    ) -&gt; \"Shape\":\n        \"\"\"Return a buffered version of the shape.\n\n        It makes a thicker or thinner version of the original shape by adding or removing space around it, based on the distances you specify.\n        The \"kind\" option decides if you get the whole new shape filled in or just the edge line.\n\n        Args:\n            dist_xy: Horizontal buffer distance. Positive values expand the shape, and negative values contract it.\n            dist_y: Vertical buffer distance. If None, the same value as dist_xy is used. The sign must match that of dist_xy.\n            kind: Determines whether to return the filled buffered geometry (\"fill\") or just the border (\"border\").\n            join: The corner join style to use on buffered corners.\n\n        Returns:\n            Shape: A new Shape instance representing the buffered shape.\n\n        Examples:\n            &gt;&gt;&gt; shape = Shape(\"m 0 0 l 100 0 100 50 0 50\")\n            &gt;&gt;&gt; shape.buffer(5, kind=\"border\", join=\"round\")\n            m -3.333 50 l -3.269 50.65 (...)\n        \"\"\"\n        if join not in (\"round\", \"bevel\", \"mitre\"):\n            raise ValueError(\"join must be one of 'round', 'bevel', or 'mitre'\")\n        if kind not in (\"fill\", \"border\"):\n            raise ValueError(\"kind must be either 'fill' or 'border'\")\n        if dist_y is None:\n            dist_y = dist_xy\n        if dist_xy == 0 and dist_y == 0:\n            return Shape() if kind == \"border\" else self\n\n        # Validate signs: both distances must have the same sign (or be zero)\n        if dist_xy * dist_y &lt; 0:\n            raise ValueError(\"dist_xy and dist_y must have the same sign\")\n        sign = 1 if dist_xy &gt;= 0 else -1\n\n        # Build Shapely geometry\n        multipoly = self.to_multipolygon()\n\n        # Apply libass hack\n        _LIBASS_HACK = 2 / 3\n        dist_xy *= _LIBASS_HACK\n        dist_y *= _LIBASS_HACK\n\n        # Anisotropic scaling so that the buffer distance is uniform\n        width = max(abs(dist_xy), abs(dist_y))\n\n        _EPS = 1e-9  # Avoid division-by-zero\n        xscale = abs(dist_xy) / width if abs(dist_xy) &gt; 0 else _EPS\n        yscale = abs(dist_y) / width if abs(dist_y) &gt; 0 else _EPS\n\n        inv_xscale = 1.0 / xscale\n        inv_yscale = 1.0 / yscale\n        scaled_geom = affine_scale(\n            multipoly, xfact=inv_xscale, yfact=inv_yscale, origin=(0, 0)\n        )\n\n        # Apply buffer (positive \u21d2 outward, negative \u21d2 inward)\n        buffered_scaled = scaled_geom.buffer(\n            sign * width, join_style=getattr(JOIN_STYLE, join)\n        )\n\n        if kind == \"fill\":\n            # Grown/shrunk geometry\n            result_scaled = buffered_scaled\n        else:\n            if sign &gt; 0:\n                # External border: grow and subtract original\n                result_scaled = buffered_scaled.difference(scaled_geom)\n            else:\n                # Internal border: shrink original and subtract new interior\n                result_scaled = scaled_geom.difference(buffered_scaled)\n\n        # Scale back to the original coordinate system\n        result_geom = affine_scale(\n            result_scaled, xfact=xscale, yfact=yscale, origin=(0, 0)\n        )\n\n        # Craft MultiPolygon\n        if isinstance(result_geom, MultiPolygon):\n            mp = result_geom\n        elif isinstance(result_geom, Polygon):\n            mp = MultiPolygon([result_geom])\n        else:\n            raise ValueError(f\"Invalid stroke geometry type: {type(result_geom)}\")\n\n        # Convert back to Shape\n        return Shape.from_multipolygon(mp)\n\n    @functools.lru_cache(maxsize=1024)\n    @staticmethod\n    def _prepare_morph(\n        source_ids_and_cmds: tuple[tuple[str, str], ...],\n        target_ids_and_cmds: tuple[tuple[str, str], ...],\n        max_len: float,\n        tolerance: float,\n        w_dist: float,\n        w_area: float,\n        w_overlap: float,\n        cost_threshold: float,\n        ensure_shell_pairs: bool = False,\n    ) -&gt; tuple[\n        list[tuple[LinearRing, LinearRing, bool, str, str]],\n        list[tuple[LinearRing, Point, bool, str]],\n        list[tuple[LinearRing, Point, bool, str]],\n    ]:\n        \"\"\"Prepare the morphing process by decomposing the shapes into compounds and pairing them.\n\n        Returns:\n            A tuple containing:\n            - A list of (src, tgt, is_hole, src_id, tgt_id) ring pairs.\n            - A list of (src, ref, is_hole, src_id) unmatched source rings.\n            - A list of (tgt, ref, is_hole, tgt_id) unmatched target rings.\n        \"\"\"\n\n        def _pair_rings(\n            source_rings_meta: list[tuple[Polygon, bool, str]],\n            target_rings_meta: list[tuple[Polygon, bool, str]],\n            w_dist: float,\n            w_area: float,\n            w_overlap: float,\n            cost_threshold: float,\n            ensure_shell_pairs: bool,\n        ) -&gt; tuple[\n            list[tuple[LinearRing, LinearRing, bool, str, str]],\n            list[tuple[LinearRing, Point, bool, str]],\n            list[tuple[LinearRing, Point, bool, str]],\n        ]:\n            \"\"\"\n            Pair source and target polygon rings (exteriors and interiors) based on centroid distance,\n            area similarity, and overlap, avoiding shell-hole mismatches.\n\n            Any ring left without a counterpart is matched to the closest centroid so that downstream\n            morphing logic can decide whether it is *appearing* or *disappearing*.\n            \"\"\"\n            matched: list[tuple[LinearRing, LinearRing, bool, str, str]] = []\n            unmatched_src: list[tuple[LinearRing, Point, bool, str]] = []\n            unmatched_tgt: list[tuple[LinearRing, Point, bool, str]] = []\n\n            # Global centroid arrays (used for nearest-neighbour fallback)\n            all_src_centroids = np.array(\n                [poly.centroid.coords[0] for poly, _, _ in source_rings_meta]\n            )\n            all_tgt_centroids = np.array(\n                [poly.centroid.coords[0] for poly, _, _ in target_rings_meta]\n            )\n\n            # Match separately for shells (False) and holes (True)\n            for is_hole in (False, True):\n                cur_src = [\n                    (poly, sid)\n                    for poly, hole, sid in source_rings_meta\n                    if hole == is_hole\n                ]\n                cur_tgt = [\n                    (poly, sid)\n                    for poly, hole, sid in target_rings_meta\n                    if hole == is_hole\n                ]\n                n_src, n_tgt = len(cur_src), len(cur_tgt)\n\n                if n_src == 0 and n_tgt == 0:\n                    continue\n                if n_src == 0:\n                    for poly, did in cur_tgt:\n                        ref = (\n                            Point(all_src_centroids[0])\n                            if all_src_centroids.size\n                            else poly.centroid\n                        )\n                        unmatched_tgt.append((poly.exterior, ref, is_hole, did))\n                    continue\n                if n_tgt == 0:\n                    for poly, sid in cur_src:\n                        ref = (\n                            Point(all_tgt_centroids[0])\n                            if all_tgt_centroids.size\n                            else poly.centroid\n                        )\n                        unmatched_src.append((poly.exterior, ref, is_hole, sid))\n                    continue\n\n                src_areas = np.array([p.area for p, _ in cur_src])\n                tgt_areas = np.array([p.area for p, _ in cur_tgt])\n                src_centroids = np.array([p.centroid.coords[0] for p, _ in cur_src])\n                tgt_centroids = np.array([p.centroid.coords[0] for p, _ in cur_tgt])\n\n                # 1) Centroid distance (normalised)\n                diff = src_centroids[:, None, :] - tgt_centroids[None, :, :]\n                dist = np.linalg.norm(diff, axis=2)\n                size_norm = np.sqrt(np.maximum(src_areas[:, None], tgt_areas[None, :]))\n                centroid_term = dist / (size_norm + 1e-8)\n\n                # 2) Relative area difference\n                area_term = np.abs(src_areas[:, None] - tgt_areas[None, :]) / (\n                    np.maximum(src_areas[:, None], tgt_areas[None, :]) + 1e-8\n                )\n\n                costs = w_dist * centroid_term + w_area * area_term\n\n                # 3) Add overlap term for top 8 promising pairs only\n                k = min(8, n_tgt)\n                candidate_cols = np.argpartition(costs, kth=k - 1, axis=1)[:, :k]\n\n                for i, cols in enumerate(candidate_cols):\n                    poly_i = cur_src[i][0]\n                    area_i = src_areas[i]\n                    for j in cols:\n                        poly_j = cur_tgt[j][0]\n                        inter_area = 0.0\n                        if poly_i.intersects(poly_j):\n                            inter_area = poly_i.intersection(poly_j).area\n                        min_area = min(area_i, tgt_areas[j])\n                        if min_area:\n                            iou_term = 1.0 - (inter_area / min_area)\n                            costs[i, j] += w_overlap * iou_term\n\n                # 4) Solve assignment (Hungarian algorithm)\n                row_ind, col_ind = linear_sum_assignment(costs)\n\n                used_src: set[int] = set()\n                used_tgt: set[int] = set()\n\n                for i, j in zip(row_ind, col_ind):\n                    if cost_threshold is None or costs[i, j] &lt;= cost_threshold:\n                        matched.append(\n                            (\n                                cur_src[i][0].exterior,\n                                cur_tgt[j][0].exterior,\n                                is_hole,\n                                cur_src[i][1],\n                                cur_tgt[j][1],\n                            )\n                        )\n                        used_src.add(i)\n                        used_tgt.add(j)\n\n                # 5) Handle still-unmatched rings.\n                unmatched_src_idx = set(range(n_src)) - used_src\n                unmatched_tgt_idx = set(range(n_tgt)) - used_tgt\n\n                # Optionally force-pair shells so that they always morph into something.\n                if ensure_shell_pairs and not is_hole and n_src &gt; 0 and n_tgt &gt; 0:\n                    # Pair every remaining source shell with its minimum-cost target shell\n                    for i in unmatched_src_idx:\n                        j = int(np.argmin(costs[i]))\n                        matched.append(\n                            (\n                                cur_src[i][0].exterior,\n                                cur_tgt[j][0].exterior,\n                                is_hole,\n                                cur_src[i][1],\n                                cur_tgt[j][1],\n                            )\n                        )\n                        used_src.add(i)\n                    for j in unmatched_tgt_idx:\n                        i = int(np.argmin(costs[:, j]))\n                        matched.append(\n                            (\n                                cur_src[i][0].exterior,\n                                cur_tgt[j][0].exterior,\n                                is_hole,\n                                cur_src[i][1],\n                                cur_tgt[j][1],\n                            )\n                        )\n                        used_tgt.add(j)\n\n                # Any ring still left unmatched will be matched to the closest centroid.\n                un_src_idx = set(range(n_src)) - used_src\n                un_tgt_idx = set(range(n_tgt)) - used_tgt\n\n                for idx in un_src_idx:\n                    poly, source_id = cur_src[idx]\n                    src_cent = src_centroids[idx]\n                    nn = np.argmin(np.linalg.norm(all_tgt_centroids - src_cent, axis=1))\n                    unmatched_src.append(\n                        (\n                            poly.exterior,\n                            Point(all_tgt_centroids[nn]),\n                            is_hole,\n                            source_id,\n                        )\n                    )\n                for idx in un_tgt_idx:\n                    poly, target_id = cur_tgt[idx]\n                    tgt_cent = tgt_centroids[idx]\n                    nn = np.argmin(np.linalg.norm(all_src_centroids - tgt_cent, axis=1))\n                    unmatched_tgt.append(\n                        (\n                            poly.exterior,\n                            Point(all_src_centroids[nn]),\n                            is_hole,\n                            target_id,\n                        )\n                    )\n\n            return matched, unmatched_src, unmatched_tgt\n\n        def _resample_loop(loop: LinearRing, n_points: int) -&gt; LinearRing:\n            \"\"\"Return *loop* resampled to *n_points* evenly spaced vertices along its perimeter, while preserving all the original loop points if *preserve_original_points* is True.\"\"\"\n\n            if n_points &lt; 3:\n                raise ValueError(\"n_points must be at least 3 for a valid LinearRing.\")\n\n            # Ensure the loop is closed and get coordinates\n            coords = np.asarray(loop.coords)\n            if not np.allclose(coords[0], coords[-1]):\n                raise ValueError(\"Input LinearRing must be closed.\")\n            coords = coords[:-1]  # remove duplicate endpoint\n\n            if n_points &lt; len(coords):\n                raise ValueError(\n                    \"n_points must be &gt;= number of original vertices when preserve_original_points=True.\"\n                )\n            if n_points == len(coords):\n                return loop\n\n            extra = n_points - len(coords)\n\n            # Compute segment lengths and cumulative lengths\n            deltas = np.diff(coords, axis=0, append=[coords[0]])\n            segment_lengths = np.linalg.norm(deltas, axis=1)\n            total_length = segment_lengths.sum()\n\n            # Ideal (floating point) allocation of extra vertices per segment\n            ideal_alloc = segment_lengths / total_length * extra\n\n            # Initial integer allocation (floor) and compute how many vertices are still unassigned\n            int_alloc = np.floor(ideal_alloc).astype(int)\n            allocated = int_alloc.sum()\n            remaining = extra - allocated\n\n            # Distribute the remaining vertices to the segments with the largest fractional parts\n            if remaining &gt; 0:\n                frac_parts = ideal_alloc - int_alloc\n                # Indices of segments sorted by descending fractional part\n                order = np.argsort(-frac_parts)\n                for idx in order[:remaining]:\n                    int_alloc[idx] += 1\n\n            # Build the new coordinate list\n            new_coords = []\n            for i, start_pt in enumerate(coords):\n                end_pt = coords[(i + 1) % len(coords)]\n                new_coords.append(tuple(start_pt))  # always keep the original vertex\n                k = int_alloc[i]\n                if k == 0:\n                    continue\n                # Insert *k* equally spaced points *strictly inside* the segment\n                for j in range(1, k + 1):\n                    ratio = j / (k + 1)\n                    interp_pt = start_pt + ratio * (end_pt - start_pt)\n                    new_coords.append(tuple(interp_pt))\n\n            new_coords.append(new_coords[0])  # close the ring\n            return LinearRing(new_coords)\n\n        # --- Execute the pipeline ---\n        # 1) Flatten and split each shape into short lines to have more points to work with,\n        #    then convert to polygons and extract rings.\n        source_rings_meta: list[tuple[Polygon, bool, str]] = []\n        target_rings_meta: list[tuple[Polygon, bool, str]] = []\n\n        for source_id, source_cmds in source_ids_and_cmds:\n            shape_mp = Shape(source_cmds).split(max_len, tolerance).to_multipolygon()\n            for poly in shape_mp.geoms:\n                source_rings_meta.append((Polygon(poly.exterior), False, source_id))\n                source_rings_meta.extend(\n                    (Polygon(inter), True, source_id) for inter in poly.interiors\n                )\n\n        for target_id, target_cmds in target_ids_and_cmds:\n            shape_mp = Shape(target_cmds).split(max_len, tolerance).to_multipolygon()\n            for poly in shape_mp.geoms:\n                target_rings_meta.append((Polygon(poly.exterior), False, target_id))\n                target_rings_meta.extend(\n                    (Polygon(inter), True, target_id) for inter in poly.interiors\n                )\n\n        # 2) Pair individual rings extracted from those compounds\n        matched, unmatched_src, unmatched_tgt = _pair_rings(\n            source_rings_meta,\n            target_rings_meta,\n            w_dist,\n            w_area,\n            w_overlap,\n            cost_threshold,\n            ensure_shell_pairs,\n        )\n\n        # 3) Resample each paired ring so that both have the same vertex count\n        resampled: list[tuple[LinearRing, LinearRing, bool, str, str]] = []\n        for src_r, tgt_r, is_hole, source_id, target_id in matched:\n            n_src = len(src_r.coords) - 1\n            n_tgt = len(tgt_r.coords) - 1\n            n_pts = max(n_src, n_tgt, 4)\n            resampled.append(\n                (\n                    _resample_loop(src_r, n_pts),\n                    _resample_loop(tgt_r, n_pts),\n                    is_hole,\n                    source_id,\n                    target_id,\n                )\n            )\n\n        return resampled, unmatched_src, unmatched_tgt\n\n    def morph(\n        self,\n        target: \"Shape\",\n        t: float,\n        max_len: float = 16.0,\n        tolerance: float = 1.0,\n        min_point_spacing: float = 0.5,\n        w_dist: float = 0.55,\n        w_area: float = 0.35,\n        w_overlap: float = 0.1,\n        cost_threshold: float = 2.5,\n        ensure_shell_pairs: bool = True,\n    ) -&gt; \"Shape\":\n        \"\"\"Interpolate the current shape toward a target shape.\n\n        This method computes an intermediate shape by morphing the current shape into a target shape based on an interpolation factor t (where 0 corresponds to the source shape and 1 corresponds to the target shape).\n        The morph is performed by decomposing both shapes into closed ring segments and matching corresponding rings based on spatial properties. Matched rings are linearly interpolated, and unmatched rings are processed to appear or disappear gradually.\n\n        Args:\n            target: The target shape to morph into.\n            t: Interpolation factor between 0 and 1, where 0 returns the original shape and 1 returns the target shape.\n            max_len: The maximum allowed length for any line segment when splitting curves before morphing.\n            tolerance: The tolerance angle in degrees used when flattening curves.\n            min_point_spacing: Per-axis spacing threshold - a vertex is kept only if both `|\u0394x|` and `|\u0394y|` from the previous vertex are \u2265 this value (increasing it will boost performance during reproduction, but lower accuracy).\n            w_dist: Weight for the centroid-distance term (higher values make proximity more important).\n            w_area: Weight for the relative area-difference term (higher values make size similarity more important).\n            w_overlap: Weight for the overlap / IoU term that penalises pairs with little spatial intersection.\n            cost_threshold: Maximum acceptable cost for a pairing. Pairs whose cost is above this threshold are treated as unmatched and will grow/shrink to the closest centroid.\n            ensure_shell_pairs: If `True`, shell rings that would otherwise remain unmatched will be force-paired with the shell that yields the minimum cost. This guarantees that every visible contour morphs into something, at the price of allowing the same shell to be reused multiple times.\n\n        Returns:\n            Shape: A new Shape instance representing the intermediate morph state.\n\n        Examples:\n            &gt;&gt;&gt; source = Shape(\"m 0 0 l 100 0 100 100 0 100 c\")\n            &gt;&gt;&gt; target = Shape(\"m 50 50 l 150 50 150 150 50 150 c\")\n            &gt;&gt;&gt; morph = source.morph(target, t=0.5)\n        \"\"\"\n\n        # Fast-path validations\n        if not isinstance(target, Shape):\n            raise TypeError(\"Target must be a Shape instance\")\n        if not 0 &lt;= t &lt;= 1:\n            raise ValueError(\"t must be between 0 and 1\")\n        if t == 0:\n            return self\n        if t == 1:\n            return target\n\n        # Use the multi-shape morphing routine to get intermediate geometries.\n        morphs = Shape.morph_multi(\n            {\"_\": self},\n            {\"_\": target},\n            t,\n            max_len=max_len,\n            tolerance=tolerance,\n            min_point_spacing=min_point_spacing,\n            w_dist=w_dist,\n            w_area=w_area,\n            w_overlap=w_overlap,\n            cost_threshold=cost_threshold,\n            ensure_shell_pairs=ensure_shell_pairs,\n        )\n\n        shapes = list(morphs.values())\n        combined_shape = shapes[0]\n        for shape in shapes[1:]:\n            combined_shape = combined_shape.boolean(\n                shape,\n                op=\"union\",\n                tolerance=tolerance,\n                min_point_spacing=min_point_spacing,\n            )\n\n        return combined_shape\n\n    @staticmethod\n    def morph_multi(\n        src_shapes: dict[str, \"Shape\"],\n        tgt_shapes: dict[str, \"Shape\"],\n        t: float,\n        *,\n        max_len: float = 16.0,\n        tolerance: float = 1.0,\n        min_point_spacing: float = 0.5,\n        w_dist: float = 0.55,\n        w_area: float = 0.35,\n        w_overlap: float = 0.1,\n        cost_threshold: float = 2.5,\n        ensure_shell_pairs: bool = True,\n    ) -&gt; dict[tuple[str | None, str | None], \"Shape\"]:\n        \"\"\"Interpolate multiple shapes simultaneously.\n\n        This class method performs a multi-shape morphing operation by interpolating between collections of source and target shapes.\n        It decomposes each shape into rings, matches corresponding rings across the source and target collections based on spatial relationships, and computes intermediate shapes at a given interpolation factor t.\n        The output is a dictionary mapping source-target identifier tuples to the resulting interpolated Shape.\n\n        Args:\n            src_shapes: A dictionary mapping source shape identifiers to their corresponding Shape instances.\n            tgt_shapes: A dictionary mapping target shape identifiers to their corresponding Shape instances.\n            t: Interpolation factor between 0 and 1. A value of 0 returns the source shapes and 1 returns the target shapes.\n            max_len: Maximum allowed length for any line segment after splitting curves.\n            tolerance: The tolerance angle in degrees used when flattening curves.\n            min_point_spacing: Per-axis spacing threshold - a vertex is kept only if both `|\u0394x|` and `|\u0394y|` from the previous vertex are \u2265 this value (increasing it will boost performance during reproduction, but lower accuracy).\n            w_dist: Weight for the centroid-distance term (higher values make proximity more important).\n            w_area: Weight for the relative area-difference term (higher values make size similarity more important).\n            w_overlap: Weight for the overlap / IoU term that penalises pairs with little spatial intersection.\n            cost_threshold: Maximum acceptable cost for a pairing. Pairs whose cost is above this threshold are treated as unmatched and will grow/shrink to the closest centroid.\n            ensure_shell_pairs: If `True`, shell rings that would otherwise remain unmatched will be force-paired with the shell that yields the minimum cost. This guarantees that every visible contour morphs into something, at the price of allowing the same shell to be reused multiple times.\n\n        Returns:\n            dict[tuple[str | None, str | None], Shape]: A dictionary mapping tuples of source and target identifiers to the corresponding interpolated Shape. A source identifier of None indicates an appearing shape, while a target identifier of None indicates a disappearing shape.\n\n        Examples:\n            &gt;&gt;&gt; src = { 'A': Shape.star(5, 20, 40), 'B': Shape.ellipse(50, 30).move(100, 0) }\n            &gt;&gt;&gt; tgt = { 'X': Shape.polygon(6, 45) }\n            &gt;&gt;&gt; morphs = Shape.morph_multi(src, tgt, t=0.5)\n            &gt;&gt;&gt; for (src_id, tgt_id), shape in morphs.items():\n            ...     print(f\"{src_id} -&gt; {tgt_id}: {shape}\")\n        \"\"\"\n        # Basic validation\n        if not 0 &lt;= t &lt;= 1:\n            raise ValueError(\"t must be between 0 and 1\")\n        if any(not isinstance(s, Shape) for s in src_shapes.values()):\n            raise TypeError(\"All src_shapes values must be Shape instances\")\n        if any(not isinstance(s, Shape) for s in tgt_shapes.values()):\n            raise TypeError(\"All tgt_shapes values must be Shape instances\")\n\n        # Fast-paths\n        if t == 0:\n            return {(k, None): v for k, v in src_shapes.items()}\n        if t == 1:\n            return {(None, k): v for k, v in tgt_shapes.items()}\n\n        def _morph_transition(\n            ring: LinearRing,\n            ref_pt: Point,\n            t: float,\n            appearing: bool,\n        ) -&gt; LinearRing:\n            \"\"\"Morphism helper shared by *appearing* and *disappearing* rings.\"\"\"\n            if (t == 0 and not appearing) or (t == 1 and appearing):\n                return ring\n\n            coords = np.asarray(ring.coords[:-1], dtype=float)\n\n            if appearing:\n                # Grow *ring* from *ref_pt*\n                origin = np.array([ref_pt.x, ref_pt.y])\n                new_coords = origin + (coords - origin) * t\n            else:\n                # Shrink *ring* towards *ref_pt*\n                centroid = np.array(ring.centroid.coords[0])\n                dest = np.array([ref_pt.x, ref_pt.y])\n                new_coords = (\n                    centroid + (coords - centroid) * (1 - t) + (dest - centroid) * t\n                )\n\n            new_coords = np.vstack([new_coords, new_coords[0]])  # close ring\n            return LinearRing(new_coords)\n\n        def _interpolate_rings(\n            src_ring: LinearRing, tgt_ring: LinearRing, t: float\n        ) -&gt; LinearRing:\n            \"\"\"Linear interpolation between two rings with optimal vertex correspondence.\"\"\"\n            if t == 0:\n                return src_ring\n            if t == 1:\n                return tgt_ring\n            if len(src_ring.coords) != len(tgt_ring.coords):\n                raise ValueError(\n                    \"Rings must have the same number of vertices: \"\n                    f\"{len(src_ring.coords)} != {len(tgt_ring.coords)}\"\n                )\n\n            src_coords = np.asarray(src_ring.coords[:-1], dtype=float)\n            tgt_coords = np.asarray(tgt_ring.coords[:-1], dtype=float)\n\n            # Ensure orientation consistency\n            if src_ring.is_ccw != tgt_ring.is_ccw:\n                tgt_coords = tgt_coords[::-1]\n\n            # Find optimal alignment by minimizing total vertex distances\n            n_vertices = len(src_coords)\n            min_total_distance = float(\"inf\")\n            best_shift = 0\n\n            # Try all possible rotations and find the one with minimum total distance\n            for shift in range(n_vertices):\n                shifted_tgt = np.roll(tgt_coords, -shift, axis=0)\n                total_distance = np.sum(\n                    np.linalg.norm(src_coords - shifted_tgt, axis=1)\n                )\n\n                if total_distance &lt; min_total_distance:\n                    min_total_distance = total_distance\n                    best_shift = shift\n\n            # Apply the best alignment\n            if best_shift &gt; 0:\n                tgt_coords = np.roll(tgt_coords, -best_shift, axis=0)\n\n            # Perform linear interpolation between corresponding vertices\n            interp_coords = (1 - t) * src_coords + t * tgt_coords\n\n            # Close the ring\n            interp_coords = np.vstack([interp_coords, interp_coords[0]])\n            return LinearRing(interp_coords)\n\n        def _rings_to_multipolygon(\n            rings: list[tuple[LinearRing, bool]],\n        ) -&gt; MultiPolygon:\n            \"\"\"Convert a collection of `(ring, is_hole)` tuples to a `MultiPolygon`.\"\"\"\n\n            # Gather polygons (shells and holes)\n            shell_polys: list[Polygon] = []\n            hole_polys: list[Polygon] = []\n\n            for lr, is_hole in rings:\n                poly = Polygon(lr).buffer(0)\n                if poly.is_empty or not poly.is_valid:\n                    continue\n                (hole_polys if is_hole else shell_polys).append(poly)\n\n            # Union the shells and holes\n            shell_union = unary_union(shell_polys) if shell_polys else None\n            hole_union = unary_union(hole_polys) if hole_polys else None\n\n            # Subtract the holes from the shells (if any)\n            if shell_union and hole_union:\n                combined = shell_union.difference(hole_union)\n            elif shell_union:\n                combined = shell_union\n            elif hole_union:\n                combined = hole_union\n            else:\n                return MultiPolygon()\n\n            if isinstance(combined, MultiPolygon):\n                return combined\n            elif isinstance(combined, Polygon):\n                return MultiPolygon([combined])\n            else:\n                raise ValueError(\"Combined geometry is not a Polygon or MultiPolygon\")\n\n        # 1) Retrieve pairing &amp; resampling information (cached)\n        src_cmds = tuple(sorted((k, s.drawing_cmds) for k, s in src_shapes.items()))\n        dst_cmds = tuple(sorted((k, s.drawing_cmds) for k, s in tgt_shapes.items()))\n\n        paired, src_unmatched, tgt_unmatched = Shape._prepare_morph(\n            src_cmds,\n            dst_cmds,\n            max_len,\n            tolerance,\n            w_dist,\n            w_area,\n            w_overlap,\n            cost_threshold,\n            ensure_shell_pairs,\n        )\n\n        # 2) Interpolate matched rings\n        result_rings: list[tuple[LinearRing, bool, str | None, str | None]] = [\n            (_interpolate_rings(src, tgt, t), is_hole, src_id, tgt_id)\n            for src, tgt, is_hole, src_id, tgt_id in paired\n        ]\n\n        # 3) Handle disappearing / appearing rings\n        for ring, dest_pt, is_hole, src_id in src_unmatched:\n            result_rings.append(\n                (\n                    _morph_transition(ring, dest_pt, t, appearing=False),\n                    is_hole,\n                    src_id,\n                    None,\n                )\n            )\n        for ring, origin_pt, is_hole, tgt_id in tgt_unmatched:\n            result_rings.append(\n                (\n                    _morph_transition(ring, origin_pt, t, appearing=True),\n                    is_hole,\n                    None,\n                    tgt_id,\n                )\n            )\n\n        # 4) Group by (shape_id, target_id)\n        #    Holes coming from / going to *None* (i.e. appearing/disappearing) must be\n        #    subtracted from *every* shape \u2013 they are collected in `global_holes` and\n        #    later injected into every flow.\n\n        global_holes: list[tuple[LinearRing, bool]] = []  # always [(ring, True)]\n        flows: dict[tuple[str | None, str | None], list[tuple[LinearRing, bool]]] = {}\n\n        for ring, is_hole, src_id, tgt_id in result_rings:\n            # If the ring is a hole and one side of the morph is missing, treat it as\n            # a *global* hole that has to be removed from every resulting geometry.\n            if is_hole and (src_id is None or tgt_id is None):\n                global_holes.append((ring, True))\n                continue\n\n            flows.setdefault((src_id, tgt_id), []).append((ring, is_hole))\n\n        # Inject global holes into every shape flow so they are diffed out.\n        if global_holes:\n            for ring_list in flows.values():\n                ring_list.extend(global_holes)\n\n        # 5) Convert back to Shape and return as dictionary\n        result: dict[tuple[str | None, str | None], Shape] = {}\n        for (src_id, tgt_id), ring_list in flows.items():\n            mp = _rings_to_multipolygon(ring_list)\n            result[(src_id, tgt_id)] = Shape.from_multipolygon(mp, min_point_spacing)\n        return result\n\n    PIXEL: str = \"m 0 1 l 0 0 1 0 1 1\"\n    \"\"\"A string representing a pixel.\"\"\"\n\n    @classmethod\n    def triangle(cls, width: float, height: float) -&gt; \"Shape\":\n        \"\"\"Creates a triangle centered at the origin with the specified width and height.\n\n        The triangle is defined by three vertices:\n        - Top vertex at (0, height/2).\n        - Bottom-left vertex at (-width/2, -height/2).\n        - Bottom-right vertex at (width/2, -height/2).\n\n        Args:\n            width: The width of the triangle base (must be positive).\n            height: The height of the triangle (must be positive).\n\n        Returns:\n            Shape: A new Shape instance representing the triangle.\n        \"\"\"\n        if width &lt;= 0 or height &lt;= 0:\n            raise ValueError(\"Width and height must be positive\")\n\n        # Calculate vertices\n        half_w = width / 2\n        half_h = height / 2\n        vertices = [\n            (0, half_h),  # Top vertex\n            (-half_w, -half_h),  # Bottom-left vertex\n            (half_w, -half_h),  # Bottom-right vertex\n        ]\n\n        # Build ASS path command\n        f = cls.format_value\n        path_parts = [f\"m {f(vertices[0][0])} {f(vertices[0][1])}\"]\n\n        for vertex in vertices[1:]:\n            path_parts.append(f\"l {f(vertex[0])} {f(vertex[1])}\")\n\n        return cls(\" \".join(path_parts)).align()\n\n    @classmethod\n    def rectangle(cls, width: float, height: float) -&gt; \"Shape\":\n        \"\"\"Creates a rectangle shape with the specified width and height.\n\n        Args:\n            width: The width of the rectangle (must be positive).\n            height: The height of the rectangle (must be positive).\n\n        Returns:\n            Shape: A new Shape instance representing the rectangle.\n        \"\"\"\n        if width &lt;= 0 or height &lt;= 0:\n            raise ValueError(\"Width and height must be positive\")\n\n        f = cls.format_value\n        return cls(\n            \"m 0 0 l %s 0 %s %s 0 %s 0 0\" % (f(width), f(width), f(height), f(height))\n        )\n\n    @classmethod\n    def square(cls, size: float) -&gt; \"Shape\":\n        \"\"\"Creates a square shape with the given side length.\n\n        Args:\n            size: The side length of the square (must be positive).\n\n        Returns:\n            Shape: A new Shape instance representing the square.\n        \"\"\"\n        return cls.rectangle(size, size)\n\n    @classmethod\n    def rounded_rectangle(cls, width: float, height: float, radius: float) -&gt; \"Shape\":\n        \"\"\"Creates a rounded rectangle shape.\n\n        Args:\n            width: Rectangle width in pixels (must be positive).\n            height: Rectangle height in pixels (must be positive).\n            radius: Corner radius in pixels (must be &lt;= min(width/2, height/2)).\n\n        Returns:\n            Shape: A rounded rectangle with origin at top-left (0,0), extending to (width, height).\n        \"\"\"\n        if width &lt;= 0 or height &lt;= 0:\n            raise ValueError(\"Width and height must be positive\")\n        if radius &lt; 0:\n            raise ValueError(\"Radius must be non-negative\")\n        if radius &gt; min(width / 2, height / 2):\n            raise ValueError(\"Radius is too large for the given dimensions\")\n\n        f = cls.format_value\n        k = 0.5522847498 * radius  # Bezier approximation constant\n        w, h, r = width, height, radius\n\n        # Each tuple: (line_end_x, line_end_y, bezier_c1x, c1y, c2x, c2y, end_x, end_y)\n        segments = [\n            (w - r, 0, w - r + k, 0, w, k, w, r),  # Top edge + top-right corner\n            (\n                w,\n                h - r,\n                w,\n                h - r + k,\n                w - k,\n                h,\n                w - r,\n                h,\n            ),  # Right edge + bottom-right corner\n            (r, h, r - k, h, 0, h - k, 0, h - r),  # Bottom edge + bottom-left corner\n            (0, r, 0, r - k, k, 0, r, 0),  # Left edge + top-left corner\n        ]\n\n        cmd = [f\"m {f(r)} {f(0)}\"]\n        for lx, ly, c1x, c1y, c2x, c2y, ex, ey in segments:\n            cmd.extend(\n                [\n                    f\"l {f(lx)} {f(ly)}\",\n                    f\"b {f(c1x)} {f(c1y)} {f(c2x)} {f(c2y)} {f(ex)} {f(ey)}\",\n                ]\n            )\n\n        return cls(\" \".join(cmd))\n\n    @classmethod\n    def polygon(cls, edges: int, side_length: float) -&gt; \"Shape\":\n        \"\"\"Creates a regular n-sided polygon shape.\n\n        Args:\n            edges: Number of sides for the polygon (must be at least 3).\n            side_length: The length of each side (must be positive).\n\n        Returns:\n            Shape: A Shape object representing the polygon.\n        \"\"\"\n        if edges &lt; 3:\n            raise ValueError(\"Edges must be \u2265 3\")\n        if side_length &lt;= 0:\n            raise ValueError(\"Side length must be positive\")\n\n        # Calculate circumradius from side length\n        radius = side_length / (2 * math.sin(math.pi / edges))\n\n        f = cls.format_value\n        pts = []\n        # Rotate to get a more natural orientation (flat bottom when possible)\n        angle_offset = math.pi / 2 + math.pi / edges\n\n        for i in range(edges):\n            angle = 2 * math.pi * i / edges + angle_offset\n            x = radius * math.cos(angle)\n            y = radius * math.sin(angle)\n            pts.append((f(x), f(y)))\n\n        cmd_parts = [f\"m {pts[0][0]} {pts[0][1]} l\"]\n        cmd_parts.extend(f\"{x} {y}\" for x, y in pts[1:])\n        return cls(\" \".join(cmd_parts)).align()\n\n    @classmethod\n    def ellipse(cls, w: float, h: float) -&gt; \"Shape\":\n        \"\"\"Creates an ellipse shape centered at the origin.\n\n        Args:\n            w: The width of the ellipse.\n            h: The height of the ellipse.\n\n        Returns:\n            Shape: A Shape object representing the ellipse.\n        \"\"\"\n        try:\n            w2, h2 = w / 2, h / 2\n        except TypeError:\n            raise TypeError(\"Number(s) expected\")\n\n        f = cls.format_value\n\n        return cls(\n            \"m 0 %s \"\n            \"b 0 %s 0 0 %s 0 \"\n            \"%s 0 %s 0 %s %s \"\n            \"%s %s %s %s %s %s \"\n            \"%s %s 0 %s 0 %s\"\n            % (\n                f(h2),  # move\n                f(h2),\n                f(w2),  # curve 1\n                f(w2),\n                f(w),\n                f(w),\n                f(h2),  # curve 2\n                f(w),\n                f(h2),\n                f(w),\n                f(h),\n                f(w2),\n                f(h),  # curve 3\n                f(w2),\n                f(h),\n                f(h),\n                f(h2),  # curve 4\n            )\n        )\n\n    @classmethod\n    def circle(cls, radius: float) -&gt; \"Shape\":\n        \"\"\"Creates a circle shape with the given radius.\n\n        Args:\n            radius: The radius of the circle (must be positive).\n\n        Returns:\n            Shape: A new Shape instance representing the circle.\n        \"\"\"\n        return cls.ellipse(2 * radius, 2 * radius)\n\n    @classmethod\n    def ring(cls, out_r: float, in_r: float) -&gt; \"Shape\":\n        \"\"\"Creates a ring shape with specified inner and outer radii centered at the origin.\n\n        Args:\n            out_r: The outer radius of the ring.\n            in_r: The inner radius of the ring (must be less than out_r).\n\n        Returns:\n            Shape: A Shape object representing the ring.\n        \"\"\"\n        try:\n            out_r2, in_r2 = out_r * 2, in_r * 2\n            off = out_r - in_r\n            off_in_r = off + in_r\n            off_in_r2 = off + in_r2\n        except TypeError:\n            raise TypeError(\"Number(s) expected\")\n\n        if in_r &gt;= out_r:\n            raise ValueError(\n                \"Valid number expected. Inner radius must be less than outer radius\"\n            )\n\n        f = cls.format_value\n        return cls(\n            \"m 0 %s \"\n            \"b 0 %s 0 0 %s 0 \"\n            \"%s 0 %s 0 %s %s \"\n            \"%s %s %s %s %s %s \"\n            \"%s %s 0 %s 0 %s \"\n            \"m %s %s \"\n            \"b %s %s %s %s %s %s \"\n            \"%s %s %s %s %s %s \"\n            \"%s %s %s %s %s %s \"\n            \"%s %s %s %s %s %s\"\n            % (\n                f(out_r),  # outer move\n                f(out_r),\n                f(out_r),  # outer curve 1\n                f(out_r),\n                f(out_r2),\n                f(out_r2),\n                f(out_r),  # outer curve 2\n                f(out_r2),\n                f(out_r),\n                f(out_r2),\n                f(out_r2),\n                f(out_r),\n                f(out_r2),  # outer curve 3\n                f(out_r),\n                f(out_r2),\n                f(out_r2),\n                f(out_r),  # outer curve 4\n                f(off),\n                f(off_in_r),  # inner move\n                f(off),\n                f(off_in_r),\n                f(off),\n                f(off_in_r2),\n                f(off_in_r),\n                f(off_in_r2),  # inner curve 1\n                f(off_in_r),\n                f(off_in_r2),\n                f(off_in_r2),\n                f(off_in_r2),\n                f(off_in_r2),\n                f(off_in_r),  # inner curve 2\n                f(off_in_r2),\n                f(off_in_r),\n                f(off_in_r2),\n                f(off),\n                f(off_in_r),\n                f(off),  # inner curve 3\n                f(off_in_r),\n                f(off),\n                f(off),\n                f(off),\n                f(off),\n                f(off_in_r),  # inner curve 4\n            )\n        )\n\n    @classmethod\n    def heart(cls, size: float, offset: float = 0) -&gt; \"Shape\":\n        \"\"\"Creates a heart shape with specified dimensions and vertical offset.\n\n        Args:\n            size: The width and height of the heart.\n            offset: The vertical offset for the heart's center point (default is 0).\n\n        Returns:\n            Shape: A Shape object representing the heart.\n        \"\"\"\n        try:\n            mult = 100 * size / 30\n        except TypeError:\n            raise TypeError(\"Size parameter must be a number\")\n        # Build shape from template\n        shape = cls(\n            \"m 15 30 b 27 22 30 18 30 14 30 8 22 0 15 10 8 0 0 8 0 14 0 18 3 22 15 30\"\n        ).scale(mult)\n\n        # Shift mid point of heart vertically\n        count = 0\n\n        def shift_mid_point(x, y):\n            nonlocal count\n            count += 1\n\n            if count == 7:\n                try:\n                    return x, y + offset\n                except TypeError:\n                    raise TypeError(\"Offset parameter must be a number\")\n            return x, y\n\n        # Return result\n        return shape.map(shift_mid_point)\n\n    @classmethod\n    def _glance_or_star(\n        cls, edges: int, inner_size: float, outer_size: float, g_or_s: str\n    ) -&gt; \"Shape\":\n        \"\"\"Generates a shape for a star or glance based on provided parameters.\n\n        Args:\n            edges: The number of edges in the shape.\n            inner_size: The size used for the inner vertex or control points.\n            outer_size: The size used for the outer vertex.\n            g_or_s: Flag to determine the style ('l' for star with lines, 'b' for glance with curves).\n\n        Returns:\n            Shape: A Shape object representing the generated star or glance.\n        \"\"\"\n        # Alias for utility functions\n        f = cls.format_value\n\n        def rotate_on_axis_z(point, theta):\n            # Internal function to rotate a point around z axis by a given angle.\n            theta = math.radians(theta)\n            return Quaternion(axis=[0, 0, 1], angle=theta).rotate(point)\n\n        # Building shape\n        shape = [f\"m 0 {-outer_size} {g_or_s}\"]\n        inner_p, outer_p = 0, 0\n\n        for i in range(1, edges + 1):\n            # Inner edge\n            inner_p = rotate_on_axis_z([0, -inner_size, 0], ((i - 0.5) / edges) * 360)\n            # Outer edge\n            outer_p = rotate_on_axis_z([0, -outer_size, 0], (i / edges) * 360)\n            # Add curve / line\n            if g_or_s == \"l\":\n                shape.append(\n                    \"%s %s %s %s\"\n                    % (f(inner_p[0]), f(inner_p[1]), f(outer_p[0]), f(outer_p[1]))\n                )\n            else:\n                shape.append(\n                    \"%s %s %s %s %s %s\"\n                    % (\n                        f(inner_p[0]),\n                        f(inner_p[1]),\n                        f(inner_p[0]),\n                        f(inner_p[1]),\n                        f(outer_p[0]),\n                        f(outer_p[1]),\n                    )\n                )\n\n        shape = cls(\" \".join(shape))\n\n        # Return result centered\n        return shape.align()\n\n    @classmethod\n    def star(cls, edges: int, inner_size: float, outer_size: float) -&gt; \"Shape\":\n        \"\"\"Creates a star shape centered at the origin.\n\n        Args:\n            edges: The number of edges for the star.\n            inner_size: The distance from the center to the inner vertices.\n            outer_size: The distance from the center to the outer vertices.\n\n        Returns:\n            Shape: A Shape object representing the star.\n        \"\"\"\n        return cls._glance_or_star(edges, inner_size, outer_size, \"l\")\n\n    @classmethod\n    def glance(cls, edges: int, inner_size: float, outer_size: float) -&gt; \"Shape\":\n        \"\"\"Creates a glance shape with curved transitions between edges.\n\n        Args:\n            edges: The number of edges for the glance.\n            inner_size: The distance from the center to the inner control points.\n            outer_size: The control point distance for the curves between outer edges.\n\n        Returns:\n            Shape: A Shape object representing the glance.\n        \"\"\"\n        return cls._glance_or_star(edges, inner_size, outer_size, \"b\")\n</code></pre>"},{"location":"reference/shape/#pyonfx.shape.Shape.elements","title":"<code>elements</code>  <code>instance-attribute</code>","text":"<p>The shape's elements as a list of :class:<code>ShapeElement</code> objects.</p>"},{"location":"reference/shape/#pyonfx.shape.Shape.drawing_cmds","title":"<code>drawing_cmds</code>  <code>property</code>","text":"<p>The shape's drawing commands in ASS format as a string.</p>"},{"location":"reference/shape/#pyonfx.shape.Shape.PIXEL","title":"<code>PIXEL = 'm 0 1 l 0 0 1 0 1 1'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>A string representing a pixel.</p>"},{"location":"reference/shape/#pyonfx.shape.Shape.to_multipolygon","title":"<code>to_multipolygon(tolerance=1.0)</code>","text":"<p>Convert the shape to a Shapely MultiPolygon.</p> <p>It processes the shape into individual closed loops that are then assembled into polygons with proper shell-hole relationships. It automatically calls <code>flatten</code> to convert curves into straight line segments.</p> <p>Parameters:</p> Name Type Description Default <code>tolerance</code> <code>float</code> <p>The tolerance angle in degrees used to determine when a bezier curve is considered flat. Higher values yield lower accuracy but faster processing.</p> <code>1.0</code> <p>Returns:</p> Name Type Description <code>MultiPolygon</code> <code>MultiPolygon</code> <p>A MultiPolygon where each polygon consists of an outer shell (and optional holes) representing distinct contours of the shape.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; shape = Shape(\"m 0 0 l 10 0 10 10 l 0 10 c\")\n&gt;&gt;&gt; mp = shape.to_multipolygon(tolerance=1.0)\n</code></pre> Source code in <code>pyonfx/shape.py</code> <pre><code>def to_multipolygon(self, tolerance: float = 1.0) -&gt; MultiPolygon:\n    \"\"\"Convert the shape to a Shapely MultiPolygon.\n\n    It processes the shape into individual closed loops that are then assembled into polygons with proper shell-hole relationships.\n    It automatically calls [`flatten`][pyonfx.shape.Shape.flatten] to convert curves into straight line segments.\n\n    Args:\n        tolerance: The tolerance angle in degrees used to determine when a bezier curve is considered flat. Higher values yield lower accuracy but faster processing.\n\n    Returns:\n        MultiPolygon: A MultiPolygon where each polygon consists of an outer shell (and optional holes) representing distinct contours of the shape.\n\n    Examples:\n        &gt;&gt;&gt; shape = Shape(\"m 0 0 l 10 0 10 10 l 0 10 c\")\n        &gt;&gt;&gt; mp = shape.to_multipolygon(tolerance=1.0)\n    \"\"\"\n    # Work on a copy to avoid modifying the original shape\n    shape_copy = Shape(self.drawing_cmds)\n\n    # 1. Ensure the outline is fully linear by flattening B\u00e9ziers.\n    shape_copy.flatten(tolerance)\n\n    # 2. Extract individual closed loops (contours).\n    loops: list[list[Point]] = []\n    current_loop: list[Point] = []\n\n    for element in shape_copy:\n        cmd = element.command\n        if cmd == \"m\":\n            if current_loop:\n                loops.append(current_loop)\n            current_loop = [element.coordinates[0]]\n        elif cmd in {\"l\", \"n\"}:\n            current_loop.append(element.coordinates[0])\n\n    if current_loop:\n        loops.append(current_loop)\n\n    # 3. Convert loops to Shapely polygons (without holes yet).\n    loop_polys: list[Polygon] = []\n    for pts in loops:\n        if len(pts) &lt; 3:\n            # Degenerate loop \u2013 ignore.\n            continue\n        loop_polys.append(Polygon(pts))\n\n    if not loop_polys:\n        return MultiPolygon([])\n\n    # 4. Sort by descending area magnitude so that larger shells are processed first.\n    loop_polys.sort(key=lambda p: abs(p.area), reverse=True)\n\n    shells: list[Polygon] = []\n    holes_map: dict[Polygon, set[Polygon]] = {}\n\n    for loop_poly in loop_polys:\n        # Try to place the loop as a hole inside an existing shell.\n        for shell in shells:\n            if shell.contains(loop_poly):\n                holes_map[shell].add(loop_poly)\n                break\n        else:\n            # It's a new outer shell.\n            shells.append(loop_poly)\n            holes_map[loop_poly] = set()\n\n    # 5. Build compound polygons with their holes.\n    compounds: list[Polygon] = []\n    for shell in shells:\n        holes = holes_map[shell]\n        if holes:\n            compound = Polygon(shell.exterior, [h.exterior for h in holes])\n        else:\n            compound = shell\n        compounds.append(compound)\n\n    return MultiPolygon(compounds)\n</code></pre>"},{"location":"reference/shape/#pyonfx.shape.Shape.from_multipolygon","title":"<code>from_multipolygon(multipolygon, min_point_spacing=0.5)</code>  <code>classmethod</code>","text":"<p>Create a Shape instance from a Shapely MultiPolygon.</p> <p>Parameters:</p> Name Type Description Default <code>multipolygon</code> <code>MultiPolygon</code> <p>The Shapely MultiPolygon geometry to convert.</p> required <code>min_point_spacing</code> <code>float</code> <p>Per-axis spacing threshold - a vertex is kept only if both <code>|\u0394x|</code> and <code>|\u0394y|</code> from the previous vertex are \u2265 this value (increasing it will boost performance during reproduction, but lower accuracy).</p> <code>0.5</code> <p>Returns:</p> Name Type Description <code>Shape</code> <code>Shape</code> <p>A new Shape instance representing the geometry of the provided MultiPolygon.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from shapely.geometry import MultiPolygon, Polygon\n&gt;&gt;&gt; mp = MultiPolygon([Polygon([(0,0), (10,0), (10,10), (0,10)])])\n&gt;&gt;&gt; shape = Shape.from_multipolygon(mp, min_point_spacing=0.5)\n</code></pre> See Also <p><code>to_multipolygon</code></p> Source code in <code>pyonfx/shape.py</code> <pre><code>@classmethod\ndef from_multipolygon(\n    cls, multipolygon: MultiPolygon, min_point_spacing: float = 0.5\n) -&gt; \"Shape\":\n    \"\"\"Create a Shape instance from a Shapely MultiPolygon.\n\n    Args:\n        multipolygon: The Shapely MultiPolygon geometry to convert.\n        min_point_spacing: Per-axis spacing threshold - a vertex is kept only if both `|\u0394x|` and `|\u0394y|` from the previous vertex are \u2265 this value (increasing it will boost performance during reproduction, but lower accuracy).\n\n    Returns:\n        Shape: A new Shape instance representing the geometry of the provided MultiPolygon.\n\n    Examples:\n        &gt;&gt;&gt; from shapely.geometry import MultiPolygon, Polygon\n        &gt;&gt;&gt; mp = MultiPolygon([Polygon([(0,0), (10,0), (10,10), (0,10)])])\n        &gt;&gt;&gt; shape = Shape.from_multipolygon(mp, min_point_spacing=0.5)\n\n    See Also:\n        [`to_multipolygon`][pyonfx.shape.Shape.to_multipolygon]\n    \"\"\"\n    if not isinstance(multipolygon, MultiPolygon):\n        raise TypeError(\"Expected a MultiPolygon instance\")\n\n    elements: list[ShapeElement] = []\n\n    def _linear_ring_to_elements(linear_ring: LinearRing, is_hole: bool = False):\n        nonlocal elements\n\n        coords = list(linear_ring.coords)\n        if not coords:\n            return\n\n        # Remove duplicate closing point if present\n        if len(coords) &gt; 1 and coords[0] == coords[-1]:\n            coords.pop()\n\n        # Normalize orientation (outer = CW, inner = CCW)\n        if is_hole and not linear_ring.is_ccw:\n            coords = coords[::-1]\n        elif not is_hole and linear_ring.is_ccw:\n            coords = coords[::-1]\n\n        # Consecutive \"m\" commands are overriden, drop last one\n        if elements and elements[-1].command == \"m\":\n            elements.pop()\n\n        first_point = last_point = coords[0]\n        elements.append(ShapeElement(\"m\", [Point(first_point[0], first_point[1])]))\n        if len(coords) &gt; 1:\n            for x, y in coords[1:]:\n                if (\n                    abs(last_point[0] - x) &gt;= min_point_spacing\n                    or abs(last_point[1] - y) &gt;= min_point_spacing\n                ):\n                    elements.append(ShapeElement(\"l\", [Point(x, y)]))\n                    last_point = (x, y)\n\n    for polygon in multipolygon.geoms:\n        if not isinstance(polygon, Polygon) or polygon.is_empty:\n            continue\n        _linear_ring_to_elements(polygon.exterior, is_hole=False)\n        for interior in polygon.interiors:\n            _linear_ring_to_elements(interior, is_hole=True)\n\n    # Ending with \"m\" command is not VSFilter compatible, drop it\n    if elements and elements[-1].command == \"m\":\n        elements.pop()\n\n    return cls(elements=elements)\n</code></pre>"},{"location":"reference/shape/#pyonfx.shape.Shape.bounding","title":"<code>bounding(exact=False)</code>","text":"<p>Calculate the bounding box of the shape.</p> <p>Parameters:</p> Name Type Description Default <code>exact</code> <code>bool</code> <p>If True, perform an exact calculation by considering curve details; if False, use a faster approximation (libass).</p> <code>False</code> <p>Returns:</p> Type Description <code>tuple[float, float, float, float]</code> <p>tuple[float, float, float, float]: A tuple (x_min, y_min, x_max, y_max) representing the bounding coordinates of the shape.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; shape = Shape(\"m 10 5 l 25 5 25 42 10 42\")\n&gt;&gt;&gt; shape.bounding()\n(10.0, 5.0, 25.0, 42.0)  # left, top, right, bottom\n</code></pre> Source code in <code>pyonfx/shape.py</code> <pre><code>def bounding(self, exact: bool = False) -&gt; tuple[float, float, float, float]:\n    \"\"\"Calculate the bounding box of the shape.\n\n    Args:\n        exact: If True, perform an exact calculation by considering curve details; if False, use a faster approximation (libass).\n\n    Returns:\n        tuple[float, float, float, float]: A tuple (x_min, y_min, x_max, y_max) representing the bounding coordinates of the shape.\n\n    Examples:\n        &gt;&gt;&gt; shape = Shape(\"m 10 5 l 25 5 25 42 10 42\")\n        &gt;&gt;&gt; shape.bounding()\n        (10.0, 5.0, 25.0, 42.0)  # left, top, right, bottom\n    \"\"\"\n    all_points = [coord for element in self for coord in element.coordinates]\n\n    if not exact:\n        return MultiPoint(all_points).bounds\n\n    def _cubic_bezier_bounds(\n        p0: Point,\n        p1: Point,\n        p2: Point,\n        p3: Point,\n    ) -&gt; tuple[float, float, float, float]:\n        \"\"\"Axis-aligned bounds of a cubic B\u00e9zier curve.\n\n        Implementation adapted from https://stackoverflow.com/a/14429749\n        taking care of degenerate cases (coincident control points).\n        \"\"\"\n\n        def _axis_bounds(c0, c1, c2, c3):\n            # Solve derivative 3*at^2 + 2*bt + c for roots in (0,1)\n            a = -3 * c0 + 9 * c1 - 9 * c2 + 3 * c3\n            b = 6 * c0 - 12 * c1 + 6 * c2\n            c = 3 * (c1 - c0)\n\n            ts: list[float] = []\n\n            if abs(a) &lt; 1e-12:  # Quadratic (or linear) case\n                if abs(b) &gt; 1e-12:\n                    t = -c / b\n                    if 0 &lt; t &lt; 1:\n                        ts.append(t)\n            else:  # Cubic case\n                disc = b * b - 4 * a * c\n                if disc &gt;= 0:\n                    sqrt_disc = math.sqrt(disc)\n                    for sign in (1, -1):\n                        t = (-b + sign * sqrt_disc) / (2 * a)\n                        if 0 &lt; t &lt; 1:\n                            ts.append(t)\n\n            # extrema candidates are the end-points and the roots above\n            vals = [c0, c3]\n            for t in ts:\n                mt = 1 - t\n                vals.append(\n                    mt * mt * mt * c0\n                    + 3 * mt * mt * t * c1\n                    + 3 * mt * t * t * c2\n                    + t * t * t * c3\n                )\n\n            return min(vals), max(vals)\n\n        xmin, xmax = _axis_bounds(p0.x, p1.x, p2.x, p3.x)\n        ymin, ymax = _axis_bounds(p0.y, p1.y, p2.y, p3.y)\n        return xmin, ymin, xmax, ymax\n\n    x_min, y_min = math.inf, math.inf\n    x_max, y_max = -math.inf, -math.inf\n\n    def _update(pt: Point):\n        nonlocal x_min, y_min, x_max, y_max\n        x_min = min(x_min, pt.x)\n        y_min = min(y_min, pt.y)\n        x_max = max(x_max, pt.x)\n        y_max = max(y_max, pt.y)\n\n    prev_element: ShapeElement | None = None\n\n    for element in self:\n        match element.command:\n            case \"m\" | \"n\":\n                prev_element = element\n            case \"l\":\n                if prev_element is not None and prev_element.command in {\"m\", \"n\"}:\n                    _update(prev_element.coordinates[-1])\n                for c in element.coordinates:\n                    _update(c)\n                prev_element = element\n            case \"b\":\n                if prev_element is None:\n                    raise ValueError(\n                        \"Bezier command found without an initial point.\"\n                    )\n                bx_min, by_min, bx_max, by_max = _cubic_bezier_bounds(\n                    prev_element.coordinates[-1], *element.coordinates\n                )\n                _update(Point(bx_min, by_min))\n                _update(Point(bx_max, by_max))\n                prev_element = element\n            case \"c\":\n                pass\n            case _:\n                raise NotImplementedError(\n                    f\"Drawing command '{element.command}' not handled by bounding().\"\n                )\n\n    if math.inf in (x_min, y_min) or -math.inf in (x_max, y_max):\n        raise ValueError(\"Invalid or empty shape - could not determine bounds.\")\n\n    return x_min, y_min, x_max, y_max\n</code></pre>"},{"location":"reference/shape/#pyonfx.shape.Shape.boolean","title":"<code>boolean(other, op, *, tolerance=1.0, min_point_spacing=0.5)</code>","text":"<p>Perform a boolean operation between two shapes.</p> <p>This method converts both shapes to Shapely MultiPolygon objects (flattening any B\u00e9zier curves with the provided tolerance) and performs the specified boolean operation (union, intersection, difference, or symmetric difference). The result is converted back into a Shape instance.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Shape</code> <p>The other shape to combine with this shape.</p> required <code>op</code> <code>Literal['union', 'intersection', 'difference', 'xor']</code> <p>The boolean operation to perform. Use \"union\" for combined area, \"intersection\" for overlapping area, \"difference\" for subtraction, or \"xor\" for symmetric difference.</p> required <code>tolerance</code> <code>float</code> <p>The tolerance angle in degrees used for flattening curves. Higher tolerance reduces processing time but lowers accuracy.</p> <code>1.0</code> <code>min_point_spacing</code> <code>float</code> <p>The minimum spacing between consecutive points when converting back from polygons to a shape.</p> <code>0.5</code> <p>Returns:</p> Name Type Description <code>Shape</code> <code>Shape</code> <p>A new Shape instance representing the resulting shape after the boolean operation.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; shape1 = Shape(\"m 0 0 l 10 0 10 10 0 10\")\n&gt;&gt;&gt; shape2 = Shape(\"m 5 5 l 15 5 15 15 5 15\")\n&gt;&gt;&gt; shape1.boolean(shape2, op=\"intersection\", tolerance=1.0, min_point_spacing=0.5)\nm 10 10 l 10 5 5 5 5 10\n</code></pre> See Also <p><code>to_multipolygon</code> <code>from_multipolygon</code></p> Source code in <code>pyonfx/shape.py</code> <pre><code>def boolean(\n    self,\n    other: \"Shape\",\n    op: Literal[\"union\", \"intersection\", \"difference\", \"xor\"],\n    *,\n    tolerance: float = 1.0,\n    min_point_spacing: float = 0.5,\n) -&gt; \"Shape\":\n    \"\"\"Perform a boolean operation between two shapes.\n\n    This method converts both shapes to Shapely MultiPolygon objects (flattening any B\u00e9zier curves with the provided tolerance)\n    and performs the specified boolean operation (union, intersection, difference, or symmetric difference).\n    The result is converted back into a Shape instance.\n\n    Args:\n        other: The other shape to combine with this shape.\n        op: The boolean operation to perform. Use \"union\" for combined area, \"intersection\" for overlapping area, \"difference\" for subtraction, or \"xor\" for symmetric difference.\n        tolerance: The tolerance angle in degrees used for flattening curves. Higher tolerance reduces processing time but lowers accuracy.\n        min_point_spacing: The minimum spacing between consecutive points when converting back from polygons to a shape.\n\n    Returns:\n        Shape: A new Shape instance representing the resulting shape after the boolean operation.\n\n    Examples:\n        &gt;&gt;&gt; shape1 = Shape(\"m 0 0 l 10 0 10 10 0 10\")\n        &gt;&gt;&gt; shape2 = Shape(\"m 5 5 l 15 5 15 15 5 15\")\n        &gt;&gt;&gt; shape1.boolean(shape2, op=\"intersection\", tolerance=1.0, min_point_spacing=0.5)\n        m 10 10 l 10 5 5 5 5 10\n\n    See Also:\n        [`to_multipolygon`][pyonfx.shape.Shape.to_multipolygon]\n        [`from_multipolygon`][pyonfx.shape.Shape.from_multipolygon]\n    \"\"\"\n    if not isinstance(other, Shape):\n        raise TypeError(\"other must be a Shape instance\")\n\n    if op not in {\"union\", \"intersection\", \"difference\", \"xor\"}:\n        raise ValueError(\n            \"op must be one of 'union', 'intersection', 'difference', or 'xor'\"\n        )\n\n    # Convert both shapes to MultiPolygon (this flattens curves).\n    mp_self = self.to_multipolygon(tolerance)\n    mp_other = other.to_multipolygon(tolerance)\n\n    # Perform the requested boolean operation.\n    if op == \"union\":\n        result_geom = mp_self.union(mp_other)\n    elif op == \"intersection\":\n        result_geom = mp_self.intersection(mp_other)\n    elif op == \"difference\":\n        result_geom = mp_self.difference(mp_other)\n    else:  # op == \"xor\"\n        result_geom = mp_self.symmetric_difference(mp_other)\n\n    # Normalise to MultiPolygon\n    if isinstance(result_geom, Polygon):\n        result_geom = MultiPolygon([result_geom])\n    elif not isinstance(result_geom, MultiPolygon):\n        # No overlapping geometry \u2013 return an empty shape.\n        return Shape()\n\n    # Convert back to Shape.\n    return Shape.from_multipolygon(result_geom, min_point_spacing)\n</code></pre>"},{"location":"reference/shape/#pyonfx.shape.Shape.map","title":"<code>map(fun)</code>","text":"<p>Sends every point of the shape through a transformation function.</p> <p>This method applies a user-provided transformation function to each coordinate of the shape's elements, allowing for arbitrary deformations or adjustments. The function can accept two parameters (x and y) or three parameters (x, y, and the command type), providing flexibility in the transformation logic.</p> <p>Parameters:</p> Name Type Description Default <code>fun</code> <code>Callable[[float, float], tuple[float, float]] | Callable[[float, float, str], tuple[float, float]]</code> <p>A function that takes the x and y coordinates (and optionally the drawing command as the third argument) and returns a tuple with the transformed (x, y) coordinates.</p> required <p>Returns:</p> Name Type Description <code>Shape</code> <code>Shape</code> <p>A new Shape instance with each point transformed according to the provided function.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; original = Shape(\"m 0 0 l 20 0 20 10 0 10\")\n&gt;&gt;&gt; original.map(lambda x, y: (x + 10, y + 5))\nm 10 5 l 30 5 30 15 10 15\n</code></pre> Source code in <code>pyonfx/shape.py</code> <pre><code>def map(\n    self,\n    fun: (\n        Callable[[float, float], tuple[float, float]]\n        | Callable[[float, float, str], tuple[float, float]]\n    ),\n) -&gt; \"Shape\":\n    \"\"\"Sends every point of the shape through a transformation function.\n\n    This method applies a user-provided transformation function to each coordinate of the shape's elements, allowing for arbitrary deformations or adjustments.\n    The function can accept two parameters (x and y) or three parameters (x, y, and the command type), providing flexibility in the transformation logic.\n\n    Args:\n        fun: A function that takes the x and y coordinates (and optionally the drawing command as the third argument) and returns a tuple with the transformed (x, y) coordinates.\n\n    Returns:\n        Shape: A new Shape instance with each point transformed according to the provided function.\n\n    Examples:\n        &gt;&gt;&gt; original = Shape(\"m 0 0 l 20 0 20 10 0 10\")\n        &gt;&gt;&gt; original.map(lambda x, y: (x + 10, y + 5))\n        m 10 5 l 30 5 30 15 10 15\n    \"\"\"\n    if not callable(fun):\n        raise TypeError(\"(Lambda) function expected\")\n\n    # Determine the arity of the transformation function\n    n_params = len(signature(fun).parameters)\n    if n_params not in (2, 3):\n        raise ValueError(\"Function must have 2 or 3 parameters\")\n\n    # Create a wrapper function accepting always 3 parameters\n    if n_params == 3:\n        fun = cast(Callable[[float, float, str], tuple[float, float]], fun)\n        _apply = lambda px, py, cmd: fun(px, py, cmd)\n    else:\n        fun = cast(Callable[[float, float], tuple[float, float]], fun)\n        _apply = lambda px, py, _: fun(px, py)\n\n    # Apply the transformation to each element\n    transformed_elements: list[ShapeElement] = []\n    for element in self:\n        if not element.coordinates:\n            transformed_elements.append(element)\n            continue\n\n        transformed_coords = [\n            Point(*_apply(p.x, p.y, element.command)) for p in element.coordinates\n        ]\n        transformed_elements.append(\n            ShapeElement(element.command, transformed_coords)\n        )\n\n    return Shape(elements=transformed_elements)\n</code></pre>"},{"location":"reference/shape/#pyonfx.shape.Shape.move","title":"<code>move(x, y)</code>","text":"<p>Move the shape by the specified x and y offsets.</p> <p>This method translates every point in the shape by adding the given x and y offsets to the corresponding coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>The displacement along the x-axis.</p> required <code>y</code> <code>float</code> <p>The displacement along the y-axis.</p> required <p>Returns:</p> Name Type Description <code>Shape</code> <code>Shape</code> <p>A new Shape instance with the coordinates moved by the specified offsets.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; shape = Shape(\"m 0 0 l 30 0 30 20 0 20\")\n&gt;&gt;&gt; shape.move(-5, 10)\nm -5 10 l 25 10 25 30 -5 30\n</code></pre> Source code in <code>pyonfx/shape.py</code> <pre><code>def move(self, x: float, y: float) -&gt; \"Shape\":\n    \"\"\"Move the shape by the specified x and y offsets.\n\n    This method translates every point in the shape by adding the given x and y offsets to the corresponding coordinates.\n\n    Args:\n        x: The displacement along the x-axis.\n        y: The displacement along the y-axis.\n\n    Returns:\n        Shape: A new Shape instance with the coordinates moved by the specified offsets.\n\n    Examples:\n        &gt;&gt;&gt; shape = Shape(\"m 0 0 l 30 0 30 20 0 20\")\n        &gt;&gt;&gt; shape.move(-5, 10)\n        m -5 10 l 25 10 25 30 -5 30\n    \"\"\"\n    if x == 0 and y == 0:\n        return self\n\n    return self.map(lambda cx, cy: (cx + x, cy + y))\n</code></pre>"},{"location":"reference/shape/#pyonfx.shape.Shape.align","title":"<code>align(an=5, anchor=None)</code>","text":"<p>Align the shape based on a specified alignment code and pivot.</p> <p>This method adjusts the shape's position so that a chosen pivot inside the shape coincides with the position used for rendering (i.e., the \\pos point in ASS).</p> <p>Parameters:</p> Name Type Description Default <code>an</code> <code>int</code> <p>The alignment of the subtitle line (e.g., 1 through 9 corresponding to positions such as bottom-left, center, top-right, etc.).</p> <code>5</code> <code>anchor</code> <code>int | None</code> <p>The pivot inside the shape to be used for alignment. If not provided, defaults to the value of 'an'.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Shape</code> <code>Shape</code> <p>A new Shape instance with the shape aligned according to the specified parameters.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; shape = Shape(\"m 10 10 l 30 10 30 20 10 20\")\n&gt;&gt;&gt; shape.align()\nm 0 0 l 20 0 20 10 0 10\n</code></pre> Source code in <code>pyonfx/shape.py</code> <pre><code>def align(self, an: int = 5, anchor: int | None = None) -&gt; \"Shape\":\n    \"\"\"Align the shape based on a specified alignment code and pivot.\n\n    This method adjusts the shape's position so that a chosen pivot inside the shape\n    coincides with the position used for rendering (i.e., the \\\\pos point in ASS).\n\n    Args:\n        an: The alignment of the subtitle line (e.g., 1 through 9 corresponding to positions such as bottom-left, center, top-right, etc.).\n        anchor: The pivot inside the shape to be used for alignment. If not provided, defaults to the value of 'an'.\n\n    Returns:\n        Shape: A new Shape instance with the shape aligned according to the specified parameters.\n\n    Examples:\n        &gt;&gt;&gt; shape = Shape(\"m 10 10 l 30 10 30 20 10 20\")\n        &gt;&gt;&gt; shape.align()\n        m 0 0 l 20 0 20 10 0 10\n    \"\"\"\n    if anchor is None:\n        anchor = an\n\n    if an &lt; 1 or an &gt; 9:\n        raise ValueError(\"Alignment value must be an integer between 1 and 9\")\n\n    if anchor &lt; 1 or anchor &gt; 9:\n        raise ValueError(\"Anchor value must be an integer between 1 and 9\")\n\n    # Keypad decomposition (0: left / bottom, 1: centre, 2: right / top)\n    pivot_row, pivot_col = divmod(anchor - 1, 3)\n    line_row, line_col = divmod(an - 1, 3)\n\n    # Bounding boxes (exact vs. libass)\n    left, top, right, bottom = self.bounding(exact=True)\n    l_left, l_top, l_right, l_bottom = self.bounding(exact=False)\n\n    width, height = right - left, bottom - top\n\n    x_move = -left\n    y_move = -top\n\n    # Centre according to line alignment (libass corrections included)\n    if line_col == 0:  # left\n        x_move -= width / 2\n    elif line_col == 1:  # centre\n        x_move -= width / 2 - (l_right - l_left) / 2\n    elif line_col == 2:  # right\n        x_move += width / 2 - (width - (l_right - l_left))\n\n    if line_row == 0:  # bottom\n        y_move += height / 2 - (height - (l_bottom - l_top))\n    elif line_row == 1:  # middle\n        y_move -= height / 2 - (l_bottom - l_top) / 2\n    elif line_row == 2:  # top\n        y_move -= height / 2\n\n    # Finally shift so that requested pivot is the reference point\n    if pivot_col == 0:  # left\n        x_move += width / 2\n    elif pivot_col == 2:  # right\n        x_move -= width / 2\n\n    if pivot_row == 0:  # bottom\n        y_move -= height / 2\n    elif pivot_row == 2:  # top\n        y_move += height / 2\n\n    return self.move(x_move, y_move)\n</code></pre>"},{"location":"reference/shape/#pyonfx.shape.Shape.scale","title":"<code>scale(fscx=100, fscy=100, origin=(0.0, 0.0))</code>","text":"<p>Scale the shape by specified horizontal and vertical scale factors, optionally around a given origin.</p> <p>This method scales the shape's coordinates relative to a specified origin point, which serves as the pivot for the scaling transformation.</p> <p>Parameters:</p> Name Type Description Default <code>fscx</code> <code>float</code> <p>The horizontal scaling factor as a percentage (100 means no change).</p> <code>100</code> <code>fscy</code> <code>float</code> <p>The vertical scaling factor as a percentage (100 means no change).</p> <code>100</code> <code>origin</code> <code>tuple[float, float]</code> <p>The pivot point (x, y) around which scaling is performed. Default is (0.0, 0.0).</p> <code>(0.0, 0.0)</code> <p>Returns:</p> Name Type Description <code>Shape</code> <code>Shape</code> <p>A new Shape instance with the coordinates scaled accordingly.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; shape = Shape(\"m 0 50 l 0 0 50 0 50 50\")\n&gt;&gt;&gt; shape.scale(fscx=200)\nm 0 50 l 0 0 100 0 100 50\n</code></pre> Source code in <code>pyonfx/shape.py</code> <pre><code>def scale(\n    self,\n    fscx: float = 100,\n    fscy: float = 100,\n    origin: tuple[float, float] = (0.0, 0.0),\n) -&gt; \"Shape\":\n    \"\"\"Scale the shape by specified horizontal and vertical scale factors, optionally around a given origin.\n\n    This method scales the shape's coordinates relative to a specified origin point, which serves as the pivot for the scaling transformation.\n\n    Args:\n        fscx: The horizontal scaling factor as a percentage (100 means no change).\n        fscy: The vertical scaling factor as a percentage (100 means no change).\n        origin: The pivot point (x, y) around which scaling is performed. Default is (0.0, 0.0).\n\n    Returns:\n        Shape: A new Shape instance with the coordinates scaled accordingly.\n\n    Examples:\n        &gt;&gt;&gt; shape = Shape(\"m 0 50 l 0 0 50 0 50 50\")\n        &gt;&gt;&gt; shape.scale(fscx=200)\n        m 0 50 l 0 0 100 0 100 50\n    \"\"\"\n    if fscx == 100.0 and fscy == 100.0:\n        return self\n\n    scale_x = fscx / 100.0\n    scale_y = fscy / 100.0\n\n    ox, oy = origin\n\n    return self.map(lambda x, y: ((x - ox) * scale_x + ox, (y - oy) * scale_y + oy))\n</code></pre>"},{"location":"reference/shape/#pyonfx.shape.Shape.rotate","title":"<code>rotate(*, frx=0.0, fry=0.0, frz=0.0, origin=(0.0, 0.0))</code>","text":"<p>Rotate the shape by specified angles about given axes around a pivot point.</p> <p>This method applies rotation transformations to the shape's coordinates based on the provided angles for the x, y, and z axes, in degrees. The pivot point around which the rotation is applied is specified by the 'origin' parameter.</p> <p>Parameters:</p> Name Type Description Default <code>frx</code> <code>float</code> <p>The rotation angle around the x-axis (in degrees).</p> <code>0.0</code> <code>fry</code> <code>float</code> <p>The rotation angle around the y-axis (in degrees).</p> <code>0.0</code> <code>frz</code> <code>float</code> <p>The rotation angle around the z-axis (in degrees).</p> <code>0.0</code> <code>origin</code> <code>tuple[float, float]</code> <p>The pivot point (x, y) for the rotation.</p> <code>(0.0, 0.0)</code> <p>Returns:</p> Name Type Description <code>Shape</code> <code>Shape</code> <p>A new Shape instance with the coordinates rotated as specified.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; shape = Shape(\"m 0 0 l 30 0 30 20 0 20\")\n&gt;&gt;&gt; shape.rotate(frx=0, fry=0, frz=45, origin=(15,10))\nm -2.678 13.536 l 18.536 -7.678 32.678 6.464 11.464 27.678\n</code></pre> Notes <p>The rotation is applied in the order: X-axis, then Y-axis, then Z-axis.</p> Source code in <code>pyonfx/shape.py</code> <pre><code>def rotate(\n    self,\n    *,\n    frx: float = 0.0,\n    fry: float = 0.0,\n    frz: float = 0.0,\n    origin: tuple[float, float] = (0.0, 0.0),\n) -&gt; \"Shape\":\n    \"\"\"Rotate the shape by specified angles about given axes around a pivot point.\n\n    This method applies rotation transformations to the shape's coordinates based on the provided angles for the x, y, and z axes, in degrees.\n    The pivot point around which the rotation is applied is specified by the 'origin' parameter.\n\n    Args:\n        frx: The rotation angle around the x-axis (in degrees).\n        fry: The rotation angle around the y-axis (in degrees).\n        frz: The rotation angle around the z-axis (in degrees).\n        origin: The pivot point (x, y) for the rotation.\n\n    Returns:\n        Shape: A new Shape instance with the coordinates rotated as specified.\n\n    Examples:\n        &gt;&gt;&gt; shape = Shape(\"m 0 0 l 30 0 30 20 0 20\")\n        &gt;&gt;&gt; shape.rotate(frx=0, fry=0, frz=45, origin=(15,10))\n        m -2.678 13.536 l 18.536 -7.678 32.678 6.464 11.464 27.678\n\n    Notes:\n        The rotation is applied in the order: X-axis, then Y-axis, then Z-axis.\n    \"\"\"\n    if frx == 0 and fry == 0 and frz == 0:\n        return self\n\n    # Normalise the origin\n    ox, oy = origin\n\n    # Pre-compute sines/cosines\n    # (Mathematical convention is counter-clockwise, but ASS uses clockwise, *sigh*)\n    rx = math.radians(-frx)\n    ry = math.radians(-fry)\n    rz = math.radians(-frz)\n    cosx, sinx = math.cos(rx), math.sin(rx)\n    cosy, siny = math.cos(ry), math.sin(ry)\n    cosz, sinz = math.cos(rz), math.sin(rz)\n\n    def _transform(px: float, py: float) -&gt; tuple[float, float]:\n        # Translate to origin\n        x = px - ox\n        y = py - oy\n        z = 0.0\n\n        # Rotation around X (pitch)\n        y1 = y * cosx - z * sinx\n        z1 = y * sinx + z * cosx\n        x1 = x\n\n        # Rotation around Y (yaw)\n        x2 = x1 * cosy + z1 * siny\n        z2 = -x1 * siny + z1 * cosy\n        y2 = y1\n\n        # Rotation around Z (roll)\n        x3 = x2 * cosz - y2 * sinz\n        y3 = x2 * sinz + y2 * cosz\n        z3 = z2\n\n        # Translate back\n        return x3 + ox, y3 + oy\n\n    # Apply transformation to every point in the shape\n    return self.map(lambda x, y: _transform(x, y))\n</code></pre>"},{"location":"reference/shape/#pyonfx.shape.Shape.shear","title":"<code>shear(*, fax=0.0, fay=0.0, origin=(0.0, 0.0))</code>","text":"<p>Apply a shear transformation to the shape.</p> <p>This method deforms the shape by applying a shear transformation relative to a specified origin, which acts as the pivot.</p> <p>Parameters:</p> Name Type Description Default <code>fax</code> <code>float</code> <p>The horizontal shear factor. Positive values slant the top of the shape to the right, negative values slant to the left.</p> <code>0.0</code> <code>fay</code> <code>float</code> <p>The vertical shear factor. Positive values slant the right side of the shape downward, negative values slant upward.</p> <code>0.0</code> <code>origin</code> <code>tuple[float, float]</code> <p>The pivot point (x, y) for the shear transformation.</p> <code>(0.0, 0.0)</code> <p>Returns:</p> Name Type Description <code>Shape</code> <code>Shape</code> <p>A new Shape instance with the coordinates sheared accordingly.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; shape = Shape(\"m 0 0 l 30 0 30 20 0 20\")\n&gt;&gt;&gt; shape.shear(fax=0.5, fay=0, origin=(15,10))\nm -5 0 l 25 0 35 20 5 20\n</code></pre> Source code in <code>pyonfx/shape.py</code> <pre><code>def shear(\n    self,\n    *,\n    fax: float = 0.0,\n    fay: float = 0.0,\n    origin: tuple[float, float] = (0.0, 0.0),\n) -&gt; \"Shape\":\n    \"\"\"Apply a shear transformation to the shape.\n\n    This method deforms the shape by applying a shear transformation relative to a specified origin, which acts as the pivot.\n\n    Args:\n        fax: The horizontal shear factor. Positive values slant the top of the shape to the right, negative values slant to the left.\n        fay: The vertical shear factor. Positive values slant the right side of the shape downward, negative values slant upward.\n        origin: The pivot point (x, y) for the shear transformation.\n\n    Returns:\n        Shape: A new Shape instance with the coordinates sheared accordingly.\n\n    Examples:\n        &gt;&gt;&gt; shape = Shape(\"m 0 0 l 30 0 30 20 0 20\")\n        &gt;&gt;&gt; shape.shear(fax=0.5, fay=0, origin=(15,10))\n        m -5 0 l 25 0 35 20 5 20\n    \"\"\"\n    if fax == 0.0 and fay == 0.0:\n        return self\n\n    ox, oy = origin\n\n    def _shear(px: float, py: float) -&gt; tuple[float, float]:\n        # Translate to origin\n        x_rel = px - ox\n        y_rel = py - oy\n\n        # Apply shear matrix [[1, fax], [fay, 1]]\n        new_x_rel = x_rel + fax * y_rel\n        new_y_rel = fay * x_rel + y_rel\n\n        # Translate back\n        return new_x_rel + ox, new_y_rel + oy\n\n    return self.map(lambda x, y: _shear(x, y))\n</code></pre>"},{"location":"reference/shape/#pyonfx.shape.Shape.flatten","title":"<code>flatten(tolerance=1.0)</code>","text":"<p>Flatten the shape's B\u00e9zier curves into line segments.</p> <p>This method processes the shape by subdividing B\u00e9zier curves into multiple straight line segments. The subdivision is controlled by the tolerance parameter, which defines the threshold angle (in degrees) at which a curve is considered flat. This conversion is useful for operations that require linear segments, such as detailed transformations or morphing.</p> <p>Parameters:</p> Name Type Description Default <code>tolerance</code> <code>float</code> <p>The angle in degrees used to determine when a B\u00e9zier curve is flat enough to be approximated by a straight line. Higher values yield fewer segments and faster processing but lower accuracy.</p> <code>1.0</code> <p>Returns:</p> Name Type Description <code>Shape</code> <code>Shape</code> <p>A new Shape instance with the curves converted into line segments.</p> Notes <p>Flattening curves may significantly increase the number of points, which can impact performance for subsequent operations.</p> Source code in <code>pyonfx/shape.py</code> <pre><code>def flatten(self, tolerance: float = 1.0) -&gt; \"Shape\":\n    \"\"\"Flatten the shape's B\u00e9zier curves into line segments.\n\n    This method processes the shape by subdividing B\u00e9zier curves into multiple straight line segments.\n    The subdivision is controlled by the tolerance parameter, which defines the threshold angle (in degrees) at which a curve is considered flat.\n    This conversion is useful for operations that require linear segments, such as detailed transformations or morphing.\n\n    Args:\n        tolerance: The angle in degrees used to determine when a B\u00e9zier curve is flat enough to be approximated by a straight line. Higher values yield fewer segments and faster processing but lower accuracy.\n\n    Returns:\n        Shape: A new Shape instance with the curves converted into line segments.\n\n    Notes:\n        Flattening curves may significantly increase the number of points, which can impact performance for subsequent operations.\n    \"\"\"\n    if tolerance &lt; 0:\n        raise ValueError(\"Tolerance must be a positive number\")\n\n    # Convert tolerance to radians once to avoid repeated conversions\n    tolerance_rad = math.radians(tolerance)\n\n    def _subdivide_bezier(p0x, p0y, p1x, p1y, p2x, p2y, p3x, p3y, t=0.5):\n        \"\"\"De Casteljau subdivision of cubic bezier curve using raw coordinates.\"\"\"\n        # First level\n        q0x = p0x + t * (p1x - p0x)\n        q0y = p0y + t * (p1y - p0y)\n        q1x = p1x + t * (p2x - p1x)\n        q1y = p1y + t * (p2y - p1y)\n        q2x = p2x + t * (p3x - p2x)\n        q2y = p2y + t * (p3y - p2y)\n\n        # Second level\n        r0x = q0x + t * (q1x - q0x)\n        r0y = q0y + t * (q1y - q0y)\n        r1x = q1x + t * (q2x - q1x)\n        r1y = q1y + t * (q2y - q1y)\n\n        # Final point\n        sx = r0x + t * (r1x - r0x)\n        sy = r0y + t * (r1y - r0y)\n\n        return (\n            (p0x, p0y, q0x, q0y, r0x, r0y, sx, sy),\n            (sx, sy, r1x, r1y, q2x, q2y, p3x, p3y),\n        )\n\n    def _is_bezier_flat(p0x, p0y, p1x, p1y, p2x, p2y, p3x, p3y):\n        \"\"\"Check if bezier curve is flat enough based on angle tolerance.\"\"\"\n        points = [(p0x, p0y), (p1x, p1y), (p2x, p2y), (p3x, p3y)]\n\n        vectors = []\n        for i in range(1, len(points)):\n            dx = points[i][0] - points[i - 1][0]\n            dy = points[i][1] - points[i - 1][1]\n            if dx != 0 or dy != 0:\n                vectors.append((dx, dy))\n\n        if len(vectors) &lt; 2:\n            return True\n\n        # Check angle between consecutive vectors\n        for i in range(1, len(vectors)):\n            v1, v2 = vectors[i - 1], vectors[i]\n\n            angle = math.atan2(\n                v1[0] * v2[1] - v1[1] * v2[0], v1[0] * v2[0] + v1[1] * v2[1]\n            )\n\n            if abs(angle) &gt; tolerance_rad:\n                return False\n\n        return True\n\n    def _bezier_to_lines(p0, p1, p2, p3):\n        \"\"\"Convert bezier curve to line segments.\"\"\"\n        stack = [(p0.x, p0.y, p1.x, p1.y, p2.x, p2.y, p3.x, p3.y)]\n\n        line_points = []\n        while stack:\n            coords = stack.pop()\n\n            if _is_bezier_flat(*coords):\n                # End point\n                line_points.append(Point(coords[6], coords[7]))\n            else:\n                # Subdivide and add both halves to stack\n                left, right = _subdivide_bezier(*coords)\n                stack.append(right)  # Process right first (stack order)\n                stack.append(left)\n\n        return (\n            line_points[:-1] if line_points else []\n        )  # Exclude last to avoid duplication\n\n    # Process elements\n    flattened_elements = []\n    current_point = None\n\n    for element in self:\n        if element.command == \"b\":\n            if current_point is None:\n                raise ValueError(\"Bezier curve found without a starting point\")\n\n            # Convert bezier to line segments\n            p0 = current_point\n            p1, p2, p3 = element.coordinates\n\n            line_points = _bezier_to_lines(p0, p1, p2, p3)\n\n            # Add line segments\n            for point in line_points:\n                flattened_elements.append(ShapeElement(\"l\", [point]))\n\n            # Add final point\n            flattened_elements.append(ShapeElement(\"l\", [p3]))\n            current_point = p3\n\n        elif element.command == \"c\":\n            # Bezier curves are already converted to lines\n            pass\n\n        else:\n            # Keep other commands as-is and track current point\n            flattened_elements.append(element)\n            if element.coordinates:\n                current_point = element.coordinates[-1]\n\n    # Return shape with flattened elements\n    return Shape(elements=flattened_elements)\n</code></pre>"},{"location":"reference/shape/#pyonfx.shape.Shape.split","title":"<code>split(max_len=16, tolerance=1.0)</code>","text":"<p>Split the shape into smaller segments.</p> <p>This method first flattens any B\u00e9zier curves in the shape, then subdivides the resulting line segments so that no segment exceeds the specified maximum length. This process increases the number of points in the shape, which can be useful for detailed deformations or morphing.</p> <p>Parameters:</p> Name Type Description Default <code>max_len</code> <code>float</code> <p>The maximum allowed length for any line segment. Segments longer than this value will be subdivided.</p> <code>16</code> <code>tolerance</code> <code>float</code> <p>The tolerance angle in degrees used to flatten B\u00e9zier curves before splitting.</p> <code>1.0</code> <p>Returns:</p> Name Type Description <code>Shape</code> <code>Shape</code> <p>A new Shape instance with the split line segments.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; shape = Shape(\"m 0 50 l 0 0 50 0 50 50\")\n&gt;&gt;&gt; shape.split()\nm 0 50 l 0 48 0 32 0 16 0 0 2 0 18 0 34 0 50 0 50 2 50 18 50 34 50 50 48 50 32 50 16 50 0 50\n</code></pre> Source code in <code>pyonfx/shape.py</code> <pre><code>def split(self, max_len: float = 16, tolerance: float = 1.0) -&gt; \"Shape\":\n    \"\"\"Split the shape into smaller segments.\n\n    This method first flattens any B\u00e9zier curves in the shape, then subdivides the resulting line segments so that no segment exceeds the specified maximum length.\n    This process increases the number of points in the shape, which can be useful for detailed deformations or morphing.\n\n    Args:\n        max_len: The maximum allowed length for any line segment. Segments longer than this value will be subdivided.\n        tolerance: The tolerance angle in degrees used to flatten B\u00e9zier curves before splitting.\n\n    Returns:\n        Shape: A new Shape instance with the split line segments.\n\n    Examples:\n        &gt;&gt;&gt; shape = Shape(\"m 0 50 l 0 0 50 0 50 50\")\n        &gt;&gt;&gt; shape.split()\n        m 0 50 l 0 48 0 32 0 16 0 0 2 0 18 0 34 0 50 0 50 2 50 18 50 34 50 50 48 50 32 50 16 50 0 50\n    \"\"\"\n    if max_len &lt;= 0:\n        raise ValueError(\n            \"The length of segments must be a positive and non-zero value\"\n        )\n\n    def _split_line_segment(p1: Point, p2: Point) -&gt; list[Point]:\n        \"\"\"Split a line segment *p1\u2192p2* into shorter segments of length ``&lt;= max_len``\"\"\"\n        line = LineString([p1, p2])\n        distance = line.length\n\n        # If already short enough, just return the end point\n        if distance &lt;= max_len:\n            return [Point(p2.x, p2.y)]\n\n        # Split the line into segments of max_len, with possibly shorter first segment\n        segments: list[Point] = []\n        distance_rest = distance % max_len\n        cur_distance = distance_rest if distance_rest &gt; 0 else max_len\n\n        while cur_distance &lt;= distance:\n            point = line.interpolate(cur_distance)\n            segments.append(Point(point.x, point.y))\n            cur_distance += max_len\n\n        return segments\n\n    def _close_contour_if_needed(current_pt, first_move_pt):\n        \"\"\"Helper to close a contour by splitting the closing line if needed.\"\"\"\n        if current_pt is None or first_move_pt is None:\n            return []\n\n        if (current_pt.x, current_pt.y) == (first_move_pt.x, first_move_pt.y):\n            return []\n\n        closing_points = _split_line_segment(current_pt, first_move_pt)\n        return [ShapeElement(\"l\", [pt]) for pt in closing_points]\n\n    # First flatten the shape to convert bezier curves to lines\n    flattened_shape = Shape(self.drawing_cmds).flatten(tolerance)\n\n    # Process elements\n    split_elements = []\n    current_point = None\n    first_move_point = None\n\n    for element in flattened_shape:\n        if element.command == \"m\":\n            # Close previous contour if needed\n            split_elements.extend(\n                _close_contour_if_needed(current_point, first_move_point)\n            )\n\n            # Start new contour\n            split_elements.append(element)\n            current_point = element.coordinates[0]\n            first_move_point = current_point\n\n        elif element.command == \"l\":\n            if current_point is None:\n                raise ValueError(\"Line command found without a starting point\")\n\n            # Split the line segment\n            line_points = _split_line_segment(current_point, element.coordinates[0])\n\n            # Add each segment as a separate line element\n            for point in line_points:\n                split_elements.append(ShapeElement(\"l\", [point]))\n\n            # Update current point\n            current_point = (\n                line_points[-1] if line_points else element.coordinates[0]\n            )\n\n        elif element.command == \"c\":\n            # Close current contour\n            split_elements.extend(\n                _close_contour_if_needed(current_point, first_move_point)\n            )\n\n            # Reset state for next contour\n            current_point = None\n            first_move_point = None\n\n        else:\n            split_elements.append(element)\n            if element.coordinates:\n                current_point = element.coordinates[-1]\n\n    # Close the final contour if needed\n    split_elements.extend(_close_contour_if_needed(current_point, first_move_point))\n\n    # Update shape with split elements\n    return Shape(elements=split_elements)\n</code></pre>"},{"location":"reference/shape/#pyonfx.shape.Shape.buffer","title":"<code>buffer(dist_xy, dist_y=None, *, kind='border', join='round')</code>","text":"<p>Return a buffered version of the shape.</p> <p>It makes a thicker or thinner version of the original shape by adding or removing space around it, based on the distances you specify. The \"kind\" option decides if you get the whole new shape filled in or just the edge line.</p> <p>Parameters:</p> Name Type Description Default <code>dist_xy</code> <code>float</code> <p>Horizontal buffer distance. Positive values expand the shape, and negative values contract it.</p> required <code>dist_y</code> <code>float | None</code> <p>Vertical buffer distance. If None, the same value as dist_xy is used. The sign must match that of dist_xy.</p> <code>None</code> <code>kind</code> <code>Literal['fill', 'border']</code> <p>Determines whether to return the filled buffered geometry (\"fill\") or just the border (\"border\").</p> <code>'border'</code> <code>join</code> <code>Literal['round', 'bevel', 'mitre']</code> <p>The corner join style to use on buffered corners.</p> <code>'round'</code> <p>Returns:</p> Name Type Description <code>Shape</code> <code>Shape</code> <p>A new Shape instance representing the buffered shape.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; shape = Shape(\"m 0 0 l 100 0 100 50 0 50\")\n&gt;&gt;&gt; shape.buffer(5, kind=\"border\", join=\"round\")\nm -3.333 50 l -3.269 50.65 (...)\n</code></pre> Source code in <code>pyonfx/shape.py</code> <pre><code>def buffer(\n    self,\n    dist_xy: float,\n    dist_y: float | None = None,\n    *,\n    kind: Literal[\"fill\", \"border\"] = \"border\",\n    join: Literal[\"round\", \"bevel\", \"mitre\"] = \"round\",\n) -&gt; \"Shape\":\n    \"\"\"Return a buffered version of the shape.\n\n    It makes a thicker or thinner version of the original shape by adding or removing space around it, based on the distances you specify.\n    The \"kind\" option decides if you get the whole new shape filled in or just the edge line.\n\n    Args:\n        dist_xy: Horizontal buffer distance. Positive values expand the shape, and negative values contract it.\n        dist_y: Vertical buffer distance. If None, the same value as dist_xy is used. The sign must match that of dist_xy.\n        kind: Determines whether to return the filled buffered geometry (\"fill\") or just the border (\"border\").\n        join: The corner join style to use on buffered corners.\n\n    Returns:\n        Shape: A new Shape instance representing the buffered shape.\n\n    Examples:\n        &gt;&gt;&gt; shape = Shape(\"m 0 0 l 100 0 100 50 0 50\")\n        &gt;&gt;&gt; shape.buffer(5, kind=\"border\", join=\"round\")\n        m -3.333 50 l -3.269 50.65 (...)\n    \"\"\"\n    if join not in (\"round\", \"bevel\", \"mitre\"):\n        raise ValueError(\"join must be one of 'round', 'bevel', or 'mitre'\")\n    if kind not in (\"fill\", \"border\"):\n        raise ValueError(\"kind must be either 'fill' or 'border'\")\n    if dist_y is None:\n        dist_y = dist_xy\n    if dist_xy == 0 and dist_y == 0:\n        return Shape() if kind == \"border\" else self\n\n    # Validate signs: both distances must have the same sign (or be zero)\n    if dist_xy * dist_y &lt; 0:\n        raise ValueError(\"dist_xy and dist_y must have the same sign\")\n    sign = 1 if dist_xy &gt;= 0 else -1\n\n    # Build Shapely geometry\n    multipoly = self.to_multipolygon()\n\n    # Apply libass hack\n    _LIBASS_HACK = 2 / 3\n    dist_xy *= _LIBASS_HACK\n    dist_y *= _LIBASS_HACK\n\n    # Anisotropic scaling so that the buffer distance is uniform\n    width = max(abs(dist_xy), abs(dist_y))\n\n    _EPS = 1e-9  # Avoid division-by-zero\n    xscale = abs(dist_xy) / width if abs(dist_xy) &gt; 0 else _EPS\n    yscale = abs(dist_y) / width if abs(dist_y) &gt; 0 else _EPS\n\n    inv_xscale = 1.0 / xscale\n    inv_yscale = 1.0 / yscale\n    scaled_geom = affine_scale(\n        multipoly, xfact=inv_xscale, yfact=inv_yscale, origin=(0, 0)\n    )\n\n    # Apply buffer (positive \u21d2 outward, negative \u21d2 inward)\n    buffered_scaled = scaled_geom.buffer(\n        sign * width, join_style=getattr(JOIN_STYLE, join)\n    )\n\n    if kind == \"fill\":\n        # Grown/shrunk geometry\n        result_scaled = buffered_scaled\n    else:\n        if sign &gt; 0:\n            # External border: grow and subtract original\n            result_scaled = buffered_scaled.difference(scaled_geom)\n        else:\n            # Internal border: shrink original and subtract new interior\n            result_scaled = scaled_geom.difference(buffered_scaled)\n\n    # Scale back to the original coordinate system\n    result_geom = affine_scale(\n        result_scaled, xfact=xscale, yfact=yscale, origin=(0, 0)\n    )\n\n    # Craft MultiPolygon\n    if isinstance(result_geom, MultiPolygon):\n        mp = result_geom\n    elif isinstance(result_geom, Polygon):\n        mp = MultiPolygon([result_geom])\n    else:\n        raise ValueError(f\"Invalid stroke geometry type: {type(result_geom)}\")\n\n    # Convert back to Shape\n    return Shape.from_multipolygon(mp)\n</code></pre>"},{"location":"reference/shape/#pyonfx.shape.Shape.morph","title":"<code>morph(target, t, max_len=16.0, tolerance=1.0, min_point_spacing=0.5, w_dist=0.55, w_area=0.35, w_overlap=0.1, cost_threshold=2.5, ensure_shell_pairs=True)</code>","text":"<p>Interpolate the current shape toward a target shape.</p> <p>This method computes an intermediate shape by morphing the current shape into a target shape based on an interpolation factor t (where 0 corresponds to the source shape and 1 corresponds to the target shape). The morph is performed by decomposing both shapes into closed ring segments and matching corresponding rings based on spatial properties. Matched rings are linearly interpolated, and unmatched rings are processed to appear or disappear gradually.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>Shape</code> <p>The target shape to morph into.</p> required <code>t</code> <code>float</code> <p>Interpolation factor between 0 and 1, where 0 returns the original shape and 1 returns the target shape.</p> required <code>max_len</code> <code>float</code> <p>The maximum allowed length for any line segment when splitting curves before morphing.</p> <code>16.0</code> <code>tolerance</code> <code>float</code> <p>The tolerance angle in degrees used when flattening curves.</p> <code>1.0</code> <code>min_point_spacing</code> <code>float</code> <p>Per-axis spacing threshold - a vertex is kept only if both <code>|\u0394x|</code> and <code>|\u0394y|</code> from the previous vertex are \u2265 this value (increasing it will boost performance during reproduction, but lower accuracy).</p> <code>0.5</code> <code>w_dist</code> <code>float</code> <p>Weight for the centroid-distance term (higher values make proximity more important).</p> <code>0.55</code> <code>w_area</code> <code>float</code> <p>Weight for the relative area-difference term (higher values make size similarity more important).</p> <code>0.35</code> <code>w_overlap</code> <code>float</code> <p>Weight for the overlap / IoU term that penalises pairs with little spatial intersection.</p> <code>0.1</code> <code>cost_threshold</code> <code>float</code> <p>Maximum acceptable cost for a pairing. Pairs whose cost is above this threshold are treated as unmatched and will grow/shrink to the closest centroid.</p> <code>2.5</code> <code>ensure_shell_pairs</code> <code>bool</code> <p>If <code>True</code>, shell rings that would otherwise remain unmatched will be force-paired with the shell that yields the minimum cost. This guarantees that every visible contour morphs into something, at the price of allowing the same shell to be reused multiple times.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>Shape</code> <code>Shape</code> <p>A new Shape instance representing the intermediate morph state.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; source = Shape(\"m 0 0 l 100 0 100 100 0 100 c\")\n&gt;&gt;&gt; target = Shape(\"m 50 50 l 150 50 150 150 50 150 c\")\n&gt;&gt;&gt; morph = source.morph(target, t=0.5)\n</code></pre> Source code in <code>pyonfx/shape.py</code> <pre><code>def morph(\n    self,\n    target: \"Shape\",\n    t: float,\n    max_len: float = 16.0,\n    tolerance: float = 1.0,\n    min_point_spacing: float = 0.5,\n    w_dist: float = 0.55,\n    w_area: float = 0.35,\n    w_overlap: float = 0.1,\n    cost_threshold: float = 2.5,\n    ensure_shell_pairs: bool = True,\n) -&gt; \"Shape\":\n    \"\"\"Interpolate the current shape toward a target shape.\n\n    This method computes an intermediate shape by morphing the current shape into a target shape based on an interpolation factor t (where 0 corresponds to the source shape and 1 corresponds to the target shape).\n    The morph is performed by decomposing both shapes into closed ring segments and matching corresponding rings based on spatial properties. Matched rings are linearly interpolated, and unmatched rings are processed to appear or disappear gradually.\n\n    Args:\n        target: The target shape to morph into.\n        t: Interpolation factor between 0 and 1, where 0 returns the original shape and 1 returns the target shape.\n        max_len: The maximum allowed length for any line segment when splitting curves before morphing.\n        tolerance: The tolerance angle in degrees used when flattening curves.\n        min_point_spacing: Per-axis spacing threshold - a vertex is kept only if both `|\u0394x|` and `|\u0394y|` from the previous vertex are \u2265 this value (increasing it will boost performance during reproduction, but lower accuracy).\n        w_dist: Weight for the centroid-distance term (higher values make proximity more important).\n        w_area: Weight for the relative area-difference term (higher values make size similarity more important).\n        w_overlap: Weight for the overlap / IoU term that penalises pairs with little spatial intersection.\n        cost_threshold: Maximum acceptable cost for a pairing. Pairs whose cost is above this threshold are treated as unmatched and will grow/shrink to the closest centroid.\n        ensure_shell_pairs: If `True`, shell rings that would otherwise remain unmatched will be force-paired with the shell that yields the minimum cost. This guarantees that every visible contour morphs into something, at the price of allowing the same shell to be reused multiple times.\n\n    Returns:\n        Shape: A new Shape instance representing the intermediate morph state.\n\n    Examples:\n        &gt;&gt;&gt; source = Shape(\"m 0 0 l 100 0 100 100 0 100 c\")\n        &gt;&gt;&gt; target = Shape(\"m 50 50 l 150 50 150 150 50 150 c\")\n        &gt;&gt;&gt; morph = source.morph(target, t=0.5)\n    \"\"\"\n\n    # Fast-path validations\n    if not isinstance(target, Shape):\n        raise TypeError(\"Target must be a Shape instance\")\n    if not 0 &lt;= t &lt;= 1:\n        raise ValueError(\"t must be between 0 and 1\")\n    if t == 0:\n        return self\n    if t == 1:\n        return target\n\n    # Use the multi-shape morphing routine to get intermediate geometries.\n    morphs = Shape.morph_multi(\n        {\"_\": self},\n        {\"_\": target},\n        t,\n        max_len=max_len,\n        tolerance=tolerance,\n        min_point_spacing=min_point_spacing,\n        w_dist=w_dist,\n        w_area=w_area,\n        w_overlap=w_overlap,\n        cost_threshold=cost_threshold,\n        ensure_shell_pairs=ensure_shell_pairs,\n    )\n\n    shapes = list(morphs.values())\n    combined_shape = shapes[0]\n    for shape in shapes[1:]:\n        combined_shape = combined_shape.boolean(\n            shape,\n            op=\"union\",\n            tolerance=tolerance,\n            min_point_spacing=min_point_spacing,\n        )\n\n    return combined_shape\n</code></pre>"},{"location":"reference/shape/#pyonfx.shape.Shape.morph_multi","title":"<code>morph_multi(src_shapes, tgt_shapes, t, *, max_len=16.0, tolerance=1.0, min_point_spacing=0.5, w_dist=0.55, w_area=0.35, w_overlap=0.1, cost_threshold=2.5, ensure_shell_pairs=True)</code>  <code>staticmethod</code>","text":"<p>Interpolate multiple shapes simultaneously.</p> <p>This class method performs a multi-shape morphing operation by interpolating between collections of source and target shapes. It decomposes each shape into rings, matches corresponding rings across the source and target collections based on spatial relationships, and computes intermediate shapes at a given interpolation factor t. The output is a dictionary mapping source-target identifier tuples to the resulting interpolated Shape.</p> <p>Parameters:</p> Name Type Description Default <code>src_shapes</code> <code>dict[str, Shape]</code> <p>A dictionary mapping source shape identifiers to their corresponding Shape instances.</p> required <code>tgt_shapes</code> <code>dict[str, Shape]</code> <p>A dictionary mapping target shape identifiers to their corresponding Shape instances.</p> required <code>t</code> <code>float</code> <p>Interpolation factor between 0 and 1. A value of 0 returns the source shapes and 1 returns the target shapes.</p> required <code>max_len</code> <code>float</code> <p>Maximum allowed length for any line segment after splitting curves.</p> <code>16.0</code> <code>tolerance</code> <code>float</code> <p>The tolerance angle in degrees used when flattening curves.</p> <code>1.0</code> <code>min_point_spacing</code> <code>float</code> <p>Per-axis spacing threshold - a vertex is kept only if both <code>|\u0394x|</code> and <code>|\u0394y|</code> from the previous vertex are \u2265 this value (increasing it will boost performance during reproduction, but lower accuracy).</p> <code>0.5</code> <code>w_dist</code> <code>float</code> <p>Weight for the centroid-distance term (higher values make proximity more important).</p> <code>0.55</code> <code>w_area</code> <code>float</code> <p>Weight for the relative area-difference term (higher values make size similarity more important).</p> <code>0.35</code> <code>w_overlap</code> <code>float</code> <p>Weight for the overlap / IoU term that penalises pairs with little spatial intersection.</p> <code>0.1</code> <code>cost_threshold</code> <code>float</code> <p>Maximum acceptable cost for a pairing. Pairs whose cost is above this threshold are treated as unmatched and will grow/shrink to the closest centroid.</p> <code>2.5</code> <code>ensure_shell_pairs</code> <code>bool</code> <p>If <code>True</code>, shell rings that would otherwise remain unmatched will be force-paired with the shell that yields the minimum cost. This guarantees that every visible contour morphs into something, at the price of allowing the same shell to be reused multiple times.</p> <code>True</code> <p>Returns:</p> Type Description <code>dict[tuple[str | None, str | None], Shape]</code> <p>dict[tuple[str | None, str | None], Shape]: A dictionary mapping tuples of source and target identifiers to the corresponding interpolated Shape. A source identifier of None indicates an appearing shape, while a target identifier of None indicates a disappearing shape.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; src = { 'A': Shape.star(5, 20, 40), 'B': Shape.ellipse(50, 30).move(100, 0) }\n&gt;&gt;&gt; tgt = { 'X': Shape.polygon(6, 45) }\n&gt;&gt;&gt; morphs = Shape.morph_multi(src, tgt, t=0.5)\n&gt;&gt;&gt; for (src_id, tgt_id), shape in morphs.items():\n...     print(f\"{src_id} -&gt; {tgt_id}: {shape}\")\n</code></pre> Source code in <code>pyonfx/shape.py</code> <pre><code>@staticmethod\ndef morph_multi(\n    src_shapes: dict[str, \"Shape\"],\n    tgt_shapes: dict[str, \"Shape\"],\n    t: float,\n    *,\n    max_len: float = 16.0,\n    tolerance: float = 1.0,\n    min_point_spacing: float = 0.5,\n    w_dist: float = 0.55,\n    w_area: float = 0.35,\n    w_overlap: float = 0.1,\n    cost_threshold: float = 2.5,\n    ensure_shell_pairs: bool = True,\n) -&gt; dict[tuple[str | None, str | None], \"Shape\"]:\n    \"\"\"Interpolate multiple shapes simultaneously.\n\n    This class method performs a multi-shape morphing operation by interpolating between collections of source and target shapes.\n    It decomposes each shape into rings, matches corresponding rings across the source and target collections based on spatial relationships, and computes intermediate shapes at a given interpolation factor t.\n    The output is a dictionary mapping source-target identifier tuples to the resulting interpolated Shape.\n\n    Args:\n        src_shapes: A dictionary mapping source shape identifiers to their corresponding Shape instances.\n        tgt_shapes: A dictionary mapping target shape identifiers to their corresponding Shape instances.\n        t: Interpolation factor between 0 and 1. A value of 0 returns the source shapes and 1 returns the target shapes.\n        max_len: Maximum allowed length for any line segment after splitting curves.\n        tolerance: The tolerance angle in degrees used when flattening curves.\n        min_point_spacing: Per-axis spacing threshold - a vertex is kept only if both `|\u0394x|` and `|\u0394y|` from the previous vertex are \u2265 this value (increasing it will boost performance during reproduction, but lower accuracy).\n        w_dist: Weight for the centroid-distance term (higher values make proximity more important).\n        w_area: Weight for the relative area-difference term (higher values make size similarity more important).\n        w_overlap: Weight for the overlap / IoU term that penalises pairs with little spatial intersection.\n        cost_threshold: Maximum acceptable cost for a pairing. Pairs whose cost is above this threshold are treated as unmatched and will grow/shrink to the closest centroid.\n        ensure_shell_pairs: If `True`, shell rings that would otherwise remain unmatched will be force-paired with the shell that yields the minimum cost. This guarantees that every visible contour morphs into something, at the price of allowing the same shell to be reused multiple times.\n\n    Returns:\n        dict[tuple[str | None, str | None], Shape]: A dictionary mapping tuples of source and target identifiers to the corresponding interpolated Shape. A source identifier of None indicates an appearing shape, while a target identifier of None indicates a disappearing shape.\n\n    Examples:\n        &gt;&gt;&gt; src = { 'A': Shape.star(5, 20, 40), 'B': Shape.ellipse(50, 30).move(100, 0) }\n        &gt;&gt;&gt; tgt = { 'X': Shape.polygon(6, 45) }\n        &gt;&gt;&gt; morphs = Shape.morph_multi(src, tgt, t=0.5)\n        &gt;&gt;&gt; for (src_id, tgt_id), shape in morphs.items():\n        ...     print(f\"{src_id} -&gt; {tgt_id}: {shape}\")\n    \"\"\"\n    # Basic validation\n    if not 0 &lt;= t &lt;= 1:\n        raise ValueError(\"t must be between 0 and 1\")\n    if any(not isinstance(s, Shape) for s in src_shapes.values()):\n        raise TypeError(\"All src_shapes values must be Shape instances\")\n    if any(not isinstance(s, Shape) for s in tgt_shapes.values()):\n        raise TypeError(\"All tgt_shapes values must be Shape instances\")\n\n    # Fast-paths\n    if t == 0:\n        return {(k, None): v for k, v in src_shapes.items()}\n    if t == 1:\n        return {(None, k): v for k, v in tgt_shapes.items()}\n\n    def _morph_transition(\n        ring: LinearRing,\n        ref_pt: Point,\n        t: float,\n        appearing: bool,\n    ) -&gt; LinearRing:\n        \"\"\"Morphism helper shared by *appearing* and *disappearing* rings.\"\"\"\n        if (t == 0 and not appearing) or (t == 1 and appearing):\n            return ring\n\n        coords = np.asarray(ring.coords[:-1], dtype=float)\n\n        if appearing:\n            # Grow *ring* from *ref_pt*\n            origin = np.array([ref_pt.x, ref_pt.y])\n            new_coords = origin + (coords - origin) * t\n        else:\n            # Shrink *ring* towards *ref_pt*\n            centroid = np.array(ring.centroid.coords[0])\n            dest = np.array([ref_pt.x, ref_pt.y])\n            new_coords = (\n                centroid + (coords - centroid) * (1 - t) + (dest - centroid) * t\n            )\n\n        new_coords = np.vstack([new_coords, new_coords[0]])  # close ring\n        return LinearRing(new_coords)\n\n    def _interpolate_rings(\n        src_ring: LinearRing, tgt_ring: LinearRing, t: float\n    ) -&gt; LinearRing:\n        \"\"\"Linear interpolation between two rings with optimal vertex correspondence.\"\"\"\n        if t == 0:\n            return src_ring\n        if t == 1:\n            return tgt_ring\n        if len(src_ring.coords) != len(tgt_ring.coords):\n            raise ValueError(\n                \"Rings must have the same number of vertices: \"\n                f\"{len(src_ring.coords)} != {len(tgt_ring.coords)}\"\n            )\n\n        src_coords = np.asarray(src_ring.coords[:-1], dtype=float)\n        tgt_coords = np.asarray(tgt_ring.coords[:-1], dtype=float)\n\n        # Ensure orientation consistency\n        if src_ring.is_ccw != tgt_ring.is_ccw:\n            tgt_coords = tgt_coords[::-1]\n\n        # Find optimal alignment by minimizing total vertex distances\n        n_vertices = len(src_coords)\n        min_total_distance = float(\"inf\")\n        best_shift = 0\n\n        # Try all possible rotations and find the one with minimum total distance\n        for shift in range(n_vertices):\n            shifted_tgt = np.roll(tgt_coords, -shift, axis=0)\n            total_distance = np.sum(\n                np.linalg.norm(src_coords - shifted_tgt, axis=1)\n            )\n\n            if total_distance &lt; min_total_distance:\n                min_total_distance = total_distance\n                best_shift = shift\n\n        # Apply the best alignment\n        if best_shift &gt; 0:\n            tgt_coords = np.roll(tgt_coords, -best_shift, axis=0)\n\n        # Perform linear interpolation between corresponding vertices\n        interp_coords = (1 - t) * src_coords + t * tgt_coords\n\n        # Close the ring\n        interp_coords = np.vstack([interp_coords, interp_coords[0]])\n        return LinearRing(interp_coords)\n\n    def _rings_to_multipolygon(\n        rings: list[tuple[LinearRing, bool]],\n    ) -&gt; MultiPolygon:\n        \"\"\"Convert a collection of `(ring, is_hole)` tuples to a `MultiPolygon`.\"\"\"\n\n        # Gather polygons (shells and holes)\n        shell_polys: list[Polygon] = []\n        hole_polys: list[Polygon] = []\n\n        for lr, is_hole in rings:\n            poly = Polygon(lr).buffer(0)\n            if poly.is_empty or not poly.is_valid:\n                continue\n            (hole_polys if is_hole else shell_polys).append(poly)\n\n        # Union the shells and holes\n        shell_union = unary_union(shell_polys) if shell_polys else None\n        hole_union = unary_union(hole_polys) if hole_polys else None\n\n        # Subtract the holes from the shells (if any)\n        if shell_union and hole_union:\n            combined = shell_union.difference(hole_union)\n        elif shell_union:\n            combined = shell_union\n        elif hole_union:\n            combined = hole_union\n        else:\n            return MultiPolygon()\n\n        if isinstance(combined, MultiPolygon):\n            return combined\n        elif isinstance(combined, Polygon):\n            return MultiPolygon([combined])\n        else:\n            raise ValueError(\"Combined geometry is not a Polygon or MultiPolygon\")\n\n    # 1) Retrieve pairing &amp; resampling information (cached)\n    src_cmds = tuple(sorted((k, s.drawing_cmds) for k, s in src_shapes.items()))\n    dst_cmds = tuple(sorted((k, s.drawing_cmds) for k, s in tgt_shapes.items()))\n\n    paired, src_unmatched, tgt_unmatched = Shape._prepare_morph(\n        src_cmds,\n        dst_cmds,\n        max_len,\n        tolerance,\n        w_dist,\n        w_area,\n        w_overlap,\n        cost_threshold,\n        ensure_shell_pairs,\n    )\n\n    # 2) Interpolate matched rings\n    result_rings: list[tuple[LinearRing, bool, str | None, str | None]] = [\n        (_interpolate_rings(src, tgt, t), is_hole, src_id, tgt_id)\n        for src, tgt, is_hole, src_id, tgt_id in paired\n    ]\n\n    # 3) Handle disappearing / appearing rings\n    for ring, dest_pt, is_hole, src_id in src_unmatched:\n        result_rings.append(\n            (\n                _morph_transition(ring, dest_pt, t, appearing=False),\n                is_hole,\n                src_id,\n                None,\n            )\n        )\n    for ring, origin_pt, is_hole, tgt_id in tgt_unmatched:\n        result_rings.append(\n            (\n                _morph_transition(ring, origin_pt, t, appearing=True),\n                is_hole,\n                None,\n                tgt_id,\n            )\n        )\n\n    # 4) Group by (shape_id, target_id)\n    #    Holes coming from / going to *None* (i.e. appearing/disappearing) must be\n    #    subtracted from *every* shape \u2013 they are collected in `global_holes` and\n    #    later injected into every flow.\n\n    global_holes: list[tuple[LinearRing, bool]] = []  # always [(ring, True)]\n    flows: dict[tuple[str | None, str | None], list[tuple[LinearRing, bool]]] = {}\n\n    for ring, is_hole, src_id, tgt_id in result_rings:\n        # If the ring is a hole and one side of the morph is missing, treat it as\n        # a *global* hole that has to be removed from every resulting geometry.\n        if is_hole and (src_id is None or tgt_id is None):\n            global_holes.append((ring, True))\n            continue\n\n        flows.setdefault((src_id, tgt_id), []).append((ring, is_hole))\n\n    # Inject global holes into every shape flow so they are diffed out.\n    if global_holes:\n        for ring_list in flows.values():\n            ring_list.extend(global_holes)\n\n    # 5) Convert back to Shape and return as dictionary\n    result: dict[tuple[str | None, str | None], Shape] = {}\n    for (src_id, tgt_id), ring_list in flows.items():\n        mp = _rings_to_multipolygon(ring_list)\n        result[(src_id, tgt_id)] = Shape.from_multipolygon(mp, min_point_spacing)\n    return result\n</code></pre>"},{"location":"reference/shape/#pyonfx.shape.Shape.triangle","title":"<code>triangle(width, height)</code>  <code>classmethod</code>","text":"<p>Creates a triangle centered at the origin with the specified width and height.</p> <p>The triangle is defined by three vertices: - Top vertex at (0, height/2). - Bottom-left vertex at (-width/2, -height/2). - Bottom-right vertex at (width/2, -height/2).</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>float</code> <p>The width of the triangle base (must be positive).</p> required <code>height</code> <code>float</code> <p>The height of the triangle (must be positive).</p> required <p>Returns:</p> Name Type Description <code>Shape</code> <code>Shape</code> <p>A new Shape instance representing the triangle.</p> Source code in <code>pyonfx/shape.py</code> <pre><code>@classmethod\ndef triangle(cls, width: float, height: float) -&gt; \"Shape\":\n    \"\"\"Creates a triangle centered at the origin with the specified width and height.\n\n    The triangle is defined by three vertices:\n    - Top vertex at (0, height/2).\n    - Bottom-left vertex at (-width/2, -height/2).\n    - Bottom-right vertex at (width/2, -height/2).\n\n    Args:\n        width: The width of the triangle base (must be positive).\n        height: The height of the triangle (must be positive).\n\n    Returns:\n        Shape: A new Shape instance representing the triangle.\n    \"\"\"\n    if width &lt;= 0 or height &lt;= 0:\n        raise ValueError(\"Width and height must be positive\")\n\n    # Calculate vertices\n    half_w = width / 2\n    half_h = height / 2\n    vertices = [\n        (0, half_h),  # Top vertex\n        (-half_w, -half_h),  # Bottom-left vertex\n        (half_w, -half_h),  # Bottom-right vertex\n    ]\n\n    # Build ASS path command\n    f = cls.format_value\n    path_parts = [f\"m {f(vertices[0][0])} {f(vertices[0][1])}\"]\n\n    for vertex in vertices[1:]:\n        path_parts.append(f\"l {f(vertex[0])} {f(vertex[1])}\")\n\n    return cls(\" \".join(path_parts)).align()\n</code></pre>"},{"location":"reference/shape/#pyonfx.shape.Shape.rectangle","title":"<code>rectangle(width, height)</code>  <code>classmethod</code>","text":"<p>Creates a rectangle shape with the specified width and height.</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>float</code> <p>The width of the rectangle (must be positive).</p> required <code>height</code> <code>float</code> <p>The height of the rectangle (must be positive).</p> required <p>Returns:</p> Name Type Description <code>Shape</code> <code>Shape</code> <p>A new Shape instance representing the rectangle.</p> Source code in <code>pyonfx/shape.py</code> <pre><code>@classmethod\ndef rectangle(cls, width: float, height: float) -&gt; \"Shape\":\n    \"\"\"Creates a rectangle shape with the specified width and height.\n\n    Args:\n        width: The width of the rectangle (must be positive).\n        height: The height of the rectangle (must be positive).\n\n    Returns:\n        Shape: A new Shape instance representing the rectangle.\n    \"\"\"\n    if width &lt;= 0 or height &lt;= 0:\n        raise ValueError(\"Width and height must be positive\")\n\n    f = cls.format_value\n    return cls(\n        \"m 0 0 l %s 0 %s %s 0 %s 0 0\" % (f(width), f(width), f(height), f(height))\n    )\n</code></pre>"},{"location":"reference/shape/#pyonfx.shape.Shape.square","title":"<code>square(size)</code>  <code>classmethod</code>","text":"<p>Creates a square shape with the given side length.</p> <p>Parameters:</p> Name Type Description Default <code>size</code> <code>float</code> <p>The side length of the square (must be positive).</p> required <p>Returns:</p> Name Type Description <code>Shape</code> <code>Shape</code> <p>A new Shape instance representing the square.</p> Source code in <code>pyonfx/shape.py</code> <pre><code>@classmethod\ndef square(cls, size: float) -&gt; \"Shape\":\n    \"\"\"Creates a square shape with the given side length.\n\n    Args:\n        size: The side length of the square (must be positive).\n\n    Returns:\n        Shape: A new Shape instance representing the square.\n    \"\"\"\n    return cls.rectangle(size, size)\n</code></pre>"},{"location":"reference/shape/#pyonfx.shape.Shape.rounded_rectangle","title":"<code>rounded_rectangle(width, height, radius)</code>  <code>classmethod</code>","text":"<p>Creates a rounded rectangle shape.</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>float</code> <p>Rectangle width in pixels (must be positive).</p> required <code>height</code> <code>float</code> <p>Rectangle height in pixels (must be positive).</p> required <code>radius</code> <code>float</code> <p>Corner radius in pixels (must be &lt;= min(width/2, height/2)).</p> required <p>Returns:</p> Name Type Description <code>Shape</code> <code>Shape</code> <p>A rounded rectangle with origin at top-left (0,0), extending to (width, height).</p> Source code in <code>pyonfx/shape.py</code> <pre><code>@classmethod\ndef rounded_rectangle(cls, width: float, height: float, radius: float) -&gt; \"Shape\":\n    \"\"\"Creates a rounded rectangle shape.\n\n    Args:\n        width: Rectangle width in pixels (must be positive).\n        height: Rectangle height in pixels (must be positive).\n        radius: Corner radius in pixels (must be &lt;= min(width/2, height/2)).\n\n    Returns:\n        Shape: A rounded rectangle with origin at top-left (0,0), extending to (width, height).\n    \"\"\"\n    if width &lt;= 0 or height &lt;= 0:\n        raise ValueError(\"Width and height must be positive\")\n    if radius &lt; 0:\n        raise ValueError(\"Radius must be non-negative\")\n    if radius &gt; min(width / 2, height / 2):\n        raise ValueError(\"Radius is too large for the given dimensions\")\n\n    f = cls.format_value\n    k = 0.5522847498 * radius  # Bezier approximation constant\n    w, h, r = width, height, radius\n\n    # Each tuple: (line_end_x, line_end_y, bezier_c1x, c1y, c2x, c2y, end_x, end_y)\n    segments = [\n        (w - r, 0, w - r + k, 0, w, k, w, r),  # Top edge + top-right corner\n        (\n            w,\n            h - r,\n            w,\n            h - r + k,\n            w - k,\n            h,\n            w - r,\n            h,\n        ),  # Right edge + bottom-right corner\n        (r, h, r - k, h, 0, h - k, 0, h - r),  # Bottom edge + bottom-left corner\n        (0, r, 0, r - k, k, 0, r, 0),  # Left edge + top-left corner\n    ]\n\n    cmd = [f\"m {f(r)} {f(0)}\"]\n    for lx, ly, c1x, c1y, c2x, c2y, ex, ey in segments:\n        cmd.extend(\n            [\n                f\"l {f(lx)} {f(ly)}\",\n                f\"b {f(c1x)} {f(c1y)} {f(c2x)} {f(c2y)} {f(ex)} {f(ey)}\",\n            ]\n        )\n\n    return cls(\" \".join(cmd))\n</code></pre>"},{"location":"reference/shape/#pyonfx.shape.Shape.polygon","title":"<code>polygon(edges, side_length)</code>  <code>classmethod</code>","text":"<p>Creates a regular n-sided polygon shape.</p> <p>Parameters:</p> Name Type Description Default <code>edges</code> <code>int</code> <p>Number of sides for the polygon (must be at least 3).</p> required <code>side_length</code> <code>float</code> <p>The length of each side (must be positive).</p> required <p>Returns:</p> Name Type Description <code>Shape</code> <code>Shape</code> <p>A Shape object representing the polygon.</p> Source code in <code>pyonfx/shape.py</code> <pre><code>@classmethod\ndef polygon(cls, edges: int, side_length: float) -&gt; \"Shape\":\n    \"\"\"Creates a regular n-sided polygon shape.\n\n    Args:\n        edges: Number of sides for the polygon (must be at least 3).\n        side_length: The length of each side (must be positive).\n\n    Returns:\n        Shape: A Shape object representing the polygon.\n    \"\"\"\n    if edges &lt; 3:\n        raise ValueError(\"Edges must be \u2265 3\")\n    if side_length &lt;= 0:\n        raise ValueError(\"Side length must be positive\")\n\n    # Calculate circumradius from side length\n    radius = side_length / (2 * math.sin(math.pi / edges))\n\n    f = cls.format_value\n    pts = []\n    # Rotate to get a more natural orientation (flat bottom when possible)\n    angle_offset = math.pi / 2 + math.pi / edges\n\n    for i in range(edges):\n        angle = 2 * math.pi * i / edges + angle_offset\n        x = radius * math.cos(angle)\n        y = radius * math.sin(angle)\n        pts.append((f(x), f(y)))\n\n    cmd_parts = [f\"m {pts[0][0]} {pts[0][1]} l\"]\n    cmd_parts.extend(f\"{x} {y}\" for x, y in pts[1:])\n    return cls(\" \".join(cmd_parts)).align()\n</code></pre>"},{"location":"reference/shape/#pyonfx.shape.Shape.ellipse","title":"<code>ellipse(w, h)</code>  <code>classmethod</code>","text":"<p>Creates an ellipse shape centered at the origin.</p> <p>Parameters:</p> Name Type Description Default <code>w</code> <code>float</code> <p>The width of the ellipse.</p> required <code>h</code> <code>float</code> <p>The height of the ellipse.</p> required <p>Returns:</p> Name Type Description <code>Shape</code> <code>Shape</code> <p>A Shape object representing the ellipse.</p> Source code in <code>pyonfx/shape.py</code> <pre><code>@classmethod\ndef ellipse(cls, w: float, h: float) -&gt; \"Shape\":\n    \"\"\"Creates an ellipse shape centered at the origin.\n\n    Args:\n        w: The width of the ellipse.\n        h: The height of the ellipse.\n\n    Returns:\n        Shape: A Shape object representing the ellipse.\n    \"\"\"\n    try:\n        w2, h2 = w / 2, h / 2\n    except TypeError:\n        raise TypeError(\"Number(s) expected\")\n\n    f = cls.format_value\n\n    return cls(\n        \"m 0 %s \"\n        \"b 0 %s 0 0 %s 0 \"\n        \"%s 0 %s 0 %s %s \"\n        \"%s %s %s %s %s %s \"\n        \"%s %s 0 %s 0 %s\"\n        % (\n            f(h2),  # move\n            f(h2),\n            f(w2),  # curve 1\n            f(w2),\n            f(w),\n            f(w),\n            f(h2),  # curve 2\n            f(w),\n            f(h2),\n            f(w),\n            f(h),\n            f(w2),\n            f(h),  # curve 3\n            f(w2),\n            f(h),\n            f(h),\n            f(h2),  # curve 4\n        )\n    )\n</code></pre>"},{"location":"reference/shape/#pyonfx.shape.Shape.circle","title":"<code>circle(radius)</code>  <code>classmethod</code>","text":"<p>Creates a circle shape with the given radius.</p> <p>Parameters:</p> Name Type Description Default <code>radius</code> <code>float</code> <p>The radius of the circle (must be positive).</p> required <p>Returns:</p> Name Type Description <code>Shape</code> <code>Shape</code> <p>A new Shape instance representing the circle.</p> Source code in <code>pyonfx/shape.py</code> <pre><code>@classmethod\ndef circle(cls, radius: float) -&gt; \"Shape\":\n    \"\"\"Creates a circle shape with the given radius.\n\n    Args:\n        radius: The radius of the circle (must be positive).\n\n    Returns:\n        Shape: A new Shape instance representing the circle.\n    \"\"\"\n    return cls.ellipse(2 * radius, 2 * radius)\n</code></pre>"},{"location":"reference/shape/#pyonfx.shape.Shape.ring","title":"<code>ring(out_r, in_r)</code>  <code>classmethod</code>","text":"<p>Creates a ring shape with specified inner and outer radii centered at the origin.</p> <p>Parameters:</p> Name Type Description Default <code>out_r</code> <code>float</code> <p>The outer radius of the ring.</p> required <code>in_r</code> <code>float</code> <p>The inner radius of the ring (must be less than out_r).</p> required <p>Returns:</p> Name Type Description <code>Shape</code> <code>Shape</code> <p>A Shape object representing the ring.</p> Source code in <code>pyonfx/shape.py</code> <pre><code>@classmethod\ndef ring(cls, out_r: float, in_r: float) -&gt; \"Shape\":\n    \"\"\"Creates a ring shape with specified inner and outer radii centered at the origin.\n\n    Args:\n        out_r: The outer radius of the ring.\n        in_r: The inner radius of the ring (must be less than out_r).\n\n    Returns:\n        Shape: A Shape object representing the ring.\n    \"\"\"\n    try:\n        out_r2, in_r2 = out_r * 2, in_r * 2\n        off = out_r - in_r\n        off_in_r = off + in_r\n        off_in_r2 = off + in_r2\n    except TypeError:\n        raise TypeError(\"Number(s) expected\")\n\n    if in_r &gt;= out_r:\n        raise ValueError(\n            \"Valid number expected. Inner radius must be less than outer radius\"\n        )\n\n    f = cls.format_value\n    return cls(\n        \"m 0 %s \"\n        \"b 0 %s 0 0 %s 0 \"\n        \"%s 0 %s 0 %s %s \"\n        \"%s %s %s %s %s %s \"\n        \"%s %s 0 %s 0 %s \"\n        \"m %s %s \"\n        \"b %s %s %s %s %s %s \"\n        \"%s %s %s %s %s %s \"\n        \"%s %s %s %s %s %s \"\n        \"%s %s %s %s %s %s\"\n        % (\n            f(out_r),  # outer move\n            f(out_r),\n            f(out_r),  # outer curve 1\n            f(out_r),\n            f(out_r2),\n            f(out_r2),\n            f(out_r),  # outer curve 2\n            f(out_r2),\n            f(out_r),\n            f(out_r2),\n            f(out_r2),\n            f(out_r),\n            f(out_r2),  # outer curve 3\n            f(out_r),\n            f(out_r2),\n            f(out_r2),\n            f(out_r),  # outer curve 4\n            f(off),\n            f(off_in_r),  # inner move\n            f(off),\n            f(off_in_r),\n            f(off),\n            f(off_in_r2),\n            f(off_in_r),\n            f(off_in_r2),  # inner curve 1\n            f(off_in_r),\n            f(off_in_r2),\n            f(off_in_r2),\n            f(off_in_r2),\n            f(off_in_r2),\n            f(off_in_r),  # inner curve 2\n            f(off_in_r2),\n            f(off_in_r),\n            f(off_in_r2),\n            f(off),\n            f(off_in_r),\n            f(off),  # inner curve 3\n            f(off_in_r),\n            f(off),\n            f(off),\n            f(off),\n            f(off),\n            f(off_in_r),  # inner curve 4\n        )\n    )\n</code></pre>"},{"location":"reference/shape/#pyonfx.shape.Shape.heart","title":"<code>heart(size, offset=0)</code>  <code>classmethod</code>","text":"<p>Creates a heart shape with specified dimensions and vertical offset.</p> <p>Parameters:</p> Name Type Description Default <code>size</code> <code>float</code> <p>The width and height of the heart.</p> required <code>offset</code> <code>float</code> <p>The vertical offset for the heart's center point (default is 0).</p> <code>0</code> <p>Returns:</p> Name Type Description <code>Shape</code> <code>Shape</code> <p>A Shape object representing the heart.</p> Source code in <code>pyonfx/shape.py</code> <pre><code>@classmethod\ndef heart(cls, size: float, offset: float = 0) -&gt; \"Shape\":\n    \"\"\"Creates a heart shape with specified dimensions and vertical offset.\n\n    Args:\n        size: The width and height of the heart.\n        offset: The vertical offset for the heart's center point (default is 0).\n\n    Returns:\n        Shape: A Shape object representing the heart.\n    \"\"\"\n    try:\n        mult = 100 * size / 30\n    except TypeError:\n        raise TypeError(\"Size parameter must be a number\")\n    # Build shape from template\n    shape = cls(\n        \"m 15 30 b 27 22 30 18 30 14 30 8 22 0 15 10 8 0 0 8 0 14 0 18 3 22 15 30\"\n    ).scale(mult)\n\n    # Shift mid point of heart vertically\n    count = 0\n\n    def shift_mid_point(x, y):\n        nonlocal count\n        count += 1\n\n        if count == 7:\n            try:\n                return x, y + offset\n            except TypeError:\n                raise TypeError(\"Offset parameter must be a number\")\n        return x, y\n\n    # Return result\n    return shape.map(shift_mid_point)\n</code></pre>"},{"location":"reference/shape/#pyonfx.shape.Shape.star","title":"<code>star(edges, inner_size, outer_size)</code>  <code>classmethod</code>","text":"<p>Creates a star shape centered at the origin.</p> <p>Parameters:</p> Name Type Description Default <code>edges</code> <code>int</code> <p>The number of edges for the star.</p> required <code>inner_size</code> <code>float</code> <p>The distance from the center to the inner vertices.</p> required <code>outer_size</code> <code>float</code> <p>The distance from the center to the outer vertices.</p> required <p>Returns:</p> Name Type Description <code>Shape</code> <code>Shape</code> <p>A Shape object representing the star.</p> Source code in <code>pyonfx/shape.py</code> <pre><code>@classmethod\ndef star(cls, edges: int, inner_size: float, outer_size: float) -&gt; \"Shape\":\n    \"\"\"Creates a star shape centered at the origin.\n\n    Args:\n        edges: The number of edges for the star.\n        inner_size: The distance from the center to the inner vertices.\n        outer_size: The distance from the center to the outer vertices.\n\n    Returns:\n        Shape: A Shape object representing the star.\n    \"\"\"\n    return cls._glance_or_star(edges, inner_size, outer_size, \"l\")\n</code></pre>"},{"location":"reference/shape/#pyonfx.shape.Shape.glance","title":"<code>glance(edges, inner_size, outer_size)</code>  <code>classmethod</code>","text":"<p>Creates a glance shape with curved transitions between edges.</p> <p>Parameters:</p> Name Type Description Default <code>edges</code> <code>int</code> <p>The number of edges for the glance.</p> required <code>inner_size</code> <code>float</code> <p>The distance from the center to the inner control points.</p> required <code>outer_size</code> <code>float</code> <p>The control point distance for the curves between outer edges.</p> required <p>Returns:</p> Name Type Description <code>Shape</code> <code>Shape</code> <p>A Shape object representing the glance.</p> Source code in <code>pyonfx/shape.py</code> <pre><code>@classmethod\ndef glance(cls, edges: int, inner_size: float, outer_size: float) -&gt; \"Shape\":\n    \"\"\"Creates a glance shape with curved transitions between edges.\n\n    Args:\n        edges: The number of edges for the glance.\n        inner_size: The distance from the center to the inner control points.\n        outer_size: The control point distance for the curves between outer edges.\n\n    Returns:\n        Shape: A Shape object representing the glance.\n    \"\"\"\n    return cls._glance_or_star(edges, inner_size, outer_size, \"b\")\n</code></pre>"},{"location":"reference/utils/","title":"Utils","text":""},{"location":"reference/utils/#pyonfx.utils.Utils","title":"<code>Utils</code>","text":"<p>This class is a collection of static methods that will help the user in some tasks.</p> Source code in <code>pyonfx/utils.py</code> <pre><code>class Utils:\n    \"\"\"\n    This class is a collection of static methods that will help the user in some tasks.\n    \"\"\"\n\n    _LineWordSyllableChar = TypeVar(\"_LineWordSyllableChar\", Line, Word, Syllable, Char)\n\n    @staticmethod\n    def progress_bar(\n        iterable: Iterable[_LineWordSyllableChar], **kwargs: Any\n    ) -&gt; Iterable[_LineWordSyllableChar]:\n        \"\"\"Wrap an iterable of [`Line`][pyonfx.ass_core.Line], [`Word`][pyonfx.ass_core.Word], [`Syllable`][pyonfx.ass_core.Syllable], or [`Char`][pyonfx.ass_core.Char] with a tqdm progress bar.\n\n        Args:\n            iterable: An iterable containing elements of type [`Line`][pyonfx.ass_core.Line], [`Word`][pyonfx.ass_core.Word], [`Syllable`][pyonfx.ass_core.Syllable], or [`Char`][pyonfx.ass_core.Char].\n            **kwargs: Additional arguments passed to the tqdm progress bar.\n\n        Returns:\n            Iterable[_LineWordSyllableChar]: An iterator wrapping the original iterable with a tqdm\n            progress bar displaying the iteration progress.\n\n        Examples:\n            &gt;&gt;&gt; items = [line1, line2, line3]\n            &gt;&gt;&gt; for item in Utils.progress_bar(items):\n            ...     process(item)\n\n        See Also:\n            [`all_non_empty`][pyonfx.utils.Utils.all_non_empty]: Which also uses `progress_bar` for optionally wrapping its returned iterable.\n        \"\"\"\n        # Convert to list to support multiple passes and len()\n        items = list(iterable)\n        if not items:\n            return iter([])\n\n        first = items[0]\n        obj_name = type(first).__name__.lower()\n        if obj_name not in (\"line\", \"word\", \"syllable\", \"char\"):\n            raise TypeError(\n                f\"with_progress only supports Line, Word, Syllable, or Char (got {type(first)}).\"\n            )\n        emoji = {\n            \"line\": \"\ud83d\udc30\",\n            \"word\": \"\ud83d\udd24\",\n            \"syllable\": \"\ud83c\udfa4\",\n            \"char\": \"\ud83d\udd20\",\n        }\n\n        return tqdm(\n            items,\n            desc=kwargs.pop(\"desc\", f\"Processed {obj_name}s\"),\n            unit=kwargs.pop(\"unit\", obj_name),\n            leave=kwargs.pop(\"leave\", False),\n            ascii=kwargs.pop(\"ascii\", \" \u2596\u2598\u259d\u2597\u259a\u259e\u2588\"),\n            bar_format=kwargs.pop(\n                \"bar_format\",\n                emoji[obj_name]\n                + \" {desc}: |{bar}| {percentage:3.0f}% [{n_fmt}/{total_fmt}] \"\n                \"\u23f1\ufe0f  {elapsed}&lt;{remaining}, {rate_fmt}{postfix}\",\n            ),\n            **kwargs,\n        )\n\n    @staticmethod\n    def all_non_empty(\n        lines_words_syls_or_chars: Iterable[_LineWordSyllableChar],\n        *,\n        filter_comment: bool = True,\n        filter_whitespace_text: bool = True,\n        filter_empty_duration: bool = False,\n        renumber_indexes: bool = True,\n        progress_bar: bool = True,\n    ) -&gt; Iterable[_LineWordSyllableChar]:\n        \"\"\"Filter and return non-empty elements from a given iterable.\n\n        Args:\n            lines_words_syls_or_chars: An iterable containing elements of type [`Line`][pyonfx.ass_core.Line], [`Word`][pyonfx.ass_core.Word], [`Syllable`][pyonfx.ass_core.Syllable], or [`Char`][pyonfx.ass_core.Char].\n            filter_comment: If True, filters out objects with comments (only applicable for [`Line`][pyonfx.ass_core.Line] objects).\n            filter_whitespace_text: If True, filters out objects whose text attribute is empty or contains only whitespace.\n            filter_empty_duration: If True, filters out objects with a duration less than or equal to zero.\n            renumber_indexes: If True, reassigns indexes (`i`, `word_i`, `syl_i`) of the filtered objects.\n            progress_bar: If True, wraps the resulting iterable with a progress bar for visual feedback.\n\n        Returns:\n            Iterable[_LineWordSyllableChar]: An iterator that yields the filtered objects after applying all criteria.\n\n        Examples:\n            &gt;&gt;&gt; for item in Utils.all_non_empty(lines):\n            ...     print(item.text)\n\n        See Also:\n            [`progress_bar`][pyonfx.utils.Utils.progress_bar]: Used to wrap the iterable with a progress indicator.\n        \"\"\"\n        out: list[Utils._LineWordSyllableChar] = []\n        for obj in lines_words_syls_or_chars:\n            empty_for_text = filter_whitespace_text and not obj.text.strip()\n            empty_for_duration = filter_empty_duration and obj.duration &lt;= 0\n            if empty_for_text or empty_for_duration:\n                continue\n            if filter_comment and isinstance(obj, Line) and obj.comment:\n                continue\n            out.append(obj)\n\n        if renumber_indexes:\n\n            def _renumber_attr(attr_name: str) -&gt; None:\n                if out and not hasattr(out[0], attr_name):\n                    return\n\n                first_seen: dict[int, int] = {}\n                next_idx = 0\n\n                for obj in out:\n                    old_val = getattr(obj, attr_name)\n                    if old_val not in first_seen:\n                        first_seen[old_val] = next_idx\n                        next_idx += 1\n                    setattr(obj, attr_name, first_seen[old_val])\n\n            for secondary in (\"i\", \"word_i\", \"syl_i\"):\n                _renumber_attr(secondary)\n\n        if progress_bar:\n            return Utils.progress_bar(out)\n\n        return iter(out)\n\n    @staticmethod\n    def accelerate(\n        pct: float,\n        acc: (\n            float\n            | Literal[\n                \"in_back\",\n                \"out_back\",\n                \"in_out_back\",\n                \"in_bounce\",\n                \"out_bounce\",\n                \"in_out_bounce\",\n                \"in_circ\",\n                \"out_circ\",\n                \"in_out_circ\",\n                \"in_cubic\",\n                \"out_cubic\",\n                \"in_out_cubic\",\n                \"in_elastic\",\n                \"out_elastic\",\n                \"in_out_elastic\",\n                \"in_expo\",\n                \"out_expo\",\n                \"in_out_expo\",\n                \"in_quad\",\n                \"out_quad\",\n                \"in_out_quad\",\n                \"in_quart\",\n                \"out_quart\",\n                \"in_out_quart\",\n                \"in_quint\",\n                \"out_quint\",\n                \"in_out_quint\",\n                \"in_sine\",\n                \"out_sine\",\n                \"in_out_sine\",\n            ]\n            | Callable[[float], float]\n        ) = 1.0,\n    ) -&gt; float:\n        \"\"\"Transform a progress percentage using an acceleration function.\n\n        Args:\n            pct: A float representing the progress percentage, typically between 0.0 and 1.0.\n            acc: A float, string, or callable defining the acceleration function. Defaults to 1.0 for linear progression.\n                 - If a float is provided, it acts as the exponent for the transformation.\n                 - If a string is provided, it must correspond to a preset easing function name as defined in `rpeasings`.\n                 - If a callable is provided, it should accept a float and return a transformed float.\n\n        Returns:\n            float: The transformed percentage value after applying the acceleration function.\n\n        Examples:\n            &gt;&gt;&gt; Utils.accelerate(0.5, 2.0)\n            0.25\n            &gt;&gt;&gt; Utils.accelerate(0.5, \"in_expo\")\n            0.3125\n\n        Notes:\n            Refer to [https://easings.net/](https://easings.net/) for guidance in choosing among the available easing functions.\n\n        See Also:\n            [`interpolate`][pyonfx.utils.Utils.interpolate]: Used for interpolating between values with easing.\n        \"\"\"\n        if pct == 0.0 or pct == 1.0:\n            return pct\n\n        if isinstance(acc, (int, float)):\n            fn: Callable[[float], float] = lambda x: x**acc\n        elif isinstance(acc, str):\n            try:\n                fn = getattr(rpeasings, acc)\n            except KeyError:\n                raise ValueError(f\"Unknown easing function: {acc!r}\")\n        elif callable(acc):\n            fn = acc  # Assume it follows the Accelerator protocol\n        else:\n            raise TypeError(\"Accelerator must be float, str, or callable\")\n\n        return fn(pct)\n\n    @staticmethod\n    def interpolate(\n        pct: float,\n        val1: _FloatStr,\n        val2: _FloatStr,\n        acc: (\n            float\n            | Literal[\n                \"in_back\",\n                \"out_back\",\n                \"in_out_back\",\n                \"in_bounce\",\n                \"out_bounce\",\n                \"in_out_bounce\",\n                \"in_circ\",\n                \"out_circ\",\n                \"in_out_circ\",\n                \"in_cubic\",\n                \"out_cubic\",\n                \"in_out_cubic\",\n                \"in_elastic\",\n                \"out_elastic\",\n                \"in_out_elastic\",\n                \"in_expo\",\n                \"out_expo\",\n                \"in_out_expo\",\n                \"in_quad\",\n                \"out_quad\",\n                \"in_out_quad\",\n                \"in_quart\",\n                \"out_quart\",\n                \"in_out_quart\",\n                \"in_quint\",\n                \"out_quint\",\n                \"in_out_quint\",\n                \"in_sine\",\n                \"out_sine\",\n                \"in_out_sine\",\n            ]\n            | Callable[[float], float]\n        ) = 1.0,\n    ) -&gt; _FloatStr:\n        \"\"\"Interpolate between two values with an optional acceleration (easing) function.\n\n        Args:\n            pct: A float in the range [0.0, 1.0] representing the interpolation factor.\n            val1: The starting value (ASS color, ASS alpha channel or number) for interpolation.\n            val2: The ending value (ASS color, ASS alpha channel or number) for interpolation.\n            acc: A float, string, or callable defining the acceleration function. Defaults to 1.0 for linear progression.\n                 - If a float is provided, it acts as the exponent for the transformation.\n                 - If a string is provided, it must correspond to a preset easing function name as defined in `rpeasings`.\n                 - If a callable is provided, it should accept a float and return a transformed float.\n\n        Returns:\n            The interpolated value, either a number or a string, matching the type of `val1` and `val2`.\n\n        Examples:\n            &gt;&gt;&gt; Utils.interpolate(0.5, 10, 20)\n            15.0\n            &gt;&gt;&gt; Utils.interpolate(0.9, \"&amp;HFFFFFF&amp;\", \"&amp;H000000&amp;\")\n            &amp;HE5E5E5&amp;\n            &gt;&gt;&gt; Utils.interpolate(0.5, 10, 20, \"ease-in\")\n            13.05\n            &gt;&gt;&gt; Utils.interpolate(0.5, 10, 20, 2.0)\n            12.5\n\n        Notes:\n            Refer to [https://easings.net/](https://easings.net/) for guidance in choosing among the available easing functions.\n\n        See Also:\n            [`accelerate`][pyonfx.utils.Utils.accelerate]: Used to transform percentage values with easing.\n        \"\"\"\n        if pct &gt; 1.0 or pct &lt; 0:\n            raise ValueError(\n                f\"Percent value must be a float between 0.0 and 1.0, but yours was {pct}\"\n            )\n\n        # Apply acceleration function\n        pct = Utils.accelerate(pct, acc)\n\n        def interpolate_numbers(val1: float, val2: float) -&gt; float:\n            nonlocal pct\n            return val1 + (val2 - val1) * pct\n\n        # Interpolating\n        if isinstance(val1, str) and isinstance(val2, str):\n            if len(val1) != len(val2):\n                raise ValueError(\n                    \"ASS values must have the same type (either two alphas, two colors or two colors+alpha).\"\n                )\n            if len(val1) == len(\"&amp;HXX&amp;\"):\n                val1_dec = Convert.alpha_ass_to_dec(val1)\n                val2_dec = Convert.alpha_ass_to_dec(val2)\n                a = interpolate_numbers(val1_dec, val2_dec)\n                return Convert.alpha_dec_to_ass(a)\n            elif len(val1) == len(\"&amp;HBBGGRR&amp;\"):\n                val1_rgb = Convert.color_ass_to_rgb(val1)\n                val2_rgb = Convert.color_ass_to_rgb(val2)\n                if isinstance(val1_rgb, tuple) and isinstance(val2_rgb, tuple):\n                    rgb = tuple(\n                        int(interpolate_numbers(v1, v2))\n                        for v1, v2 in zip(val1_rgb, val2_rgb)\n                    )\n                    if len(rgb) == 3:\n                        return Convert.color_rgb_to_ass(rgb)\n                raise ValueError(\"Invalid RGB color conversion\")\n            elif len(val1) == len(\"&amp;HAABBGGRR\"):\n                val1_rgba = Convert.color(val1, ColorModel.ASS, ColorModel.RGBA)\n                val2_rgba = Convert.color(val2, ColorModel.ASS, ColorModel.RGBA)\n                if isinstance(val1_rgba, tuple) and isinstance(val2_rgba, tuple):\n                    rgba = tuple(\n                        interpolate_numbers(v1, v2)\n                        for v1, v2 in zip(val1_rgba, val2_rgba)\n                    )\n                    if len(rgba) == 4:\n                        result = Convert.color(rgba, ColorModel.RGBA, ColorModel.ASS)\n                        if isinstance(result, str):\n                            return result\n                raise ValueError(\"Invalid RGBA color conversion\")\n            else:\n                raise ValueError(\n                    f\"Provided inputs '{val1}' and '{val2}' are not valid ASS strings.\"\n                )\n        elif isinstance(val1, (int, float)) and isinstance(val2, (int, float)):\n            return interpolate_numbers(float(val1), float(val2))\n        else:\n            raise TypeError(\n                \"Invalid input(s) type, either pass two strings or two numbers.\"\n            )\n\n    @staticmethod\n    def retime(\n        mode: Literal[\n            \"syl\",\n            \"presyl\",\n            \"postsyl\",\n            \"line\",\n            \"preline\",\n            \"postline\",\n            \"start2syl\",\n            \"syl2end\",\n            \"set\",\n            \"abs\",\n            \"sylpct\",\n        ],\n        output_line: Line,\n        line: Line,\n        word_syl_or_char: Word | Syllable | Char | None = None,\n        *,\n        offset_start: int = 0,\n        offset_end: int = 0,\n    ):\n        \"\"\"Adjust the timing of a subtitle line based on a specified mode.\n\n        Args:\n            mode: A string literal indicating the retime mode. Each mode applies a different timing adjustment strategy.\n            output_line: The subtitle line object whose `start_time` and `end_time` will be adjusted.\n            line: The subtitle line object whose `start_time` and `end_time` will be used as reference.\n            word_syl_or_char: An optional element ([`Word`][pyonfx.ass_core.Word], [`Syllable`][pyonfx.ass_core.Syllable], or [`Char`][pyonfx.ass_core.Char])\n                              providing timing reference for modes that require relative timing. Must be provided for modes other than\n                              \"line\", \"preline\", \"postline\", \"set\", and \"abs\".\n            offset_start: An optional integer offset (in milliseconds) to add to the computed start time.\n            offset_end: An optional integer offset (in milliseconds) to add to the computed end time.\n\n        Examples:\n            &gt;&gt;&gt; # Retiming a line based on the timing of a syllable\n            &gt;&gt;&gt; Utils.retime(\"syl\", l, line, syl, offset_start=10, offset_end=5)\n            &gt;&gt;&gt; # Retiming a line to keep its original timing (no adjustment)\n            &gt;&gt;&gt; Utils.retime(\"line\", l, line)\n\n        See Also:\n            [kara-templater retime implementation](https://github.com/slackingway/karaOK/blob/master/autoload/ln.kara-templater-mod.lua#L352)\n        \"\"\"\n        if mode == \"syl\":\n            if word_syl_or_char is None:\n                raise ValueError(\"word_syl_or_char must be provided for mode 'syl'\")\n            new_start = line.start_time + word_syl_or_char.start_time\n            new_end = line.start_time + word_syl_or_char.end_time\n        elif mode == \"presyl\":\n            if word_syl_or_char is None:\n                raise ValueError(\"word_syl_or_char must be provided for mode 'presyl'\")\n            new_start = line.start_time + word_syl_or_char.start_time\n            new_end = line.start_time + word_syl_or_char.start_time\n        elif mode == \"postsyl\":\n            if word_syl_or_char is None:\n                raise ValueError(\"word_syl_or_char must be provided for mode 'postsyl'\")\n            new_start = line.start_time + word_syl_or_char.end_time\n            new_end = line.start_time + word_syl_or_char.end_time\n        elif mode == \"line\":\n            new_start = line.start_time\n            new_end = line.end_time\n        elif mode == \"preline\":\n            new_start = line.start_time\n            new_end = line.start_time\n        elif mode == \"postline\":\n            new_start = line.end_time\n            new_end = line.end_time\n        elif mode == \"start2syl\":\n            if word_syl_or_char is None:\n                raise ValueError(\n                    \"word_syl_or_char must be provided for mode 'start2syl'\"\n                )\n            new_start = line.start_time\n            new_end = line.start_time + word_syl_or_char.start_time\n        elif mode == \"syl2end\":\n            if word_syl_or_char is None:\n                raise ValueError(\"word_syl_or_char must be provided for mode 'syl2end'\")\n            new_start = line.start_time + word_syl_or_char.end_time\n            new_end = line.end_time\n        elif mode in (\"set\", \"abs\"):\n            new_start = 0\n            new_end = 0\n        elif mode == \"sylpct\":\n            if word_syl_or_char is None:\n                raise ValueError(\"word_syl_or_char must be provided for mode 'sylpct'\")\n            new_start = (\n                line.start_time\n                + word_syl_or_char.start_time\n                + int(offset_start * word_syl_or_char.duration / 100)\n            )\n            new_end = (\n                line.start_time\n                + word_syl_or_char.start_time\n                + int(offset_end * word_syl_or_char.duration / 100)\n            )\n        else:\n            raise ValueError(f\"Unknown retime mode: {mode}\")\n\n        if mode != \"sylpct\":\n            new_start += offset_start\n            new_end += offset_end\n\n        output_line.start_time = new_start\n        output_line.end_time = new_end\n</code></pre>"},{"location":"reference/utils/#pyonfx.utils.Utils.progress_bar","title":"<code>progress_bar(iterable, **kwargs)</code>  <code>staticmethod</code>","text":"<p>Wrap an iterable of <code>Line</code>, <code>Word</code>, <code>Syllable</code>, or <code>Char</code> with a tqdm progress bar.</p> <p>Parameters:</p> Name Type Description Default <code>iterable</code> <code>Iterable[_LineWordSyllableChar]</code> <p>An iterable containing elements of type <code>Line</code>, <code>Word</code>, <code>Syllable</code>, or <code>Char</code>.</p> required <code>**kwargs</code> <code>Any</code> <p>Additional arguments passed to the tqdm progress bar.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Iterable[_LineWordSyllableChar]</code> <p>Iterable[_LineWordSyllableChar]: An iterator wrapping the original iterable with a tqdm</p> <code>Iterable[_LineWordSyllableChar]</code> <p>progress bar displaying the iteration progress.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; items = [line1, line2, line3]\n&gt;&gt;&gt; for item in Utils.progress_bar(items):\n...     process(item)\n</code></pre> See Also <p><code>all_non_empty</code>: Which also uses <code>progress_bar</code> for optionally wrapping its returned iterable.</p> Source code in <code>pyonfx/utils.py</code> <pre><code>@staticmethod\ndef progress_bar(\n    iterable: Iterable[_LineWordSyllableChar], **kwargs: Any\n) -&gt; Iterable[_LineWordSyllableChar]:\n    \"\"\"Wrap an iterable of [`Line`][pyonfx.ass_core.Line], [`Word`][pyonfx.ass_core.Word], [`Syllable`][pyonfx.ass_core.Syllable], or [`Char`][pyonfx.ass_core.Char] with a tqdm progress bar.\n\n    Args:\n        iterable: An iterable containing elements of type [`Line`][pyonfx.ass_core.Line], [`Word`][pyonfx.ass_core.Word], [`Syllable`][pyonfx.ass_core.Syllable], or [`Char`][pyonfx.ass_core.Char].\n        **kwargs: Additional arguments passed to the tqdm progress bar.\n\n    Returns:\n        Iterable[_LineWordSyllableChar]: An iterator wrapping the original iterable with a tqdm\n        progress bar displaying the iteration progress.\n\n    Examples:\n        &gt;&gt;&gt; items = [line1, line2, line3]\n        &gt;&gt;&gt; for item in Utils.progress_bar(items):\n        ...     process(item)\n\n    See Also:\n        [`all_non_empty`][pyonfx.utils.Utils.all_non_empty]: Which also uses `progress_bar` for optionally wrapping its returned iterable.\n    \"\"\"\n    # Convert to list to support multiple passes and len()\n    items = list(iterable)\n    if not items:\n        return iter([])\n\n    first = items[0]\n    obj_name = type(first).__name__.lower()\n    if obj_name not in (\"line\", \"word\", \"syllable\", \"char\"):\n        raise TypeError(\n            f\"with_progress only supports Line, Word, Syllable, or Char (got {type(first)}).\"\n        )\n    emoji = {\n        \"line\": \"\ud83d\udc30\",\n        \"word\": \"\ud83d\udd24\",\n        \"syllable\": \"\ud83c\udfa4\",\n        \"char\": \"\ud83d\udd20\",\n    }\n\n    return tqdm(\n        items,\n        desc=kwargs.pop(\"desc\", f\"Processed {obj_name}s\"),\n        unit=kwargs.pop(\"unit\", obj_name),\n        leave=kwargs.pop(\"leave\", False),\n        ascii=kwargs.pop(\"ascii\", \" \u2596\u2598\u259d\u2597\u259a\u259e\u2588\"),\n        bar_format=kwargs.pop(\n            \"bar_format\",\n            emoji[obj_name]\n            + \" {desc}: |{bar}| {percentage:3.0f}% [{n_fmt}/{total_fmt}] \"\n            \"\u23f1\ufe0f  {elapsed}&lt;{remaining}, {rate_fmt}{postfix}\",\n        ),\n        **kwargs,\n    )\n</code></pre>"},{"location":"reference/utils/#pyonfx.utils.Utils.all_non_empty","title":"<code>all_non_empty(lines_words_syls_or_chars, *, filter_comment=True, filter_whitespace_text=True, filter_empty_duration=False, renumber_indexes=True, progress_bar=True)</code>  <code>staticmethod</code>","text":"<p>Filter and return non-empty elements from a given iterable.</p> <p>Parameters:</p> Name Type Description Default <code>lines_words_syls_or_chars</code> <code>Iterable[_LineWordSyllableChar]</code> <p>An iterable containing elements of type <code>Line</code>, <code>Word</code>, <code>Syllable</code>, or <code>Char</code>.</p> required <code>filter_comment</code> <code>bool</code> <p>If True, filters out objects with comments (only applicable for <code>Line</code> objects).</p> <code>True</code> <code>filter_whitespace_text</code> <code>bool</code> <p>If True, filters out objects whose text attribute is empty or contains only whitespace.</p> <code>True</code> <code>filter_empty_duration</code> <code>bool</code> <p>If True, filters out objects with a duration less than or equal to zero.</p> <code>False</code> <code>renumber_indexes</code> <code>bool</code> <p>If True, reassigns indexes (<code>i</code>, <code>word_i</code>, <code>syl_i</code>) of the filtered objects.</p> <code>True</code> <code>progress_bar</code> <code>bool</code> <p>If True, wraps the resulting iterable with a progress bar for visual feedback.</p> <code>True</code> <p>Returns:</p> Type Description <code>Iterable[_LineWordSyllableChar]</code> <p>Iterable[_LineWordSyllableChar]: An iterator that yields the filtered objects after applying all criteria.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; for item in Utils.all_non_empty(lines):\n...     print(item.text)\n</code></pre> See Also <p><code>progress_bar</code>: Used to wrap the iterable with a progress indicator.</p> Source code in <code>pyonfx/utils.py</code> <pre><code>@staticmethod\ndef all_non_empty(\n    lines_words_syls_or_chars: Iterable[_LineWordSyllableChar],\n    *,\n    filter_comment: bool = True,\n    filter_whitespace_text: bool = True,\n    filter_empty_duration: bool = False,\n    renumber_indexes: bool = True,\n    progress_bar: bool = True,\n) -&gt; Iterable[_LineWordSyllableChar]:\n    \"\"\"Filter and return non-empty elements from a given iterable.\n\n    Args:\n        lines_words_syls_or_chars: An iterable containing elements of type [`Line`][pyonfx.ass_core.Line], [`Word`][pyonfx.ass_core.Word], [`Syllable`][pyonfx.ass_core.Syllable], or [`Char`][pyonfx.ass_core.Char].\n        filter_comment: If True, filters out objects with comments (only applicable for [`Line`][pyonfx.ass_core.Line] objects).\n        filter_whitespace_text: If True, filters out objects whose text attribute is empty or contains only whitespace.\n        filter_empty_duration: If True, filters out objects with a duration less than or equal to zero.\n        renumber_indexes: If True, reassigns indexes (`i`, `word_i`, `syl_i`) of the filtered objects.\n        progress_bar: If True, wraps the resulting iterable with a progress bar for visual feedback.\n\n    Returns:\n        Iterable[_LineWordSyllableChar]: An iterator that yields the filtered objects after applying all criteria.\n\n    Examples:\n        &gt;&gt;&gt; for item in Utils.all_non_empty(lines):\n        ...     print(item.text)\n\n    See Also:\n        [`progress_bar`][pyonfx.utils.Utils.progress_bar]: Used to wrap the iterable with a progress indicator.\n    \"\"\"\n    out: list[Utils._LineWordSyllableChar] = []\n    for obj in lines_words_syls_or_chars:\n        empty_for_text = filter_whitespace_text and not obj.text.strip()\n        empty_for_duration = filter_empty_duration and obj.duration &lt;= 0\n        if empty_for_text or empty_for_duration:\n            continue\n        if filter_comment and isinstance(obj, Line) and obj.comment:\n            continue\n        out.append(obj)\n\n    if renumber_indexes:\n\n        def _renumber_attr(attr_name: str) -&gt; None:\n            if out and not hasattr(out[0], attr_name):\n                return\n\n            first_seen: dict[int, int] = {}\n            next_idx = 0\n\n            for obj in out:\n                old_val = getattr(obj, attr_name)\n                if old_val not in first_seen:\n                    first_seen[old_val] = next_idx\n                    next_idx += 1\n                setattr(obj, attr_name, first_seen[old_val])\n\n        for secondary in (\"i\", \"word_i\", \"syl_i\"):\n            _renumber_attr(secondary)\n\n    if progress_bar:\n        return Utils.progress_bar(out)\n\n    return iter(out)\n</code></pre>"},{"location":"reference/utils/#pyonfx.utils.Utils.accelerate","title":"<code>accelerate(pct, acc=1.0)</code>  <code>staticmethod</code>","text":"<p>Transform a progress percentage using an acceleration function.</p> <p>Parameters:</p> Name Type Description Default <code>pct</code> <code>float</code> <p>A float representing the progress percentage, typically between 0.0 and 1.0.</p> required <code>acc</code> <code>float | Literal['in_back', 'out_back', 'in_out_back', 'in_bounce', 'out_bounce', 'in_out_bounce', 'in_circ', 'out_circ', 'in_out_circ', 'in_cubic', 'out_cubic', 'in_out_cubic', 'in_elastic', 'out_elastic', 'in_out_elastic', 'in_expo', 'out_expo', 'in_out_expo', 'in_quad', 'out_quad', 'in_out_quad', 'in_quart', 'out_quart', 'in_out_quart', 'in_quint', 'out_quint', 'in_out_quint', 'in_sine', 'out_sine', 'in_out_sine'] | Callable[[float], float]</code> <p>A float, string, or callable defining the acceleration function. Defaults to 1.0 for linear progression.  - If a float is provided, it acts as the exponent for the transformation.  - If a string is provided, it must correspond to a preset easing function name as defined in <code>rpeasings</code>.  - If a callable is provided, it should accept a float and return a transformed float.</p> <code>1.0</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The transformed percentage value after applying the acceleration function.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; Utils.accelerate(0.5, 2.0)\n0.25\n&gt;&gt;&gt; Utils.accelerate(0.5, \"in_expo\")\n0.3125\n</code></pre> Notes <p>Refer to https://easings.net/ for guidance in choosing among the available easing functions.</p> See Also <p><code>interpolate</code>: Used for interpolating between values with easing.</p> Source code in <code>pyonfx/utils.py</code> <pre><code>@staticmethod\ndef accelerate(\n    pct: float,\n    acc: (\n        float\n        | Literal[\n            \"in_back\",\n            \"out_back\",\n            \"in_out_back\",\n            \"in_bounce\",\n            \"out_bounce\",\n            \"in_out_bounce\",\n            \"in_circ\",\n            \"out_circ\",\n            \"in_out_circ\",\n            \"in_cubic\",\n            \"out_cubic\",\n            \"in_out_cubic\",\n            \"in_elastic\",\n            \"out_elastic\",\n            \"in_out_elastic\",\n            \"in_expo\",\n            \"out_expo\",\n            \"in_out_expo\",\n            \"in_quad\",\n            \"out_quad\",\n            \"in_out_quad\",\n            \"in_quart\",\n            \"out_quart\",\n            \"in_out_quart\",\n            \"in_quint\",\n            \"out_quint\",\n            \"in_out_quint\",\n            \"in_sine\",\n            \"out_sine\",\n            \"in_out_sine\",\n        ]\n        | Callable[[float], float]\n    ) = 1.0,\n) -&gt; float:\n    \"\"\"Transform a progress percentage using an acceleration function.\n\n    Args:\n        pct: A float representing the progress percentage, typically between 0.0 and 1.0.\n        acc: A float, string, or callable defining the acceleration function. Defaults to 1.0 for linear progression.\n             - If a float is provided, it acts as the exponent for the transformation.\n             - If a string is provided, it must correspond to a preset easing function name as defined in `rpeasings`.\n             - If a callable is provided, it should accept a float and return a transformed float.\n\n    Returns:\n        float: The transformed percentage value after applying the acceleration function.\n\n    Examples:\n        &gt;&gt;&gt; Utils.accelerate(0.5, 2.0)\n        0.25\n        &gt;&gt;&gt; Utils.accelerate(0.5, \"in_expo\")\n        0.3125\n\n    Notes:\n        Refer to [https://easings.net/](https://easings.net/) for guidance in choosing among the available easing functions.\n\n    See Also:\n        [`interpolate`][pyonfx.utils.Utils.interpolate]: Used for interpolating between values with easing.\n    \"\"\"\n    if pct == 0.0 or pct == 1.0:\n        return pct\n\n    if isinstance(acc, (int, float)):\n        fn: Callable[[float], float] = lambda x: x**acc\n    elif isinstance(acc, str):\n        try:\n            fn = getattr(rpeasings, acc)\n        except KeyError:\n            raise ValueError(f\"Unknown easing function: {acc!r}\")\n    elif callable(acc):\n        fn = acc  # Assume it follows the Accelerator protocol\n    else:\n        raise TypeError(\"Accelerator must be float, str, or callable\")\n\n    return fn(pct)\n</code></pre>"},{"location":"reference/utils/#pyonfx.utils.Utils.interpolate","title":"<code>interpolate(pct, val1, val2, acc=1.0)</code>  <code>staticmethod</code>","text":"<p>Interpolate between two values with an optional acceleration (easing) function.</p> <p>Parameters:</p> Name Type Description Default <code>pct</code> <code>float</code> <p>A float in the range [0.0, 1.0] representing the interpolation factor.</p> required <code>val1</code> <code>_FloatStr</code> <p>The starting value (ASS color, ASS alpha channel or number) for interpolation.</p> required <code>val2</code> <code>_FloatStr</code> <p>The ending value (ASS color, ASS alpha channel or number) for interpolation.</p> required <code>acc</code> <code>float | Literal['in_back', 'out_back', 'in_out_back', 'in_bounce', 'out_bounce', 'in_out_bounce', 'in_circ', 'out_circ', 'in_out_circ', 'in_cubic', 'out_cubic', 'in_out_cubic', 'in_elastic', 'out_elastic', 'in_out_elastic', 'in_expo', 'out_expo', 'in_out_expo', 'in_quad', 'out_quad', 'in_out_quad', 'in_quart', 'out_quart', 'in_out_quart', 'in_quint', 'out_quint', 'in_out_quint', 'in_sine', 'out_sine', 'in_out_sine'] | Callable[[float], float]</code> <p>A float, string, or callable defining the acceleration function. Defaults to 1.0 for linear progression.  - If a float is provided, it acts as the exponent for the transformation.  - If a string is provided, it must correspond to a preset easing function name as defined in <code>rpeasings</code>.  - If a callable is provided, it should accept a float and return a transformed float.</p> <code>1.0</code> <p>Returns:</p> Type Description <code>_FloatStr</code> <p>The interpolated value, either a number or a string, matching the type of <code>val1</code> and <code>val2</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; Utils.interpolate(0.5, 10, 20)\n15.0\n&gt;&gt;&gt; Utils.interpolate(0.9, \"&amp;HFFFFFF&amp;\", \"&amp;H000000&amp;\")\n&amp;HE5E5E5&amp;\n&gt;&gt;&gt; Utils.interpolate(0.5, 10, 20, \"ease-in\")\n13.05\n&gt;&gt;&gt; Utils.interpolate(0.5, 10, 20, 2.0)\n12.5\n</code></pre> Notes <p>Refer to https://easings.net/ for guidance in choosing among the available easing functions.</p> See Also <p><code>accelerate</code>: Used to transform percentage values with easing.</p> Source code in <code>pyonfx/utils.py</code> <pre><code>@staticmethod\ndef interpolate(\n    pct: float,\n    val1: _FloatStr,\n    val2: _FloatStr,\n    acc: (\n        float\n        | Literal[\n            \"in_back\",\n            \"out_back\",\n            \"in_out_back\",\n            \"in_bounce\",\n            \"out_bounce\",\n            \"in_out_bounce\",\n            \"in_circ\",\n            \"out_circ\",\n            \"in_out_circ\",\n            \"in_cubic\",\n            \"out_cubic\",\n            \"in_out_cubic\",\n            \"in_elastic\",\n            \"out_elastic\",\n            \"in_out_elastic\",\n            \"in_expo\",\n            \"out_expo\",\n            \"in_out_expo\",\n            \"in_quad\",\n            \"out_quad\",\n            \"in_out_quad\",\n            \"in_quart\",\n            \"out_quart\",\n            \"in_out_quart\",\n            \"in_quint\",\n            \"out_quint\",\n            \"in_out_quint\",\n            \"in_sine\",\n            \"out_sine\",\n            \"in_out_sine\",\n        ]\n        | Callable[[float], float]\n    ) = 1.0,\n) -&gt; _FloatStr:\n    \"\"\"Interpolate between two values with an optional acceleration (easing) function.\n\n    Args:\n        pct: A float in the range [0.0, 1.0] representing the interpolation factor.\n        val1: The starting value (ASS color, ASS alpha channel or number) for interpolation.\n        val2: The ending value (ASS color, ASS alpha channel or number) for interpolation.\n        acc: A float, string, or callable defining the acceleration function. Defaults to 1.0 for linear progression.\n             - If a float is provided, it acts as the exponent for the transformation.\n             - If a string is provided, it must correspond to a preset easing function name as defined in `rpeasings`.\n             - If a callable is provided, it should accept a float and return a transformed float.\n\n    Returns:\n        The interpolated value, either a number or a string, matching the type of `val1` and `val2`.\n\n    Examples:\n        &gt;&gt;&gt; Utils.interpolate(0.5, 10, 20)\n        15.0\n        &gt;&gt;&gt; Utils.interpolate(0.9, \"&amp;HFFFFFF&amp;\", \"&amp;H000000&amp;\")\n        &amp;HE5E5E5&amp;\n        &gt;&gt;&gt; Utils.interpolate(0.5, 10, 20, \"ease-in\")\n        13.05\n        &gt;&gt;&gt; Utils.interpolate(0.5, 10, 20, 2.0)\n        12.5\n\n    Notes:\n        Refer to [https://easings.net/](https://easings.net/) for guidance in choosing among the available easing functions.\n\n    See Also:\n        [`accelerate`][pyonfx.utils.Utils.accelerate]: Used to transform percentage values with easing.\n    \"\"\"\n    if pct &gt; 1.0 or pct &lt; 0:\n        raise ValueError(\n            f\"Percent value must be a float between 0.0 and 1.0, but yours was {pct}\"\n        )\n\n    # Apply acceleration function\n    pct = Utils.accelerate(pct, acc)\n\n    def interpolate_numbers(val1: float, val2: float) -&gt; float:\n        nonlocal pct\n        return val1 + (val2 - val1) * pct\n\n    # Interpolating\n    if isinstance(val1, str) and isinstance(val2, str):\n        if len(val1) != len(val2):\n            raise ValueError(\n                \"ASS values must have the same type (either two alphas, two colors or two colors+alpha).\"\n            )\n        if len(val1) == len(\"&amp;HXX&amp;\"):\n            val1_dec = Convert.alpha_ass_to_dec(val1)\n            val2_dec = Convert.alpha_ass_to_dec(val2)\n            a = interpolate_numbers(val1_dec, val2_dec)\n            return Convert.alpha_dec_to_ass(a)\n        elif len(val1) == len(\"&amp;HBBGGRR&amp;\"):\n            val1_rgb = Convert.color_ass_to_rgb(val1)\n            val2_rgb = Convert.color_ass_to_rgb(val2)\n            if isinstance(val1_rgb, tuple) and isinstance(val2_rgb, tuple):\n                rgb = tuple(\n                    int(interpolate_numbers(v1, v2))\n                    for v1, v2 in zip(val1_rgb, val2_rgb)\n                )\n                if len(rgb) == 3:\n                    return Convert.color_rgb_to_ass(rgb)\n            raise ValueError(\"Invalid RGB color conversion\")\n        elif len(val1) == len(\"&amp;HAABBGGRR\"):\n            val1_rgba = Convert.color(val1, ColorModel.ASS, ColorModel.RGBA)\n            val2_rgba = Convert.color(val2, ColorModel.ASS, ColorModel.RGBA)\n            if isinstance(val1_rgba, tuple) and isinstance(val2_rgba, tuple):\n                rgba = tuple(\n                    interpolate_numbers(v1, v2)\n                    for v1, v2 in zip(val1_rgba, val2_rgba)\n                )\n                if len(rgba) == 4:\n                    result = Convert.color(rgba, ColorModel.RGBA, ColorModel.ASS)\n                    if isinstance(result, str):\n                        return result\n            raise ValueError(\"Invalid RGBA color conversion\")\n        else:\n            raise ValueError(\n                f\"Provided inputs '{val1}' and '{val2}' are not valid ASS strings.\"\n            )\n    elif isinstance(val1, (int, float)) and isinstance(val2, (int, float)):\n        return interpolate_numbers(float(val1), float(val2))\n    else:\n        raise TypeError(\n            \"Invalid input(s) type, either pass two strings or two numbers.\"\n        )\n</code></pre>"},{"location":"reference/utils/#pyonfx.utils.Utils.retime","title":"<code>retime(mode, output_line, line, word_syl_or_char=None, *, offset_start=0, offset_end=0)</code>  <code>staticmethod</code>","text":"<p>Adjust the timing of a subtitle line based on a specified mode.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>Literal['syl', 'presyl', 'postsyl', 'line', 'preline', 'postline', 'start2syl', 'syl2end', 'set', 'abs', 'sylpct']</code> <p>A string literal indicating the retime mode. Each mode applies a different timing adjustment strategy.</p> required <code>output_line</code> <code>Line</code> <p>The subtitle line object whose <code>start_time</code> and <code>end_time</code> will be adjusted.</p> required <code>line</code> <code>Line</code> <p>The subtitle line object whose <code>start_time</code> and <code>end_time</code> will be used as reference.</p> required <code>word_syl_or_char</code> <code>Word | Syllable | Char | None</code> <p>An optional element (<code>Word</code>, <code>Syllable</code>, or <code>Char</code>)               providing timing reference for modes that require relative timing. Must be provided for modes other than               \"line\", \"preline\", \"postline\", \"set\", and \"abs\".</p> <code>None</code> <code>offset_start</code> <code>int</code> <p>An optional integer offset (in milliseconds) to add to the computed start time.</p> <code>0</code> <code>offset_end</code> <code>int</code> <p>An optional integer offset (in milliseconds) to add to the computed end time.</p> <code>0</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # Retiming a line based on the timing of a syllable\n&gt;&gt;&gt; Utils.retime(\"syl\", l, line, syl, offset_start=10, offset_end=5)\n&gt;&gt;&gt; # Retiming a line to keep its original timing (no adjustment)\n&gt;&gt;&gt; Utils.retime(\"line\", l, line)\n</code></pre> See Also <p>kara-templater retime implementation</p> Source code in <code>pyonfx/utils.py</code> <pre><code>@staticmethod\ndef retime(\n    mode: Literal[\n        \"syl\",\n        \"presyl\",\n        \"postsyl\",\n        \"line\",\n        \"preline\",\n        \"postline\",\n        \"start2syl\",\n        \"syl2end\",\n        \"set\",\n        \"abs\",\n        \"sylpct\",\n    ],\n    output_line: Line,\n    line: Line,\n    word_syl_or_char: Word | Syllable | Char | None = None,\n    *,\n    offset_start: int = 0,\n    offset_end: int = 0,\n):\n    \"\"\"Adjust the timing of a subtitle line based on a specified mode.\n\n    Args:\n        mode: A string literal indicating the retime mode. Each mode applies a different timing adjustment strategy.\n        output_line: The subtitle line object whose `start_time` and `end_time` will be adjusted.\n        line: The subtitle line object whose `start_time` and `end_time` will be used as reference.\n        word_syl_or_char: An optional element ([`Word`][pyonfx.ass_core.Word], [`Syllable`][pyonfx.ass_core.Syllable], or [`Char`][pyonfx.ass_core.Char])\n                          providing timing reference for modes that require relative timing. Must be provided for modes other than\n                          \"line\", \"preline\", \"postline\", \"set\", and \"abs\".\n        offset_start: An optional integer offset (in milliseconds) to add to the computed start time.\n        offset_end: An optional integer offset (in milliseconds) to add to the computed end time.\n\n    Examples:\n        &gt;&gt;&gt; # Retiming a line based on the timing of a syllable\n        &gt;&gt;&gt; Utils.retime(\"syl\", l, line, syl, offset_start=10, offset_end=5)\n        &gt;&gt;&gt; # Retiming a line to keep its original timing (no adjustment)\n        &gt;&gt;&gt; Utils.retime(\"line\", l, line)\n\n    See Also:\n        [kara-templater retime implementation](https://github.com/slackingway/karaOK/blob/master/autoload/ln.kara-templater-mod.lua#L352)\n    \"\"\"\n    if mode == \"syl\":\n        if word_syl_or_char is None:\n            raise ValueError(\"word_syl_or_char must be provided for mode 'syl'\")\n        new_start = line.start_time + word_syl_or_char.start_time\n        new_end = line.start_time + word_syl_or_char.end_time\n    elif mode == \"presyl\":\n        if word_syl_or_char is None:\n            raise ValueError(\"word_syl_or_char must be provided for mode 'presyl'\")\n        new_start = line.start_time + word_syl_or_char.start_time\n        new_end = line.start_time + word_syl_or_char.start_time\n    elif mode == \"postsyl\":\n        if word_syl_or_char is None:\n            raise ValueError(\"word_syl_or_char must be provided for mode 'postsyl'\")\n        new_start = line.start_time + word_syl_or_char.end_time\n        new_end = line.start_time + word_syl_or_char.end_time\n    elif mode == \"line\":\n        new_start = line.start_time\n        new_end = line.end_time\n    elif mode == \"preline\":\n        new_start = line.start_time\n        new_end = line.start_time\n    elif mode == \"postline\":\n        new_start = line.end_time\n        new_end = line.end_time\n    elif mode == \"start2syl\":\n        if word_syl_or_char is None:\n            raise ValueError(\n                \"word_syl_or_char must be provided for mode 'start2syl'\"\n            )\n        new_start = line.start_time\n        new_end = line.start_time + word_syl_or_char.start_time\n    elif mode == \"syl2end\":\n        if word_syl_or_char is None:\n            raise ValueError(\"word_syl_or_char must be provided for mode 'syl2end'\")\n        new_start = line.start_time + word_syl_or_char.end_time\n        new_end = line.end_time\n    elif mode in (\"set\", \"abs\"):\n        new_start = 0\n        new_end = 0\n    elif mode == \"sylpct\":\n        if word_syl_or_char is None:\n            raise ValueError(\"word_syl_or_char must be provided for mode 'sylpct'\")\n        new_start = (\n            line.start_time\n            + word_syl_or_char.start_time\n            + int(offset_start * word_syl_or_char.duration / 100)\n        )\n        new_end = (\n            line.start_time\n            + word_syl_or_char.start_time\n            + int(offset_end * word_syl_or_char.duration / 100)\n        )\n    else:\n        raise ValueError(f\"Unknown retime mode: {mode}\")\n\n    if mode != \"sylpct\":\n        new_start += offset_start\n        new_end += offset_end\n\n    output_line.start_time = new_start\n    output_line.end_time = new_end\n</code></pre>"},{"location":"reference/utils/#pyonfx.utils.FrameUtility","title":"<code>FrameUtility</code>","text":"<p>Provide an accurate frame-by-frame iteration engine for subtitle processing.</p> <p>This class enables precise operations on video frames by dividing a time interval (from <code>start_ms</code> to <code>end_ms</code>) into discrete frame segments based on a given timestamps object. It calculates the corresponding frame indices and yields a tuple for each frame segment containing:   - The start time of the frame segment (in milliseconds).   - The end time of the frame segment (in milliseconds), clamped to the video duration.   - The current frame index (starting at 1).   - The total number of frame segments.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # Assume `io.input_timestamps` is an instance of ABCTimestamps and the video has a 20 fps frame rate (50 ms per frame)\n&gt;&gt;&gt; fu = FrameUtility(0, 110, io.input_timestamps)\n&gt;&gt;&gt; for s, e, i, n in fu:\n...     print(f\"Frame {i}/{n}: {s} - {e}\")\nFrame 1/3: 0 - 25\nFrame 2/3: 25 - 75\nFrame 3/3: 75 - 125\n</code></pre> Notes <p>A mid-point approach is used to center each frame's timing around the player's seek time, ensuring that subtitles remain visible throughout the entire frame duration. This method is reliable for both constant frame rate (CFR) and variable frame rate (VFR) videos.</p> Source code in <code>pyonfx/utils.py</code> <pre><code>class FrameUtility:\n    \"\"\"Provide an accurate frame-by-frame iteration engine for subtitle processing.\n\n    This class enables precise operations on video frames by dividing a time interval (from `start_ms` to `end_ms`)\n    into discrete frame segments based on a given timestamps object. It calculates the corresponding frame indices and yields\n    a tuple for each frame segment containing:\n      - The start time of the frame segment (in milliseconds).\n      - The end time of the frame segment (in milliseconds), clamped to the video duration.\n      - The current frame index (starting at 1).\n      - The total number of frame segments.\n\n    Examples:\n        &gt;&gt;&gt; # Assume `io.input_timestamps` is an instance of ABCTimestamps and the video has a 20 fps frame rate (50 ms per frame)\n        &gt;&gt;&gt; fu = FrameUtility(0, 110, io.input_timestamps)\n        &gt;&gt;&gt; for s, e, i, n in fu:\n        ...     print(f\"Frame {i}/{n}: {s} - {e}\")\n        Frame 1/3: 0 - 25\n        Frame 2/3: 25 - 75\n        Frame 3/3: 75 - 125\n\n    Notes:\n        A mid-point approach is used to center each frame's timing around the player's seek time, ensuring that subtitles\n        remain visible throughout the entire frame duration. This method is reliable for both constant frame rate (CFR) and\n        variable frame rate (VFR) videos.\n    \"\"\"\n\n    def __init__(\n        self,\n        start_ms: int,\n        end_ms: int,\n        timestamps: ABCTimestamps | None,\n        n_fr: int = 1,\n    ):\n        \"\"\"Initialize the FrameUtility object.\n\n        Args:\n            start_ms: A positive integer representing the starting time (in milliseconds) of the interval.\n            end_ms: A positive integer representing the ending time (in milliseconds) of the interval.\n            timestamps: An instance of `ABCTimestamps` used to convert between time values and frame numbers.\n            n_fr: An optional positive integer specifying the number of frames to process per iteration (default is 1).\n        \"\"\"\n        # Check for invalid values\n        if start_ms &lt; 0 or end_ms &lt; 0:\n            raise ValueError(\"Parameters 'start_ms' and 'end_ms' must be &gt;= 0.\")\n        if end_ms &lt; start_ms:\n            raise ValueError(\"Parameter 'start_ms' is expected to be &lt;= 'end_ms'.\")\n        if n_fr &lt;= 0:\n            raise ValueError(\"Parameter 'n_fr' must be &gt; 0.\")\n        if timestamps is None:\n            raise ValueError(\n                \"Parameter 'timestamps' cannot be None (hint: does your ASS file have a video specified?).\"\n            )\n\n        self.timestamps = timestamps\n        self.start_ms = start_ms\n        self.end_ms = end_ms\n\n        self.start_fr = self.curr_fr = timestamps.time_to_frame(\n            start_ms, TimeType.START, 3\n        )\n        self.end_fr = timestamps.time_to_frame(end_ms, TimeType.END, 3)\n        self.end_ms_snapped = timestamps.frame_to_time(\n            self.end_fr, TimeType.END, 3, True\n        )\n        self.n_fr = n_fr\n        self.i = 0\n        self.n = self.end_fr - self.start_fr + 1\n\n    @property\n    def duration(self) -&gt; int:\n        \"\"\"Derived duration of the frame window in milliseconds.\"\"\"\n        return self.end_ms - self.start_ms\n\n    def __iter__(self):\n        # Generate values for the frames on demand. The end time is always clamped to the end_ms value.\n        for self.i in range(0, self.n, self.n_fr):\n            yield (\n                self.timestamps.frame_to_time(self.curr_fr, TimeType.START, 3, True),\n                min(\n                    self.timestamps.frame_to_time(\n                        self.curr_fr + self.n_fr - 1, TimeType.END, 3, True\n                    ),\n                    self.end_ms_snapped,\n                ),\n                self.i + 1,\n                self.n,\n            )\n            self.curr_fr += self.n_fr\n\n        # Reset the object to make it usable again\n        self.reset()\n\n    def reset(self):\n        \"\"\"Reset the frame utility to its initial state.\"\"\"\n        self.i = 0\n        self.curr_fr = self.start_fr\n\n    def add(\n        self,\n        start_time: float,\n        end_time: float,\n        end_value: float,\n        acc: (\n            float\n            | Literal[\n                \"in_back\",\n                \"out_back\",\n                \"in_out_back\",\n                \"in_bounce\",\n                \"out_bounce\",\n                \"in_out_bounce\",\n                \"in_circ\",\n                \"out_circ\",\n                \"in_out_circ\",\n                \"in_cubic\",\n                \"out_cubic\",\n                \"in_out_cubic\",\n                \"in_elastic\",\n                \"out_elastic\",\n                \"in_out_elastic\",\n                \"in_expo\",\n                \"out_expo\",\n                \"in_out_expo\",\n                \"in_quad\",\n                \"out_quad\",\n                \"in_out_quad\",\n                \"in_quart\",\n                \"out_quart\",\n                \"in_out_quart\",\n                \"in_quint\",\n                \"out_quint\",\n                \"in_out_quint\",\n                \"in_sine\",\n                \"out_sine\",\n                \"in_out_sine\",\n            ]\n            | Callable[[float], float]\n        ) = 1.0,\n    ) -&gt; float:\n        \"\"\"Apply a frame-by-frame numeric transformation similar to the ASS '\\\\t' tag.\n\n        This method computes an adjustment value for the current frame by interpolating between 0 and `end_value` over a\n        specified time interval defined by `start_time` and `end_time`. Mimicking the behavior of the ASS '\\\\t' tag,\n        it calculates the interpolation progress based on the midpoint of the current frame within the interval and applies\n        an optional acceleration (easing) function (`acc`) to modulate the transformation.\n\n        Args:\n            start_time: The start time (in milliseconds) of the transformation interval (relative to the iteration range).\n            end_time: The end time (in milliseconds) of the transformation interval (relative to the iteration range).\n            end_value: The final adjustment value to be reached at the end of the interval.\n            acc: A float, string, or callable defining the acceleration function. Defaults to 1.0 for linear progression.\n                 - If a float is provided, it acts as the exponent for the transformation.\n                 - If a string is provided, it must correspond to a preset easing function name as defined in `rpeasings`.\n                 - If a callable is provided, it should accept a float and return a transformed float.\n\n        Returns:\n            float: The computed adjustment value for the current frame.\n\n        Examples:\n            &gt;&gt;&gt; # Let's assume to have an Ass object named \"io\" having a 20 fps video (i.e. frames are 50 ms long)\n            &gt;&gt;&gt; fu = FrameUtility(25, 225, io.input_timestamps)\n            &gt;&gt;&gt; for s, e, i, n in fu:\n            ...     # We would like to transform the fsc value\n            ...     # from 100 up 150 for the first 100 ms,\n            ...     # and then from 150 to 100 for the remaining 200 ms\n            ...     fsc = 100\n            ...     fsc += fu.add(0, 100, 50)\n            ...     fsc += fu.add(100, 200, -50)\n            ...     print(f\"Frame {i}/{n}: {s} - {e}; fsc: {fsc}\")\n            Frame 1/4: 25 - 75; fsc: 112.5\n            Frame 2/4: 75 - 125; fsc: 137.5\n            Frame 3/4: 125 - 175; fsc: 137.5\n            Frame 4/4: 175 - 225; fsc: 112.5\n\n        Notes:\n            Should be called inside a loop iterating over a `FrameUtility` instance.\n\n        See Also:\n            [`accelerate`][pyonfx.utils.Utils.accelerate]: For transforming percentage values with easing.\n        \"\"\"\n        curr_ms = self.timestamps.frame_to_time(\n            self.i + (self.n_fr - 1) // 2, TimeType.END, 3, True\n        )\n\n        if curr_ms &lt;= start_time:\n            return 0\n        elif curr_ms &gt;= end_time:\n            return end_value\n\n        curr = curr_ms - start_time\n        total = end_time - start_time\n        return Utils.interpolate(curr / total, 0, end_value, acc)\n\n    def interpolate(\n        self,\n        start_time: float,\n        end_time: float,\n        start_value: _FloatStr,\n        end_value: _FloatStr,\n        acc: (\n            float\n            | Literal[\n                \"in_back\",\n                \"out_back\",\n                \"in_out_back\",\n                \"in_bounce\",\n                \"out_bounce\",\n                \"in_out_bounce\",\n                \"in_circ\",\n                \"out_circ\",\n                \"in_out_circ\",\n                \"in_cubic\",\n                \"out_cubic\",\n                \"in_out_cubic\",\n                \"in_elastic\",\n                \"out_elastic\",\n                \"in_out_elastic\",\n                \"in_expo\",\n                \"out_expo\",\n                \"in_out_expo\",\n                \"in_quad\",\n                \"out_quad\",\n                \"in_out_quad\",\n                \"in_quart\",\n                \"out_quart\",\n                \"in_out_quart\",\n                \"in_quint\",\n                \"out_quint\",\n                \"in_out_quint\",\n                \"in_sine\",\n                \"out_sine\",\n                \"in_out_sine\",\n            ]\n            | Callable[[float], float]\n        ) = 1.0,\n    ) -&gt; _FloatStr:\n        \"\"\"Interpolate between two values over a time window, aligned to the current frame.\n\n        This behaves like `add`, but instead of interpolating from 0 to `end_value`, it\n        interpolates from `start_value` to `end_value`, supporting numbers and ASS\n        color/alpha strings, with optional easing.\n\n        Args:\n            start_time: Window start time in milliseconds (relative to the iteration range).\n            end_time: Window end time in milliseconds (relative to the iteration range).\n            start_value: Initial value at `start_time` (number or ASS color/alpha string).\n            end_value: Final value at `end_time` (number or ASS color/alpha string).\n            acc: Easing/acceleration to apply; same semantics as in `Utils.interpolate`.\n\n        Returns:\n            The interpolated value for the current frame time.\n\n        Notes:\n            Should be called inside a loop iterating over a `FrameUtility` instance.\n\n        See Also:\n            [`add`][pyonfx.utils.FrameUtility.add].\n        \"\"\"\n        curr_ms = self.timestamps.frame_to_time(\n            self.i + (self.n_fr - 1) // 2, TimeType.END, 3, True\n        )\n\n        if curr_ms &lt;= start_time:\n            return start_value\n        elif curr_ms &gt;= end_time:\n            return end_value\n\n        curr = curr_ms - start_time\n        total = end_time - start_time\n        return Utils.interpolate(curr / total, start_value, end_value, acc)\n</code></pre>"},{"location":"reference/utils/#pyonfx.utils.FrameUtility.duration","title":"<code>duration</code>  <code>property</code>","text":"<p>Derived duration of the frame window in milliseconds.</p>"},{"location":"reference/utils/#pyonfx.utils.FrameUtility.__init__","title":"<code>__init__(start_ms, end_ms, timestamps, n_fr=1)</code>","text":"<p>Initialize the FrameUtility object.</p> <p>Parameters:</p> Name Type Description Default <code>start_ms</code> <code>int</code> <p>A positive integer representing the starting time (in milliseconds) of the interval.</p> required <code>end_ms</code> <code>int</code> <p>A positive integer representing the ending time (in milliseconds) of the interval.</p> required <code>timestamps</code> <code>ABCTimestamps | None</code> <p>An instance of <code>ABCTimestamps</code> used to convert between time values and frame numbers.</p> required <code>n_fr</code> <code>int</code> <p>An optional positive integer specifying the number of frames to process per iteration (default is 1).</p> <code>1</code> Source code in <code>pyonfx/utils.py</code> <pre><code>def __init__(\n    self,\n    start_ms: int,\n    end_ms: int,\n    timestamps: ABCTimestamps | None,\n    n_fr: int = 1,\n):\n    \"\"\"Initialize the FrameUtility object.\n\n    Args:\n        start_ms: A positive integer representing the starting time (in milliseconds) of the interval.\n        end_ms: A positive integer representing the ending time (in milliseconds) of the interval.\n        timestamps: An instance of `ABCTimestamps` used to convert between time values and frame numbers.\n        n_fr: An optional positive integer specifying the number of frames to process per iteration (default is 1).\n    \"\"\"\n    # Check for invalid values\n    if start_ms &lt; 0 or end_ms &lt; 0:\n        raise ValueError(\"Parameters 'start_ms' and 'end_ms' must be &gt;= 0.\")\n    if end_ms &lt; start_ms:\n        raise ValueError(\"Parameter 'start_ms' is expected to be &lt;= 'end_ms'.\")\n    if n_fr &lt;= 0:\n        raise ValueError(\"Parameter 'n_fr' must be &gt; 0.\")\n    if timestamps is None:\n        raise ValueError(\n            \"Parameter 'timestamps' cannot be None (hint: does your ASS file have a video specified?).\"\n        )\n\n    self.timestamps = timestamps\n    self.start_ms = start_ms\n    self.end_ms = end_ms\n\n    self.start_fr = self.curr_fr = timestamps.time_to_frame(\n        start_ms, TimeType.START, 3\n    )\n    self.end_fr = timestamps.time_to_frame(end_ms, TimeType.END, 3)\n    self.end_ms_snapped = timestamps.frame_to_time(\n        self.end_fr, TimeType.END, 3, True\n    )\n    self.n_fr = n_fr\n    self.i = 0\n    self.n = self.end_fr - self.start_fr + 1\n</code></pre>"},{"location":"reference/utils/#pyonfx.utils.FrameUtility.reset","title":"<code>reset()</code>","text":"<p>Reset the frame utility to its initial state.</p> Source code in <code>pyonfx/utils.py</code> <pre><code>def reset(self):\n    \"\"\"Reset the frame utility to its initial state.\"\"\"\n    self.i = 0\n    self.curr_fr = self.start_fr\n</code></pre>"},{"location":"reference/utils/#pyonfx.utils.FrameUtility.add","title":"<code>add(start_time, end_time, end_value, acc=1.0)</code>","text":"<p>Apply a frame-by-frame numeric transformation similar to the ASS '\\t' tag.</p> <p>This method computes an adjustment value for the current frame by interpolating between 0 and <code>end_value</code> over a specified time interval defined by <code>start_time</code> and <code>end_time</code>. Mimicking the behavior of the ASS '\\t' tag, it calculates the interpolation progress based on the midpoint of the current frame within the interval and applies an optional acceleration (easing) function (<code>acc</code>) to modulate the transformation.</p> <p>Parameters:</p> Name Type Description Default <code>start_time</code> <code>float</code> <p>The start time (in milliseconds) of the transformation interval (relative to the iteration range).</p> required <code>end_time</code> <code>float</code> <p>The end time (in milliseconds) of the transformation interval (relative to the iteration range).</p> required <code>end_value</code> <code>float</code> <p>The final adjustment value to be reached at the end of the interval.</p> required <code>acc</code> <code>float | Literal['in_back', 'out_back', 'in_out_back', 'in_bounce', 'out_bounce', 'in_out_bounce', 'in_circ', 'out_circ', 'in_out_circ', 'in_cubic', 'out_cubic', 'in_out_cubic', 'in_elastic', 'out_elastic', 'in_out_elastic', 'in_expo', 'out_expo', 'in_out_expo', 'in_quad', 'out_quad', 'in_out_quad', 'in_quart', 'out_quart', 'in_out_quart', 'in_quint', 'out_quint', 'in_out_quint', 'in_sine', 'out_sine', 'in_out_sine'] | Callable[[float], float]</code> <p>A float, string, or callable defining the acceleration function. Defaults to 1.0 for linear progression.  - If a float is provided, it acts as the exponent for the transformation.  - If a string is provided, it must correspond to a preset easing function name as defined in <code>rpeasings</code>.  - If a callable is provided, it should accept a float and return a transformed float.</p> <code>1.0</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The computed adjustment value for the current frame.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # Let's assume to have an Ass object named \"io\" having a 20 fps video (i.e. frames are 50 ms long)\n&gt;&gt;&gt; fu = FrameUtility(25, 225, io.input_timestamps)\n&gt;&gt;&gt; for s, e, i, n in fu:\n...     # We would like to transform the fsc value\n...     # from 100 up 150 for the first 100 ms,\n...     # and then from 150 to 100 for the remaining 200 ms\n...     fsc = 100\n...     fsc += fu.add(0, 100, 50)\n...     fsc += fu.add(100, 200, -50)\n...     print(f\"Frame {i}/{n}: {s} - {e}; fsc: {fsc}\")\nFrame 1/4: 25 - 75; fsc: 112.5\nFrame 2/4: 75 - 125; fsc: 137.5\nFrame 3/4: 125 - 175; fsc: 137.5\nFrame 4/4: 175 - 225; fsc: 112.5\n</code></pre> Notes <p>Should be called inside a loop iterating over a <code>FrameUtility</code> instance.</p> See Also <p><code>accelerate</code>: For transforming percentage values with easing.</p> Source code in <code>pyonfx/utils.py</code> <pre><code>def add(\n    self,\n    start_time: float,\n    end_time: float,\n    end_value: float,\n    acc: (\n        float\n        | Literal[\n            \"in_back\",\n            \"out_back\",\n            \"in_out_back\",\n            \"in_bounce\",\n            \"out_bounce\",\n            \"in_out_bounce\",\n            \"in_circ\",\n            \"out_circ\",\n            \"in_out_circ\",\n            \"in_cubic\",\n            \"out_cubic\",\n            \"in_out_cubic\",\n            \"in_elastic\",\n            \"out_elastic\",\n            \"in_out_elastic\",\n            \"in_expo\",\n            \"out_expo\",\n            \"in_out_expo\",\n            \"in_quad\",\n            \"out_quad\",\n            \"in_out_quad\",\n            \"in_quart\",\n            \"out_quart\",\n            \"in_out_quart\",\n            \"in_quint\",\n            \"out_quint\",\n            \"in_out_quint\",\n            \"in_sine\",\n            \"out_sine\",\n            \"in_out_sine\",\n        ]\n        | Callable[[float], float]\n    ) = 1.0,\n) -&gt; float:\n    \"\"\"Apply a frame-by-frame numeric transformation similar to the ASS '\\\\t' tag.\n\n    This method computes an adjustment value for the current frame by interpolating between 0 and `end_value` over a\n    specified time interval defined by `start_time` and `end_time`. Mimicking the behavior of the ASS '\\\\t' tag,\n    it calculates the interpolation progress based on the midpoint of the current frame within the interval and applies\n    an optional acceleration (easing) function (`acc`) to modulate the transformation.\n\n    Args:\n        start_time: The start time (in milliseconds) of the transformation interval (relative to the iteration range).\n        end_time: The end time (in milliseconds) of the transformation interval (relative to the iteration range).\n        end_value: The final adjustment value to be reached at the end of the interval.\n        acc: A float, string, or callable defining the acceleration function. Defaults to 1.0 for linear progression.\n             - If a float is provided, it acts as the exponent for the transformation.\n             - If a string is provided, it must correspond to a preset easing function name as defined in `rpeasings`.\n             - If a callable is provided, it should accept a float and return a transformed float.\n\n    Returns:\n        float: The computed adjustment value for the current frame.\n\n    Examples:\n        &gt;&gt;&gt; # Let's assume to have an Ass object named \"io\" having a 20 fps video (i.e. frames are 50 ms long)\n        &gt;&gt;&gt; fu = FrameUtility(25, 225, io.input_timestamps)\n        &gt;&gt;&gt; for s, e, i, n in fu:\n        ...     # We would like to transform the fsc value\n        ...     # from 100 up 150 for the first 100 ms,\n        ...     # and then from 150 to 100 for the remaining 200 ms\n        ...     fsc = 100\n        ...     fsc += fu.add(0, 100, 50)\n        ...     fsc += fu.add(100, 200, -50)\n        ...     print(f\"Frame {i}/{n}: {s} - {e}; fsc: {fsc}\")\n        Frame 1/4: 25 - 75; fsc: 112.5\n        Frame 2/4: 75 - 125; fsc: 137.5\n        Frame 3/4: 125 - 175; fsc: 137.5\n        Frame 4/4: 175 - 225; fsc: 112.5\n\n    Notes:\n        Should be called inside a loop iterating over a `FrameUtility` instance.\n\n    See Also:\n        [`accelerate`][pyonfx.utils.Utils.accelerate]: For transforming percentage values with easing.\n    \"\"\"\n    curr_ms = self.timestamps.frame_to_time(\n        self.i + (self.n_fr - 1) // 2, TimeType.END, 3, True\n    )\n\n    if curr_ms &lt;= start_time:\n        return 0\n    elif curr_ms &gt;= end_time:\n        return end_value\n\n    curr = curr_ms - start_time\n    total = end_time - start_time\n    return Utils.interpolate(curr / total, 0, end_value, acc)\n</code></pre>"},{"location":"reference/utils/#pyonfx.utils.FrameUtility.interpolate","title":"<code>interpolate(start_time, end_time, start_value, end_value, acc=1.0)</code>","text":"<p>Interpolate between two values over a time window, aligned to the current frame.</p> <p>This behaves like <code>add</code>, but instead of interpolating from 0 to <code>end_value</code>, it interpolates from <code>start_value</code> to <code>end_value</code>, supporting numbers and ASS color/alpha strings, with optional easing.</p> <p>Parameters:</p> Name Type Description Default <code>start_time</code> <code>float</code> <p>Window start time in milliseconds (relative to the iteration range).</p> required <code>end_time</code> <code>float</code> <p>Window end time in milliseconds (relative to the iteration range).</p> required <code>start_value</code> <code>_FloatStr</code> <p>Initial value at <code>start_time</code> (number or ASS color/alpha string).</p> required <code>end_value</code> <code>_FloatStr</code> <p>Final value at <code>end_time</code> (number or ASS color/alpha string).</p> required <code>acc</code> <code>float | Literal['in_back', 'out_back', 'in_out_back', 'in_bounce', 'out_bounce', 'in_out_bounce', 'in_circ', 'out_circ', 'in_out_circ', 'in_cubic', 'out_cubic', 'in_out_cubic', 'in_elastic', 'out_elastic', 'in_out_elastic', 'in_expo', 'out_expo', 'in_out_expo', 'in_quad', 'out_quad', 'in_out_quad', 'in_quart', 'out_quart', 'in_out_quart', 'in_quint', 'out_quint', 'in_out_quint', 'in_sine', 'out_sine', 'in_out_sine'] | Callable[[float], float]</code> <p>Easing/acceleration to apply; same semantics as in <code>Utils.interpolate</code>.</p> <code>1.0</code> <p>Returns:</p> Type Description <code>_FloatStr</code> <p>The interpolated value for the current frame time.</p> Notes <p>Should be called inside a loop iterating over a <code>FrameUtility</code> instance.</p> See Also <p><code>add</code>.</p> Source code in <code>pyonfx/utils.py</code> <pre><code>def interpolate(\n    self,\n    start_time: float,\n    end_time: float,\n    start_value: _FloatStr,\n    end_value: _FloatStr,\n    acc: (\n        float\n        | Literal[\n            \"in_back\",\n            \"out_back\",\n            \"in_out_back\",\n            \"in_bounce\",\n            \"out_bounce\",\n            \"in_out_bounce\",\n            \"in_circ\",\n            \"out_circ\",\n            \"in_out_circ\",\n            \"in_cubic\",\n            \"out_cubic\",\n            \"in_out_cubic\",\n            \"in_elastic\",\n            \"out_elastic\",\n            \"in_out_elastic\",\n            \"in_expo\",\n            \"out_expo\",\n            \"in_out_expo\",\n            \"in_quad\",\n            \"out_quad\",\n            \"in_out_quad\",\n            \"in_quart\",\n            \"out_quart\",\n            \"in_out_quart\",\n            \"in_quint\",\n            \"out_quint\",\n            \"in_out_quint\",\n            \"in_sine\",\n            \"out_sine\",\n            \"in_out_sine\",\n        ]\n        | Callable[[float], float]\n    ) = 1.0,\n) -&gt; _FloatStr:\n    \"\"\"Interpolate between two values over a time window, aligned to the current frame.\n\n    This behaves like `add`, but instead of interpolating from 0 to `end_value`, it\n    interpolates from `start_value` to `end_value`, supporting numbers and ASS\n    color/alpha strings, with optional easing.\n\n    Args:\n        start_time: Window start time in milliseconds (relative to the iteration range).\n        end_time: Window end time in milliseconds (relative to the iteration range).\n        start_value: Initial value at `start_time` (number or ASS color/alpha string).\n        end_value: Final value at `end_time` (number or ASS color/alpha string).\n        acc: Easing/acceleration to apply; same semantics as in `Utils.interpolate`.\n\n    Returns:\n        The interpolated value for the current frame time.\n\n    Notes:\n        Should be called inside a loop iterating over a `FrameUtility` instance.\n\n    See Also:\n        [`add`][pyonfx.utils.FrameUtility.add].\n    \"\"\"\n    curr_ms = self.timestamps.frame_to_time(\n        self.i + (self.n_fr - 1) // 2, TimeType.END, 3, True\n    )\n\n    if curr_ms &lt;= start_time:\n        return start_value\n    elif curr_ms &gt;= end_time:\n        return end_value\n\n    curr = curr_ms - start_time\n    total = end_time - start_time\n    return Utils.interpolate(curr / total, start_value, end_value, acc)\n</code></pre>"},{"location":"reference/utils/#pyonfx.utils.ColorUtility","title":"<code>ColorUtility</code>","text":"<p>Extract and manage color transformations from ASS subtitle lines.</p> <p>Parses ASS Line objects to extract color change commands (\\1c, \\3c, \\4c) and their transformations (\\t tags), and provides interpolated color values for smooth transitions during subtitle rendering.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; cu = ColorUtility(subtitle_lines)\n&gt;&gt;&gt; color_tags = cu.get_color_change(current_line)\n&gt;&gt;&gt; print(f\"Color tags: {color_tags}\")\n\\1c&amp;HFFFFFF&amp;\\t(100,200,\\1c&amp;H000000&amp;)\n</code></pre> Notes <ul> <li>Create only one ColorUtility instance per ASS file for optimal performance.</li> <li>Lines without explicit colors inherit from the last defined color state.</li> </ul> See Also <p><code>Utils.interpolate</code> for color interpolation between ASS color values.</p> Source code in <code>pyonfx/utils.py</code> <pre><code>class ColorUtility:\n    \"\"\"Extract and manage color transformations from ASS subtitle lines.\n\n    Parses ASS Line objects to extract color change commands (\\\\1c, \\\\3c, \\\\4c)\n    and their transformations (\\\\t tags), and provides interpolated color values\n    for smooth transitions during subtitle rendering.\n\n    Examples:\n        &gt;&gt;&gt; cu = ColorUtility(subtitle_lines)\n        &gt;&gt;&gt; color_tags = cu.get_color_change(current_line)\n        &gt;&gt;&gt; print(f\"Color tags: {color_tags}\")\n        \\\\1c&amp;HFFFFFF&amp;\\\\t(100,200,\\\\1c&amp;H000000&amp;)\n\n    Notes:\n        - Create only one ColorUtility instance per ASS file for optimal performance.\n        - Lines without explicit colors inherit from the last defined color state.\n\n    See Also:\n        `Utils.interpolate` for color interpolation between ASS color values.\n    \"\"\"\n\n    # Compiled regex patterns\n    _PATTERNS = {\n        \"tags\": re.compile(r\"{.*?}\"),\n        \"transform\": re.compile(r\"\\\\t\\(\\s*(-?\\d+?)\\s*,\\s*(-?\\d+?)\\s*,\\s*(.+?)\\s*\\)\"),\n        \"c1\": re.compile(r\"\\\\1c(&amp;H[0-9A-Fa-f]{6}&amp;)\"),\n        \"c3\": re.compile(r\"\\\\3c(&amp;H[0-9A-Fa-f]{6}&amp;)\"),\n        \"c4\": re.compile(r\"\\\\4c(&amp;H[0-9A-Fa-f]{6}&amp;)\"),\n    }\n\n    def __init__(self, lines: list[Line], offset: int = 0):\n        self.color_changes: list[dict[str, Any]] = []\n        self.required_colors = {\"c1\": False, \"c3\": False, \"c4\": False}\n\n        for line in lines:\n            # Extract color information from a single subtitle line\n            tags = self._PATTERNS[\"tags\"].findall(line.raw_text)\n            for tag in tags:\n                self._process_static_colors(tag, line, offset)\n                self._process_transform_colors(tag, line, offset)\n\n    def _process_static_colors(self, tag: str, line: Line, offset: int) -&gt; None:\n        \"\"\"Process static color declarations outside of transforms.\"\"\"\n        static_content = self._PATTERNS[\"transform\"].sub(\"\", tag)\n        colors = self._extract_colors(static_content)\n\n        if any(colors.values()):\n            self.color_changes.append(\n                {\n                    \"start\": line.start_time + offset,\n                    \"end\": line.start_time + offset,\n                    \"acc\": 1,\n                    **colors,\n                }\n            )\n\n    def _process_transform_colors(self, tag: str, line: Line, offset: int) -&gt; None:\n        \"\"\"Process color transformations within \\\\t tags.\"\"\"\n        transforms = self._PATTERNS[\"transform\"].findall(tag)\n\n        for start_str, end_str, content in transforms:\n            start, end = int(start_str), int(end_str)\n            parts = content.split(\",\")\n\n            if len(parts) == 1:\n                acc, color_content = 1, parts[0]\n            elif len(parts) == 2:\n                try:\n                    acc, color_content = float(parts[0]), parts[1]\n                except ValueError:\n                    continue  # Skip malformed transforms\n            else:\n                continue  # Skip malformed transforms with too many parts\n\n            colors = self._extract_colors(color_content)\n            if any(colors.values()):\n                abs_start = line.start_time + start + offset\n                abs_end = line.start_time + end + offset\n                self.color_changes.append(\n                    {\"start\": abs_start, \"end\": abs_end, \"acc\": acc, **colors}\n                )\n\n    def _extract_colors(self, content: str) -&gt; dict[str, str | None]:\n        \"\"\"Extract c1, c3, c4 colors from content string.\"\"\"\n        colors = {}\n        for color_type in [\"c1\", \"c3\", \"c4\"]:\n            match = self._PATTERNS[color_type].search(content)\n            colors[color_type] = match.group(0) if match else None\n            if match:\n                self.required_colors[color_type] = True\n        return colors\n\n    def _get_base_colors(self, line: Line) -&gt; dict[str, str]:\n        \"\"\"Get base colors from line style reference.\"\"\"\n        if line.styleref is None:\n            raise ValueError(\"Line has no styleref\")\n\n        return {\n            \"c1\": f\"\\\\1c{line.styleref.color1}\",\n            \"c3\": f\"\\\\3c{line.styleref.color3}\",\n            \"c4\": f\"\\\\4c{line.styleref.color4}\",\n        }\n\n    def _resolve_color_flags(\n        self, c1: bool | None, c3: bool | None, c4: bool | None\n    ) -&gt; dict[str, bool]:\n        \"\"\"Resolve color flags using defaults if None.\"\"\"\n        return {\n            \"c1\": self.required_colors[\"c1\"] if c1 is None else c1,\n            \"c3\": self.required_colors[\"c3\"] if c3 is None else c3,\n            \"c4\": self.required_colors[\"c4\"] if c4 is None else c4,\n        }\n\n    def get_color_change(\n        self,\n        line: Line,\n        c1: bool | None = None,\n        c3: bool | None = None,\n        c4: bool | None = None,\n    ) -&gt; str:\n        \"\"\"Generate color transformation tags for a subtitle line's time range.\n\n        Returns interpolated color changes that occur within the line's time span,\n        including base colors and transformation tags. Automatically inherits colors\n        from previous lines when not explicitly overridden.\n\n        Args:\n            line: [`Line`][pyonfx.ass_core.Line] object containing timing and style information.\n            c1: Include primary color changes. Auto-detected if None.\n            c3: Include border color changes. Auto-detected if None.\n            c4: Include shadow color changes. Auto-detected if None.\n\n        Returns:\n            str: ASS-formatted color tags for the line (e.g., \"\\\\1c&amp;HFFFFFF&amp;\\\\t(100,200,\\\\1c&amp;H000000&amp;)\").\n\n        Examples:\n            &gt;&gt;&gt; line.start_time, line.end_time = 1000, 2000\n            &gt;&gt;&gt; cu.get_color_change(line)\n            \"\\\\1c&amp;HFFFFFF&amp;\\\\3c&amp;H000000&amp;\\\\t(500,1000,\\\\1c&amp;H000000&amp;\\\\3c&amp;HFFFFFF&amp;)\"\n            &gt;&gt;&gt; cu.get_color_change(line, c1=True, c3=False, c4=False)\n            \"\\\\1c&amp;HFFFFFF&amp;\\\\t(500,1000,\\\\1c&amp;H000000&amp;)\"\n\n        See Also:\n            [`get_fr_color_change`][pyonfx.utils.ColorUtility.get_fr_color_change] for frame-by-frame color values.\n        \"\"\"\n        flags = self._resolve_color_flags(c1, c3, c4)\n        base_colors = self._get_base_colors(line)\n        current_colors = base_colors.copy()\n        transform = \"\"\n\n        # Update base colors from previous changes and build transforms\n        for change in self.color_changes:\n            if change[\"end\"] &lt;= line.start_time:\n                # Update inherited colors from completed changes\n                for color_type in [\"c1\", \"c3\", \"c4\"]:\n                    if change[color_type]:\n                        current_colors[color_type] = change[color_type]\n            elif change[\"start\"] &lt;= line.end_time:\n                # Build transformation for overlapping changes\n                rel_start = max(1, change[\"start\"] - line.start_time)\n                rel_end = max(1, change[\"end\"] - line.start_time)\n\n                transform += f\"\\\\t({rel_start},{rel_end},\"\n                if change[\"acc\"] != 1:\n                    transform += str(change[\"acc\"])\n\n                for color_type in [\"c1\", \"c3\", \"c4\"]:\n                    if flags[color_type] and change[color_type]:\n                        transform += change[color_type]\n\n                transform += \")\"\n\n        # Prepend base colors\n        result = \"\"\n        for color_type in [\"c1\", \"c3\", \"c4\"]:\n            if flags[color_type]:\n                result = current_colors[color_type] + result\n\n        return result + transform\n\n    def get_fr_color_change(\n        self,\n        line: Line,\n        c1: bool | None = None,\n        c3: bool | None = None,\n        c4: bool | None = None,\n    ) -&gt; str:\n        \"\"\"Get interpolated color values for a specific frame time.\n\n        Returns the exact color values at line.start_time by interpolating between\n        color transformations. Essential for frame-by-frame rendering where you need\n        precise color values at specific moments.\n\n        Args:\n            line: [`Line`][pyonfx.ass_core.Line] object where start_time represents the current frame time.\n            c1: Include primary color interpolation. Auto-detected if None.\n            c3: Include border color interpolation. Auto-detected if None.\n            c4: Include shadow color interpolation. Auto-detected if None.\n\n        Returns:\n            str: Interpolated ASS color tags for the exact frame time (e.g., \"\\\\1c&amp;H808080&amp;\").\n\n        Examples:\n            &gt;&gt;&gt; line.start_time = 1500  # Frame at 1.5 seconds\n            &gt;&gt;&gt; cu.get_fr_color_change(line)\n            \"\\\\1c&amp;H808080&amp;\\\\3c&amp;HFF0000&amp;\"\n            &gt;&gt;&gt; cu.get_fr_color_change(line, c1=True, c3=False)\n            \"\\\\1c&amp;H808080&amp;\"\n\n        See Also:\n            [`get_color_change`][pyonfx.utils.ColorUtility.get_color_change] for complete transformation sequences over time ranges.\n        \"\"\"\n        flags = self._resolve_color_flags(c1, c3, c4)\n        base_colors = self._get_base_colors(line)\n        current_time = line.start_time\n\n        # Find the latest applicable color change\n        latest_idx = -1\n        for i, change in enumerate(self.color_changes):\n            if current_time &gt;= change[\"start\"]:\n                latest_idx = i\n\n        # No color changes found - use style defaults\n        if latest_idx == -1:\n            return \"\".join(base_colors[ct] for ct in [\"c1\", \"c3\", \"c4\"] if flags[ct])\n\n        change = self.color_changes[latest_idx]\n\n        # Past the end of transformation - use final values\n        if current_time &gt;= change[\"end\"]:\n            colors = []\n            for color_type in [\"c1\", \"c3\", \"c4\"]:\n                if flags[color_type] and change[color_type]:\n                    colors.append(change[color_type])\n            return \"\".join(colors)\n\n        # Interpolate within the transformation\n        progress = (current_time - change[\"start\"]) / (change[\"end\"] - change[\"start\"])\n        colors = []\n\n        for color_type in [\"c1\", \"c3\", \"c4\"]:\n            if not (flags[color_type] and change[color_type]):\n                continue\n\n            # Determine start color for interpolation\n            if latest_idx == 0:\n                start_color = base_colors[color_type][3:]  # Remove \\\\Xc prefix\n            else:\n                prev_change = self.color_changes[latest_idx - 1]\n                start_color = (\n                    prev_change[color_type][3:]\n                    if prev_change[color_type]\n                    else base_colors[color_type][3:]\n                )\n\n            end_color = change[color_type][3:]  # Remove \\\\Xc prefix\n\n            interpolated = Utils.interpolate(\n                progress, start_color, end_color, change[\"acc\"]\n            )\n            colors.append(f\"\\\\{color_type[1:]}{interpolated}\")\n\n        return \"\".join(colors)\n</code></pre>"},{"location":"reference/utils/#pyonfx.utils.ColorUtility.get_color_change","title":"<code>get_color_change(line, c1=None, c3=None, c4=None)</code>","text":"<p>Generate color transformation tags for a subtitle line's time range.</p> <p>Returns interpolated color changes that occur within the line's time span, including base colors and transformation tags. Automatically inherits colors from previous lines when not explicitly overridden.</p> <p>Parameters:</p> Name Type Description Default <code>line</code> <code>Line</code> <p><code>Line</code> object containing timing and style information.</p> required <code>c1</code> <code>bool | None</code> <p>Include primary color changes. Auto-detected if None.</p> <code>None</code> <code>c3</code> <code>bool | None</code> <p>Include border color changes. Auto-detected if None.</p> <code>None</code> <code>c4</code> <code>bool | None</code> <p>Include shadow color changes. Auto-detected if None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>ASS-formatted color tags for the line (e.g., \"\\1c&amp;HFFFFFF&amp;\\t(100,200,\\1c&amp;H000000&amp;)\").</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; line.start_time, line.end_time = 1000, 2000\n&gt;&gt;&gt; cu.get_color_change(line)\n\"\\1c&amp;HFFFFFF&amp;\\3c&amp;H000000&amp;\\t(500,1000,\\1c&amp;H000000&amp;\\3c&amp;HFFFFFF&amp;)\"\n&gt;&gt;&gt; cu.get_color_change(line, c1=True, c3=False, c4=False)\n\"\\1c&amp;HFFFFFF&amp;\\t(500,1000,\\1c&amp;H000000&amp;)\"\n</code></pre> See Also <p><code>get_fr_color_change</code> for frame-by-frame color values.</p> Source code in <code>pyonfx/utils.py</code> <pre><code>def get_color_change(\n    self,\n    line: Line,\n    c1: bool | None = None,\n    c3: bool | None = None,\n    c4: bool | None = None,\n) -&gt; str:\n    \"\"\"Generate color transformation tags for a subtitle line's time range.\n\n    Returns interpolated color changes that occur within the line's time span,\n    including base colors and transformation tags. Automatically inherits colors\n    from previous lines when not explicitly overridden.\n\n    Args:\n        line: [`Line`][pyonfx.ass_core.Line] object containing timing and style information.\n        c1: Include primary color changes. Auto-detected if None.\n        c3: Include border color changes. Auto-detected if None.\n        c4: Include shadow color changes. Auto-detected if None.\n\n    Returns:\n        str: ASS-formatted color tags for the line (e.g., \"\\\\1c&amp;HFFFFFF&amp;\\\\t(100,200,\\\\1c&amp;H000000&amp;)\").\n\n    Examples:\n        &gt;&gt;&gt; line.start_time, line.end_time = 1000, 2000\n        &gt;&gt;&gt; cu.get_color_change(line)\n        \"\\\\1c&amp;HFFFFFF&amp;\\\\3c&amp;H000000&amp;\\\\t(500,1000,\\\\1c&amp;H000000&amp;\\\\3c&amp;HFFFFFF&amp;)\"\n        &gt;&gt;&gt; cu.get_color_change(line, c1=True, c3=False, c4=False)\n        \"\\\\1c&amp;HFFFFFF&amp;\\\\t(500,1000,\\\\1c&amp;H000000&amp;)\"\n\n    See Also:\n        [`get_fr_color_change`][pyonfx.utils.ColorUtility.get_fr_color_change] for frame-by-frame color values.\n    \"\"\"\n    flags = self._resolve_color_flags(c1, c3, c4)\n    base_colors = self._get_base_colors(line)\n    current_colors = base_colors.copy()\n    transform = \"\"\n\n    # Update base colors from previous changes and build transforms\n    for change in self.color_changes:\n        if change[\"end\"] &lt;= line.start_time:\n            # Update inherited colors from completed changes\n            for color_type in [\"c1\", \"c3\", \"c4\"]:\n                if change[color_type]:\n                    current_colors[color_type] = change[color_type]\n        elif change[\"start\"] &lt;= line.end_time:\n            # Build transformation for overlapping changes\n            rel_start = max(1, change[\"start\"] - line.start_time)\n            rel_end = max(1, change[\"end\"] - line.start_time)\n\n            transform += f\"\\\\t({rel_start},{rel_end},\"\n            if change[\"acc\"] != 1:\n                transform += str(change[\"acc\"])\n\n            for color_type in [\"c1\", \"c3\", \"c4\"]:\n                if flags[color_type] and change[color_type]:\n                    transform += change[color_type]\n\n            transform += \")\"\n\n    # Prepend base colors\n    result = \"\"\n    for color_type in [\"c1\", \"c3\", \"c4\"]:\n        if flags[color_type]:\n            result = current_colors[color_type] + result\n\n    return result + transform\n</code></pre>"},{"location":"reference/utils/#pyonfx.utils.ColorUtility.get_fr_color_change","title":"<code>get_fr_color_change(line, c1=None, c3=None, c4=None)</code>","text":"<p>Get interpolated color values for a specific frame time.</p> <p>Returns the exact color values at line.start_time by interpolating between color transformations. Essential for frame-by-frame rendering where you need precise color values at specific moments.</p> <p>Parameters:</p> Name Type Description Default <code>line</code> <code>Line</code> <p><code>Line</code> object where start_time represents the current frame time.</p> required <code>c1</code> <code>bool | None</code> <p>Include primary color interpolation. Auto-detected if None.</p> <code>None</code> <code>c3</code> <code>bool | None</code> <p>Include border color interpolation. Auto-detected if None.</p> <code>None</code> <code>c4</code> <code>bool | None</code> <p>Include shadow color interpolation. Auto-detected if None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Interpolated ASS color tags for the exact frame time (e.g., \"\\1c&amp;H808080&amp;\").</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; line.start_time = 1500  # Frame at 1.5 seconds\n&gt;&gt;&gt; cu.get_fr_color_change(line)\n\"\\1c&amp;H808080&amp;\\3c&amp;HFF0000&amp;\"\n&gt;&gt;&gt; cu.get_fr_color_change(line, c1=True, c3=False)\n\"\\1c&amp;H808080&amp;\"\n</code></pre> See Also <p><code>get_color_change</code> for complete transformation sequences over time ranges.</p> Source code in <code>pyonfx/utils.py</code> <pre><code>def get_fr_color_change(\n    self,\n    line: Line,\n    c1: bool | None = None,\n    c3: bool | None = None,\n    c4: bool | None = None,\n) -&gt; str:\n    \"\"\"Get interpolated color values for a specific frame time.\n\n    Returns the exact color values at line.start_time by interpolating between\n    color transformations. Essential for frame-by-frame rendering where you need\n    precise color values at specific moments.\n\n    Args:\n        line: [`Line`][pyonfx.ass_core.Line] object where start_time represents the current frame time.\n        c1: Include primary color interpolation. Auto-detected if None.\n        c3: Include border color interpolation. Auto-detected if None.\n        c4: Include shadow color interpolation. Auto-detected if None.\n\n    Returns:\n        str: Interpolated ASS color tags for the exact frame time (e.g., \"\\\\1c&amp;H808080&amp;\").\n\n    Examples:\n        &gt;&gt;&gt; line.start_time = 1500  # Frame at 1.5 seconds\n        &gt;&gt;&gt; cu.get_fr_color_change(line)\n        \"\\\\1c&amp;H808080&amp;\\\\3c&amp;HFF0000&amp;\"\n        &gt;&gt;&gt; cu.get_fr_color_change(line, c1=True, c3=False)\n        \"\\\\1c&amp;H808080&amp;\"\n\n    See Also:\n        [`get_color_change`][pyonfx.utils.ColorUtility.get_color_change] for complete transformation sequences over time ranges.\n    \"\"\"\n    flags = self._resolve_color_flags(c1, c3, c4)\n    base_colors = self._get_base_colors(line)\n    current_time = line.start_time\n\n    # Find the latest applicable color change\n    latest_idx = -1\n    for i, change in enumerate(self.color_changes):\n        if current_time &gt;= change[\"start\"]:\n            latest_idx = i\n\n    # No color changes found - use style defaults\n    if latest_idx == -1:\n        return \"\".join(base_colors[ct] for ct in [\"c1\", \"c3\", \"c4\"] if flags[ct])\n\n    change = self.color_changes[latest_idx]\n\n    # Past the end of transformation - use final values\n    if current_time &gt;= change[\"end\"]:\n        colors = []\n        for color_type in [\"c1\", \"c3\", \"c4\"]:\n            if flags[color_type] and change[color_type]:\n                colors.append(change[color_type])\n        return \"\".join(colors)\n\n    # Interpolate within the transformation\n    progress = (current_time - change[\"start\"]) / (change[\"end\"] - change[\"start\"])\n    colors = []\n\n    for color_type in [\"c1\", \"c3\", \"c4\"]:\n        if not (flags[color_type] and change[color_type]):\n            continue\n\n        # Determine start color for interpolation\n        if latest_idx == 0:\n            start_color = base_colors[color_type][3:]  # Remove \\\\Xc prefix\n        else:\n            prev_change = self.color_changes[latest_idx - 1]\n            start_color = (\n                prev_change[color_type][3:]\n                if prev_change[color_type]\n                else base_colors[color_type][3:]\n            )\n\n        end_color = change[color_type][3:]  # Remove \\\\Xc prefix\n\n        interpolated = Utils.interpolate(\n            progress, start_color, end_color, change[\"acc\"]\n        )\n        colors.append(f\"\\\\{color_type[1:]}{interpolated}\")\n\n    return \"\".join(colors)\n</code></pre>"},{"location":"tutorials/installing/","title":"Install &amp; Set-up","text":""},{"location":"tutorials/installing/#prerequisites","title":"Prerequisites","text":"<p>To get started with PyonFX, we recommend that you have some knowledge on:</p> <ul> <li>Python 3: familiarity with basic constructs like variables, functions, conditions, loops, comparisons, string formatting, lists, and dictionaries<sup>1</sup>;</li> <li>ASS/SSA Tags: familiarity with ASS tags<sup>2</sup>;</li> </ul>"},{"location":"tutorials/installing/#installation","title":"Installation","text":"Windows <p>Download and install Python 3 from the official website. Ensure you check \"Add Python 3.x to PATH\". Then, install PyonFX:</p> <pre><code>pip install --upgrade pyonfx\n</code></pre> Ubuntu/Debian <p>Install prerequisites:</p> <pre><code>sudo apt-get update\nsudo apt-get install libgirepository-2.0-dev gobject-introspection libcairo2-dev python3-dev build-essential gir1.2-gtk-3.0 python3-gi python3-gi-cairo\n</code></pre> <p>Then, install PyonFX:</p> <pre><code>python3 -m pip install --upgrade pyonfx\n</code></pre> macOS <p>Install Homebrew if needed, then install prerequisites:</p> <pre><code>brew install python py3cairo pygobject3 pango cairo glib\n</code></pre> <p>Then, install PyonFX:</p> <pre><code>python3 -m pip install --upgrade pyonfx\n</code></pre> <p>If you encounter rendering issues, try:</p> <pre><code>PANGOCAIRO_BACKEND=fc python3 namefile.py\n</code></pre>"},{"location":"tutorials/installing/#additional-setup","title":"Additional Setup","text":"<p>Enhance your development workflow by setting up your environment as follows:</p> <ul> <li>We recommend Visual Studio Code as your text editor. For helpful code suggestions and error checking, install the Python extension and, if desired, Pylance for enhanced type support;</li> <li>If you want your Python script to run automatically every time you save, also add the RunOnSave extension;</li> <li>Install the MPV player for lightweight, hot-reload output preview without relying on Aegisub. On Windows, add the folder containing MPV\u2019s executable (typically <code>C:\\Program Files\\mpv</code>) to your system PATH (if you don't know how, follow this guide).</li> </ul>"},{"location":"tutorials/installing/#whats-next","title":"What's next","text":"<p>After completing these steps, you can start learning how to use the library! We prepared a series of tutorials for you, starting from Exploring ASS values.</p> <ol> <li> <p>For beginners, we suggest starting with this this comprehensive video guide, which introduces the basics of Python step by step. If you want to explore further, \"Think Python 2\" is an excellent free PDF book (in English) that covers core programming concepts in more depth.\u00a0\u21a9</p> </li> <li> <p>For a comprehensive guide to ASS tags, see the Aegisub official documentation.\u00a0\u21a9</p> </li> </ol>"},{"location":"tutorials/0-first-steps/01-explore-ass-values/","title":"Tutorial: Exploring ASS Values with PyonFX","text":"<p>Welcome to the first tutorial of PyonFX! In this guide, you'll learn how to use PyonFX to process an ASS file, extract its data, and explore its structure effectively.</p> <p>We assume you have already read the Install &amp; Set-up tutorial.</p>"},{"location":"tutorials/0-first-steps/01-explore-ass-values/#materials","title":"Materials","text":"<p>Before starting, please download the following ASS file: hello_world.ass</p> <p>We will use this file throughout the current and future tutorials.</p>"},{"location":"tutorials/0-first-steps/01-explore-ass-values/#code-walkthrough","title":"Code Walkthrough","text":"<p>0. Importing PyonFX</p> <p>Let's start by importing PyonFX. It's a good practice to import only the classes you need, so for this tutorial we'll import only the <code>Ass</code> class.</p> <pre><code>from pyonfx import Ass\n</code></pre> <p>The <code>Ass</code> class is the primary interface for working with ASS files. It handles file loading, parsing, manipulation, and output generation, serving as your main tool for subtitle processing.</p> <p>1. Loading and Parsing the ASS File</p> <p>Next, we load the ASS file using the <code>Ass</code> class. The string you pass to <code>Ass(...)</code> is the path to your <code>.ass</code> subtitle file \u2014 it can be either relative (like <code>\"hello_world.ass\"</code>) or absolute (for example <code>\"C:\\\\videos\\\\subs\\\\hello_world.ass\"</code>). Upon initialization, the class immediately parses the file, and you can access the data using the <code>get_data</code> method (see the Ass documentation for details):</p> <pre><code>io = Ass(\"hello_world.ass\")\nmeta, styles, lines = io.get_data()\n</code></pre> <p>Now you have three important objects to work with:</p> <ul> <li><code>meta</code>: contains metadata from the ASS file</li> <li><code>styles</code>: a dictionary of styles defined in the ASS file</li> <li><code>lines</code>: a list of dialogue lines with detailed segmentation</li> </ul> <p>2. Displaying ASS Data</p> <p>Let's take a closer look at these objects.</p> <p>Viewing Metadata:</p> <p>Print the <code>meta</code> object to see the extracted metadata:</p> <pre><code>print(meta)\n</code></pre> Show Output <pre><code>Meta(wrap_style=0, scaled_border_and_shadow=True, play_res_x=1280, play_res_y=720, audio=None, video='?dummy:23.976000:480:1280:720:59:59:59:', timestamps=&lt;video_timestamps.fps_timestamps.FPSTimestamps object at 0x000001FB6F9864B0&gt;)\n</code></pre> <p>Notably, the metadata includes audio and video file references (<code>audio</code> and <code>video</code>), display resolution (<code>play_res_x</code> and <code>play_res_y</code>), and a timestamp object associated with the video file (<code>timestamps</code>). For a complete list of attributes and their meanings, refer to the Meta documentation.</p> <p>Exploring Styles:</p> <p>To inspect the styles, iterate over the <code>styles</code> dictionary:</p> <pre><code>for style_name, style in styles.items():\n    print(f'\"{style_name}\": {style}\\n')\n</code></pre> Show Output <pre><code>\"Romaji\": Style(name='Romaji', fontname='Arial', fontsize=40.0, color1='&amp;HFFFFFF&amp;', alpha1='&amp;H00&amp;', color2='&amp;H0000FF&amp;', alpha2='&amp;H00&amp;', color3='&amp;H000000&amp;', alpha3='&amp;H00&amp;', color4='&amp;H000000&amp;', alpha4='&amp;H00&amp;', bold=True, italic=False, underline=False, strikeout=False, scale_x=100.0, scale_y=100.0, spacing=0.0, angle=0.0, border_style=False, outline=2.0, shadow=0.0, alignment=8, margin_l=12, margin_r=15, margin_v=15, encoding=1)\n\n\"Subtitle\": Style(name='Subtitle', fontname='Arial', fontsize=40.0, color1='&amp;HFFFFFF&amp;', alpha1='&amp;H00&amp;', color2='&amp;H0000FF&amp;', alpha2='&amp;H00&amp;', color3='&amp;H000000&amp;', alpha3='&amp;H00&amp;', color4='&amp;H000000&amp;', alpha4='&amp;H00&amp;', bold=True, italic=False, underline=False, strikeout=False, scale_x=100.0, scale_y=100.0, spacing=0.0, angle=0.0, border_style=False, outline=2.0, shadow=0.0, alignment=2, margin_l=12, margin_r=15, margin_v=15, encoding=1)\n</code></pre> <p>This should look familiar! The structure closely resembles what you'd find in Aegisub's style editor:</p> <p></p> <p>For more details on each attribute, see the Style documentation.</p> <p>Inspecting Dialogue Lines:</p> <p>Now, let's print the first dialogue line to observe its structure:</p> <pre><code>print(lines[0])\n</code></pre> Show Output <pre><code>Line(comment=False, layer=0, start_time=1000, end_time=3000, style='Romaji', styleref=Style(fontname='Arial', ...), actor='', margin_l=0, margin_r=0, margin_v=0, effect='', raw_text='{\\\\k50}Hel{\\\\k50}lo {\\\\k50}world!', text='Hello world!', i=0, leadin=1001, leadout=1001, width=204.84375, height=40.0, ascent=32.40625, descent=7.59375, internal_leading=4.203125, external_leading=1.171875, x=638.5, y=15, left=536.078125, center=638.5, right=740.921875, top=15, middle=35.0, bottom=55.0, words=[Word(i=0, text='Hello', ...), ... (+1 more)], syls=[Syllable(i=0, text='Hel', ...), ... (+2 more)], chars=[Char(i=0, text='H', ...), ... (+11 more)])\n</code></pre> <p>This should also look familiar \u2014 it contains many properties you'd find in Aegisub's Line Editor: </p> <p>In particular, you can see timing information (<code>start_time</code> and <code>end_time</code>), the applied style name and its corresponding object (<code>style</code> and <code>styleref</code>), and both raw text and its version stripped of ASS tags (<code>raw_text</code> and <code>text</code>). There are many other attributes, but don't worry about them for now.</p> <p>Most importantly, each <code>Line</code> object contains segmented data:</p> <ul> <li><code>Word</code> objects: segments of the line's text split by spaces</li> <li><code>Syllable</code> objects: segments of the line's text defined by karaoke timing tags (<code>\\k</code>)</li> <li><code>Char</code> objects: the individual characters of the line's text</li> </ul> <p>Let's examine these segments by printing the first word, syllable, and character of the first line:</p> <pre><code>print(lines[0].words[0], \"\\n\")\nprint(lines[0].syls[0], \"\\n\")\nprint(lines[0].chars[0], \"\\n\")\n</code></pre> Show Output <pre><code>Word(i=0, start_time=1000, end_time=3000, styleref=Style(fontname='Arial', ...), text='Hello', prespace=0, postspace=1, width=87.515625, height=40.0, x=579.8359375, y=15, left=536.078125, center=579.8359375, right=623.59375, top=15, middle=35.0, bottom=55.0)\n\nSyllable(i=0, word_i=0, start_time=0, end_time=500, styleref=Style(fontname='Arial', ...), text='Hel', tags='\\\\k50', inline_fx='', prespace=0, postspace=0, width=55.703125, height=40.0, x=563.9296875, y=15, left=536.078125, center=563.9296875, right=591.78125, top=15, middle=35.0, bottom=55.0)\n\nChar(i=0, word_i=0, syl_i=0, syl_char_i=0, start_time=0, end_time=500, styleref=Style(fontname='Arial', ...), text='H', inline_fx='', width=25.84375, height=40.0, x=549.0, y=15, left=536.078125, center=549.0, right=561.921875, top=15, middle=35.0, bottom=55.0)\n</code></pre> <p>Notice how many attributes from the parent <code>Line</code> are shared with its words, syllables, and characters.</p>"},{"location":"tutorials/0-first-steps/01-explore-ass-values/#conclusion","title":"Conclusion","text":"<p>Good job. You've successfully explored the structure of an ASS file using PyonFX. In this tutorial, you learned how to load and parse an ASS file, inspect its metadata, review style configurations, and examine the segmentation of dialogue into words, syllables, and characters.</p> <p>Up next, we'll guide you through writing your first line in a new ASS file.</p>"},{"location":"tutorials/0-first-steps/01-explore-ass-values/#full-source-code","title":"Full Source Code","text":"Show full source code <pre><code>\"\"\"\nTutorial: Exploring ASS Structure\n\nIn this tutorial, you'll learn how PyonFX reads an ASS file and converts it into structured objects:\n\u2022 Meta data about the subtitle file\n\u2022 Styles that define appearance\n\u2022 Lines that are further broken down into words, syllables, and characters\n\nExercise:\n\u2022 Experiment parsing a different ASS file to see how the printed values change.\n\"\"\"\n\nfrom pyonfx import Ass\n\n# Load the input ASS file and get the data\nio = Ass(\"../../ass/hello_world.ass\")\nmeta, styles, lines = io.get_data()\n\n# Print the META object\nprint(\"\ud83d\udccb META OBJECT:\")\nprint(f\"{meta}\\n\")\n\n# Print the STYLES dictionary\nprint(\"\ud83c\udfa8 STYLES:\")\nfor style_name, style in styles.items():\n    print(f'\"{style_name}\": {style}\\n')\n\n# Print the LINES list\nprint(\"\ud83d\udcdd LINES:\")\nfor line in lines:\n    print(f\"{line}\\n\")\n\n# Print the first word of the first line\nprint(\"\ud83d\udd24 FIRST WORD OF THE FIRST LINE:\")\nprint(f\"{lines[0].words[0]}\\n\")\n\n# Print the first syllable of the first line\nprint(\"\ud83c\udfa4 FIRST SYLLABLE OF THE FIRST LINE:\")\nprint(f\"{lines[0].syls[0]}\\n\")\n\n# Print the first char of the first line\nprint(\"\ud83c\udd70\ufe0f  FIRST CHAR OF THE FIRST LINE:\")\nprint(f\"{lines[0].chars[0]}\\n\")\n</code></pre>"},{"location":"tutorials/0-first-steps/02-hello-world/","title":"Tutorial: Hello World with PyonFX","text":"<p>In this tutorial, you'll learn how to create a new subtitle line and produce a new ASS file with your changes.</p>"},{"location":"tutorials/0-first-steps/02-hello-world/#materials","title":"Materials","text":"<p>We'll continue working with the hello_world.ass file of the previous tutorial.</p>"},{"location":"tutorials/0-first-steps/02-hello-world/#code-walkthrough","title":"Code Walkthrough","text":"<p>0. Importing PyonFX</p> <p>We start by importing the <code>Ass</code> class from PyonFX.</p> <pre><code>from pyonfx import Ass\n</code></pre> <p>1. Setting Up Input and Output Files</p> <p>The <code>Ass</code> class does more than just parse input files\u2014it also manages output generation. When initializing an <code>Ass</code> object, you can specify both input and output file paths:</p> <pre><code>io = Ass(\"hello_world.ass\", path_output=\"output.ass\")\n</code></pre> <p>This setup creates an output buffer that will become your new ASS file. By default, PyonFX copies all original lines to the output but comments them out, so you can see both the original content and your modifications. You can control this behavior with the <code>keep_original</code> parameter\u2014see the Ass initialization documentation for more details.</p> <p>Now let's extract the data from our input file as we did in the previous tutorial:</p> <pre><code>meta, styles, lines = io.get_data()\n</code></pre> <p>2. Creating a Copy of a Line</p> <p>When creating new lines in PyonFX, always start by copying an existing line rather than building one from scratch:</p> <pre><code>output_line = lines[0].copy()\n</code></pre> <p>The <code>copy()</code> method duplicates everything: timing information, style, actor/effect fields, margins, and more. This approach saves significant effort because manually setting up a new line requires configuring dozens of attributes correctly.</p> <p>Starting with a copy means you only need to modify the specific properties you want to change\u2014typically <code>text</code>, <code>start_time</code>, <code>end_time</code>, and <code>layer</code>.</p> <p>3. Modifying the Line</p> <p>Now we can safely modify our copied line. Let's change the text to demonstrate the modification:</p> <pre><code>output_line.text = \"I am a new line!\"\n</code></pre> <p>4. Adding the Line to Output</p> <p>After modifying the line, add it to the output buffer using the <code>write_line()</code> method:</p> <pre><code>io.write_line(output_line)\n</code></pre> <p>This queues your modified line for inclusion in the final output file. You can call <code>write_line()</code> multiple times to add as many lines as needed.</p> <p>5. Saving the Output File</p> <p>Once you've added all your new lines, save the output buffer to disk:</p> <pre><code>io.save()\n</code></pre> <p>This writes the complete ASS file to your specified output path (<code>output.ass</code> in our example), including any commented original lines and your new modifications. The <code>save()</code> method also automatically prints helpful statistics about your processing:</p> Show Output <pre><code>\ud83d\udc30 Produced lines: 1\n\u23f1\ufe0f Total runtime: 0.0s (avg 0.021s per generated line)\n</code></pre> <p>These metrics help you track your subtitle generation progress and performance. If you prefer to suppress these messages, you can use <code>io.save(quiet=True)</code>.</p> <p>6. Previewing in Aegisub</p> <p>PyonFX provides a convenient method to open your output file directly in Aegisub for review:</p> <pre><code>io.open_aegisub()  # requires Aegisub to be installed and available in your system PATH\n</code></pre> <p>When Aegisub opens, you'll see something like this:</p> <p></p> <p>Notice how the original lines appear commented out, while your new line appears as an active subtitle with the same timing and styling as the original but with your modified text.</p>"},{"location":"tutorials/0-first-steps/02-hello-world/#conclusion","title":"Conclusion","text":"<p>Good job. You've successfully learned the fundamental workflow for creating modified ASS files with PyonFX. In this tutorial, you discovered how to set up input and output files, copy existing lines as templates, modify line properties, and save your changes. This pattern of copying, modifying, and writing lines forms the foundation for more complex subtitle effects and transformations.</p> <p>In the next tutorial, we'll dive into line positioning and timing, exploring how to precisely control where and when your subtitles appear on screen using PyonFX's positioning properties and alignment options.</p>"},{"location":"tutorials/0-first-steps/02-hello-world/#full-source-code","title":"Full Source Code","text":"Show full source code <pre><code>\"\"\"\nTutorial: Creating Outputs with PyonFX\n\nThis tutorial covers the basic workflow to produce a new subtitle output:\n\u2022 Loading and parsing an ASS file\n\u2022 Copying and modifying an existing subtitle line\n\u2022 Writing the modified line to the output\n\nExercise:\n\u2022 Try changing the text of the copied line, or the start and end times.\n\"\"\"\n\nfrom pyonfx import Ass\n\n# Load the input ASS file and get the data\nio = Ass(\"../../ass/hello_world.ass\", path_output=\"output.ass\")\nmeta, styles, lines = io.get_data()\n\n# Create a copy of the first line for the output\noutput_line = lines[0].copy()\n\n# Modify the text of the output line\noutput_line.text = \"I am a new line!\"  # Change the text\n\n# Write the line to the output file\nio.write_line(output_line)\n\n# Save the output file\nio.save()\n\n# Open the output in Aegisub\nio.open_aegisub()\n\n# REMEMBER: always duplicate lines for output \u2014 keep the original intact\n</code></pre>"},{"location":"tutorials/0-first-steps/03-time-and-space/","title":"Tutorial: Timing &amp; Positioning with PyonFX","text":"<p>In this tutorial, you'll explore two fundamental aspects of subtitle manipulation: positioning and timing. You'll learn how to precisely place subtitles anywhere on screen using PyonFX's positioning properties, and how to control when they appear and disappear.</p>"},{"location":"tutorials/0-first-steps/03-time-and-space/#materials","title":"Materials","text":"<p>As with previous tutorials, we'll continue working with the hello_world.ass file.</p>"},{"location":"tutorials/0-first-steps/03-time-and-space/#understanding-ass-alignment-numbers","title":"Understanding ASS Alignment Numbers","text":"<p>Before diving into the code, let's recall how the <code>\\an</code> alignment tag works and review the corresponding numbers. These numbers (1-9) determine how text is positioned relative to a given coordinate point:</p> <pre><code>7 \u2500 8 \u2500 9    (Top)\n\u2502   \u2502   \u2502\n4 \u2500 5 \u2500 6    (Middle)\n\u2502   \u2502   \u2502\n1 \u2500 2 \u2500 3    (Bottom)\n</code></pre> <ul> <li>1-3: Bottom alignment (text sits above the coordinate)</li> <li>4-6: Middle alignment (text centers on the coordinate)</li> <li>7-9: Top alignment (text sits below the coordinate)</li> <li>1,4,7: Left alignment (text extends right from the coordinate)</li> <li>2,5,8: Center alignment (text centers on the coordinate)</li> <li>3,6,9: Right alignment (text extends left from the coordinate)</li> </ul>"},{"location":"tutorials/0-first-steps/03-time-and-space/#code-walkthrough","title":"Code Walkthrough","text":"<p>0. Setup and Data Loading</p> <p>We begin with the familiar setup from previous tutorials:</p> <pre><code>from pyonfx import Ass\n\n# Load the input ASS file and get the data\nio = Ass(\"hello_world.ass\")\nmeta, styles, lines = io.get_data()\n\n# Create a copy of the first line for the output\nline = lines[0]\nl = line.copy()\n</code></pre> <p>From this tutorial onwards, we'll use the shorter variable name <code>l</code> for our line copies instead of longer names like <code>output_line</code>. Since we'll be creating many line copies in advanced effects, this shorter naming convention will keep our code more readable and concise.</p> <p>1. Understanding Timing Control</p> <p>Before exploring positioning, let's first understand how to control when our subtitle appears. We can modify the timing of our copied line:</p> <pre><code># Change the timing of our copied line\nl.start_time = 0\nl.end_time = 500\n</code></pre> <p>This sets the line to display from 0ms to 500ms (half a second).</p> <p>2. Positioning Properties</p> <p>PyonFX provides convenient properties for accessing different anchor points of a line:</p> <ul> <li>Horizontal positions: <code>line.left</code>, <code>line.center</code>, <code>line.right</code></li> <li>Vertical positions: <code>line.top</code>, <code>line.middle</code>, <code>line.bottom</code></li> </ul> <p>These properties represent pixel coordinates based on the text's layout and the video resolution.</p> <p>Note: while we're exploring these with full lines in this tutorial, these positioning properties become even more powerful when working with individual words, syllables, and characters within a line\u2014allowing you to position each text element precisely where it originally appeared when creating advanced karaoke effects.</p> <p>Now let's see how positioning works in practice. The original line in our ASS file uses a specific alignment number (<code>an8</code> for top-center). When rendered normally, you see the subtitle positioned according to that alignment at coordinates determined by the subtitle renderer.</p> <p>But what if we want to take control and position our subtitle exactly where we want it? We can use PyonFX's positioning properties combined with the <code>\\pos()</code> tag to place text at precise pixel coordinates.</p> <p>For example, let's position our line using bottom-left alignment (<code>an1</code>) but place it exactly where the original text appeared:</p> <pre><code>l.text = \"{\\\\an1\\\\pos(%.3f,%.3f)}%s\" % (line.left, line.bottom, line.text)\nio.write_line(l)\n</code></pre> <p>Here's what's happening:</p> <ul> <li><code>\\\\an1</code> sets the alignment to bottom-left</li> <li><code>\\\\pos(%.3f,%.3f)</code> positions the text at specific pixel coordinates, which are passed as arguments:<ul> <li><code>line.left</code> gives us the left edge coordinate of the original text</li> <li><code>line.bottom</code> gives us the bottom edge coordinate of the original text</li> </ul> </li> <li>Finally, we use the <code>%s</code> placeholder to insert the original text.</li> </ul> <p>Together, these place our <code>an1</code>-aligned text exactly where the original text appeared. Notice the difference in the control point position rendered in Aegisub:</p> <p></p> <p>3. Demonstrating All Nine Alignments</p> <p>We can apply this same principle to all nine alignment numbers. Each alignment uses different combinations of PyonFX's positioning properties:</p> <ul> <li>Bottom alignments: <code>line.bottom</code> for vertical position</li> <li>Middle alignments: <code>line.middle</code> for vertical position  </li> <li>Top alignments: <code>line.top</code> for vertical position</li> <li>Left alignments: <code>line.left</code> for horizontal position</li> <li>Center alignments: <code>line.center</code> for horizontal position</li> <li>Right alignments: <code>line.right</code> for horizontal position</li> </ul> <p>Let's create nine lines, each with different timing and a unique color to distinguish them visually:</p> <pre><code># an1 - Bottom Left\nl.start_time = 0\nl.end_time = 500\nl.text = \"{\\\\an1\\\\pos(%.3f,%.3f)\\\\1c&amp;H4B19E6&amp;}%s\" % (line.left, line.bottom, line.text)\nio.write_line(l)\n\n# an2 - Bottom Center\nl.start_time = 500\nl.end_time = 1000\nl.text = \"{\\\\an2\\\\pos(%.3f,%.3f)\\\\1c&amp;H4BB43C&amp;}%s\" % (line.center, line.bottom, line.text)\nio.write_line(l)\n\n# ... and so on for all nine alignments\n</code></pre> <p>Each line is positioned to appear in exactly the same visual location as the original, but uses a different alignment number and displays at a different time with a unique color.</p> <p>4. The Complete Nine-Alignment Demonstration</p> <p>If you continue with all the other alignments, you'll get a 4.5-second sequence where the same text appears in all nine alignment positions, with a different color for each alignment:</p> <ul> <li>0.0-0.5s: Bottom Left (an1)</li> <li>0.5-1.0s: Bottom Center (an2)  </li> <li>1.0-1.5s: Bottom Right (an3)</li> <li>1.5-2.0s: Middle Left (an4)</li> <li>2.0-2.5s: Perfect Center (an5)</li> <li>2.5-3.0s: Middle Right (an6)</li> <li>3.0-3.5s: Top Left (an7)</li> <li>3.5-4.0s: Top Center (an8)</li> <li>4.0-4.5s: Top Right (an9)</li> </ul> <p>5. Saving and Previewing</p> <p>As always, we finish by saving our output and opening it in Aegisub:</p> <pre><code>io.save()\nio.open_aegisub()\n</code></pre> <p>In the preview, you'll see your 9 new lines, each rendered as follows:</p> <p></p>"},{"location":"tutorials/0-first-steps/03-time-and-space/#conclusion","title":"Conclusion","text":"<p>Great progress. You've mastered the fundamentals of subtitle positioning and timing with PyonFX. You now understand how ASS alignment numbers work, how to use PyonFX's positioning properties to place text precisely, and how to control your generated lines' timing.</p> <p>In the next tutorial, we'll explore how to combine these positioning and timing concepts with text segments (words, syllables, and characters).</p>"},{"location":"tutorials/0-first-steps/03-time-and-space/#full-source-code","title":"Full Source Code","text":"Show full source code <pre><code>\"\"\"\nTutorial: Lines' Positioning and Timing\n\nIn this tutorial, you will explore the various properties of a Line object:\n\u2022 Positioning: understand the horizontal and vertical position properties,\n               and how to use them combined with alignments to position subtitles precisely on the screen\n\u2022 Timing: understand the start_time and end_time properties,\n          and how to use them to control the timing of subtitles\n\nExercise:\n\u2022 Try changing the timing and/or position of the copied line and check how the output changes.\n\"\"\"\n\nfrom pyonfx import Ass\n\n# Load the input ASS file and get the data\nio = Ass(\"../../ass/hello_world.ass\")\nmeta, styles, lines = io.get_data()\n\n# Create a copy of the first line for the output\nline = lines[0]\nl = line.copy()\n\n# an1 - Bottom Left \u2192 use line.left, line.bottom\nl.start_time = 0\nl.end_time = 500\nl.text = \"{\\\\an1\\\\pos(%.3f,%.3f)\\\\1c&amp;H4B19E6&amp;}%s\" % (line.left, line.bottom, line.text)\nio.write_line(l)\n\n# an2 - Bottom Center \u2192 use line.center, line.bottom\nl.start_time = 500\nl.end_time = 1000\nl.text = \"{\\\\an2\\\\pos(%.3f,%.3f)\\\\1c&amp;H4BB43C&amp;}%s\" % (\n    line.center,\n    line.bottom,\n    line.text,\n)\nio.write_line(l)\n\n# an3 - Bottom Right \u2192 use line.right, line.bottom\nl.start_time = 1000\nl.end_time = 1500\nl.text = \"{\\\\an3\\\\pos(%.3f,%.3f)\\\\1c&amp;H19E1FF&amp;}%s\" % (line.right, line.bottom, line.text)\nio.write_line(l)\n\n# an4 - Middle Left \u2192 use line.left, line.middle\nl.start_time = 1500\nl.end_time = 2000\nl.text = \"{\\\\an4\\\\pos(%.3f,%.3f)\\\\1c&amp;HD86343&amp;}%s\" % (line.left, line.middle, line.text)\nio.write_line(l)\n\n# an5 - Center \u2192 use line.center, line.middle (or just line.x, line.y)\nl.start_time = 2000\nl.end_time = 2500\nl.text = \"{\\\\an5\\\\pos(%.3f,%.3f)\\\\1c&amp;H3182F5&amp;}%s\" % (\n    line.center,\n    line.middle,\n    line.text,\n)\nio.write_line(l)\n\n# an6 - Middle Right \u2192 use line.right, line.middle\nl.start_time = 2500\nl.end_time = 3000\nl.text = \"{\\\\an6\\\\pos(%.3f,%.3f)\\\\1c&amp;HB41E91&amp;}%s\" % (line.right, line.middle, line.text)\nio.write_line(l)\n\n# an7 - Top Left \u2192 use line.left, line.top\nl.start_time = 3000\nl.end_time = 3500\nl.text = \"{\\\\an7\\\\pos(%.3f,%.3f)\\\\1c&amp;HF0F046&amp;}%s\" % (line.left, line.top, line.text)\nio.write_line(l)\n\n# an8 - Top Center \u2192 use line.center, line.top\nl.start_time = 3500\nl.end_time = 4000\nl.text = \"{\\\\an8\\\\pos(%.3f,%.3f)\\\\1c&amp;HE632F0&amp;}%s\" % (line.center, line.top, line.text)\nio.write_line(l)\n\n# an9 - Top Right \u2192 use line.right, line.top\nl.start_time = 4000\nl.end_time = 4500\nl.text = \"{\\\\an9\\\\pos(%.3f,%.3f)\\\\1c&amp;H3CF5D2&amp;}%s\" % (line.right, line.top, line.text)\nio.write_line(l)\n\n# Save the output and open in Aegisub\nio.save()\nio.open_aegisub()\n</code></pre>"},{"location":"tutorials/0-first-steps/04-text-segmentation/","title":"Tutorial: Text Segmentation with PyonFX","text":"<p>In this tutorial, you'll learn about one of PyonFX's most used features: automatic text segmentation. You'll discover how PyonFX breaks down subtitle lines into individual words, syllables, and characters, and how to work with each segment to create precise karaoke effects.</p>"},{"location":"tutorials/0-first-steps/04-text-segmentation/#materials","title":"Materials","text":"<p>We'll continue using the hello_world.ass file from previous tutorials.</p>"},{"location":"tutorials/0-first-steps/04-text-segmentation/#understanding-text-segmentation","title":"Understanding Text Segmentation","text":"<p>When PyonFX processes an ASS line, it automatically segments the text into three hierarchical levels:</p> <ul> <li>Words: Text segments separated by spaces</li> <li>Syllables: Text segments defined by karaoke timing tags (like <code>\\k</code>, <code>\\ko</code>, <code>\\kf</code>, etc.)</li> <li>Characters: Individual characters within the text</li> </ul> <p>Let's explore how to access and work with each segment type.</p>"},{"location":"tutorials/0-first-steps/04-text-segmentation/#code-walkthrough","title":"Code Walkthrough","text":"<p>0. Setup and Data Loading</p> <p>We start with the familiar setup pattern:</p> <pre><code>from pyonfx import Ass\n\n# Load the input ASS file\nio = Ass(\"hello_world.ass\")\nmeta, styles, lines = io.get_data()\n\n# Use the first line from the file\nline = lines[0]\nl = line.copy()\n</code></pre> <p>1. Exploring Syllable Segmentation</p> <p>Let's start by understanding how syllables work, since they're the foundation of most karaoke effects. First, let's examine what syllables look like in detail, similar to what we did in Exploring ASS values:</p> <pre><code># Let's explore the syllables of our line\nfor syl in line.syls:\n    print(f\"Syllable {syl.i}: '{syl.text}' - Start: {syl.start_time}ms, End: {syl.end_time}ms\")\n    print(f\"  Position: center=({syl.center:.1f}, {syl.middle:.1f})\")\n    print()\n</code></pre> Show Output <pre><code>Syllable 0: 'Hel' - Start: 0ms, End: 500ms\n    Position: center=(563.9, 35.0)\n\nSyllable 1: 'lo' - Start: 500ms, End: 1000ms\n    Position: center=(607.7, 35.0)\n\nSyllable 2: 'world!' - Start: 1000ms, End: 1500ms\n    Position: center=(687.2, 35.0)\n</code></pre> <p>Run this code and you'll see that each syllable has the same properties we learned about for lines:</p> <ul> <li>Text content: The actual syllable text (like \"Hel\", \"lo\", \"world!\")</li> <li>Timing: <code>start_time</code> and <code>end_time</code> relative to the line's start</li> <li>Positioning: <code>center</code>, <code>middle</code>, <code>left</code>, <code>right</code>, <code>top</code>, <code>bottom</code> properties</li> <li>Index: <code>i</code> property indicating its position in the sequence</li> </ul> <p>This is powerful! Each syllable is essentially a mini-line with its own timing and positioning.</p> <p>2. Creating Your First Syllable Effect</p> <p>Now that we understand the structure, let's make each syllable appear and disappear based on its timing, positioned exactly where it would naturally appear:</p> <pre><code># Process syllables with their natural timing and positioning\nfor syl in line.syls:\n    l.start_time = syl.start_time\n    l.end_time = syl.end_time\n    l.text = \"{\\\\an5\\\\pos(%.3f,%.3f)}%s\" % (\n        syl.center,\n        syl.middle,\n        syl.text,\n    )\n    io.write_line(l)\n</code></pre> <p>This creates a basic effect where each syllable appears individually in its timing window, positioned at its natural location within the line. If you save and open this in Aegisub, you'll see something like:</p> <p></p> <p>3. Adding Colors for Clarity</p> <p>Now let's add some color to make the segmentation more visible. We'll define alternating colors and apply them to each syllable:</p> <pre><code># Define color codes for red and blue\nRED = \"&amp;HFF0000&amp;\"\nBLUE = \"&amp;H0000FF&amp;\"\n\n# Process syllables with alternating colors\nfor syl in line.syls:\n    color = RED if (syl.i % 2 == 0) else BLUE\n    l.start_time = syl.start_time\n    l.end_time = syl.end_time\n    l.text = \"{\\\\an5\\\\pos(%.3f,%.3f)\\\\1c%s}%s\" % (\n        syl.center,\n        syl.middle,\n        color,\n        syl.text,\n    )\n    io.write_line(l)\n</code></pre> <p>The alternating red and blue colors help you clearly see each individual syllable as it appears and disappears.</p> <p>4. Extending to All Segment Types</p> <p>The same principles apply to words and characters. Let's extend our effect to show all three segmentation levels at different times. We'll add time offsets so you can see each type separately:</p> <pre><code># Process words: words start to appear from 0ms\nall_words_start = 0\nfor word in line.words:\n    color = RED if (word.i % 2 == 0) else BLUE\n    l.start_time = all_words_start + word.start_time\n    l.end_time = all_words_start + word.end_time\n    l.text = \"{\\\\an5\\\\pos(%.3f,%.3f)\\\\1c%s}%s\" % (\n        word.center,\n        word.middle,\n        color,\n        word.text,\n    )\n    io.write_line(l)\n\n# Add the syllables from section 3 with a time offset: syllables start to appear from 3000ms\nall_syls_start = 3000\nfor syl in line.syls:\n    color = RED if (syl.i % 2 == 0) else BLUE\n    l.start_time = all_syls_start + syl.start_time\n    l.end_time = all_syls_start + syl.end_time\n    l.text = \"{\\\\an5\\\\pos(%.3f,%.3f)\\\\1c%s}%s\" % (\n        syl.center,\n        syl.middle,\n        color,\n        syl.text,\n    )\n    io.write_line(l)\n\n# Process characters: characters start to appear from 5000ms\nall_chars_start = 5000\nfor char in line.chars:\n    color = RED if (char.i % 2 == 0) else BLUE\n    l.start_time = all_chars_start + char.start_time\n    l.end_time = all_chars_start + char.end_time\n    l.text = \"{\\\\an5\\\\pos(%.3f,%.3f)\\\\1c%s}%s\" % (\n        char.center,\n        char.middle,\n        color,\n        char.text,\n    )\n    io.write_line(l)\n</code></pre> <p>Here's what we're doing:</p> <ul> <li>Words (0-3000ms): Show word-level segmentation first</li> <li>Syllables (3000-5000ms): Then syllable-level segmentation</li> <li>Characters (5000ms+): Finally character-level segmentation</li> </ul> <p>Each segment type uses the same pattern: iterate through the collection, apply alternating colors, position at the segment's natural location, and time it according to the segment's properties plus our time offset.</p> <p>5. Saving and Previewing</p> <p>As always, we save our work and open it for preview:</p> <pre><code>io.save()\nio.open_aegisub()\n</code></pre> <p>You should get something like:</p> <p></p> <p>Notice that: - Words start and end times coincide with the line's start and end times - Characters start and end times coincide with the syllables' start and end times</p> <p>This timing relationship reveals the intended use of each segment type:</p> <ul> <li>Syllables are perfect for traditional karaoke effects, where each syllable highlights according to the song's timing (defined by <code>\\k</code> tags)</li> <li>Characters inherit syllable timing, so you can do everything you would do with syllables, but with more granularity</li> <li>Words span the entire line duration, making them useful for word-by-word reveals, word positioning effects, or when you want to treat entire words as single units rather than breaking them into syllables</li> </ul>"},{"location":"tutorials/0-first-steps/04-text-segmentation/#conclusion","title":"Conclusion","text":"<p>Excellent work. You've mastered PyonFX's text segmentation system, learning how to work with words, syllables, and characters as individual entities, and how each segment maintains its positioning and timing properties.</p> <p>Get ready, because in the next tutorial, we'll create our first karaoke effect!</p>"},{"location":"tutorials/0-first-steps/04-text-segmentation/#full-source-code","title":"Full Source Code","text":"Show full source code <pre><code>\"\"\"\nTutorial: Understanding Text Segmentation\n\nThis tutorial explains how PyonFX segments a subtitle line into words, syllables, and characters.\n\nFor each segment type, we show that:\n\u2022 Each entity has time and position properties (same as Line)\n\u2022 Each entity has an index property (same as Line)\n\nExercise:\n\u2022 Adjust timing windows, and try to add a different ASS tag for each separate entity.\n\"\"\"\n\nfrom pyonfx import Ass\n\n# Load the input ASS file\nio = Ass(\"../../ass/hello_world.ass\")\nmeta, styles, lines = io.get_data()\n\n# Use the first line from the file\nline = lines[0]\nl = line.copy()\n\n# Define color codes for red and blue\nRED = \"&amp;HFF0000&amp;\"\nBLUE = \"&amp;H0000FF&amp;\"\n\n# Process words: words start to appear from 0ms\nall_words_start = 0\nfor word in line.words:\n    color = RED if (word.i % 2 == 0) else BLUE\n    l.start_time = all_words_start + word.start_time\n    l.end_time = all_words_start + word.end_time\n    l.text = \"{\\\\an5\\\\pos(%.3f,%.3f)\\\\1c%s}%s\" % (\n        word.center,\n        word.middle,\n        color,\n        word.text,\n    )\n    io.write_line(l)\n\n# Process syllables: syllables start to appear from 3000ms\nall_syls_start = 3000\nfor syl in line.syls:\n    color = RED if (syl.i % 2 == 0) else BLUE\n    l.start_time = all_syls_start + syl.start_time\n    l.end_time = all_syls_start + syl.end_time\n    l.text = \"{\\\\an5\\\\pos(%.3f,%.3f)\\\\1c%s}%s\" % (\n        syl.center,\n        syl.middle,\n        color,\n        syl.text,\n    )\n    io.write_line(l)\n\n# Process characters: characters start to appear from 5000ms\nall_chars_start = 5000\nfor char in line.chars:\n    color = RED if (char.i % 2 == 0) else BLUE\n    l.start_time = all_chars_start + char.start_time\n    l.end_time = all_chars_start + char.end_time\n    l.text = \"{\\\\an5\\\\pos(%.3f,%.3f)\\\\1c%s}%s\" % (\n        char.center,\n        char.middle,\n        color,\n        char.text,\n    )\n    io.write_line(l)\n\n# Save the output and open in Aegisub\nio.save()\nio.open_aegisub()\n</code></pre>"},{"location":"tutorials/1-beginner/01-first-kfx/","title":"Tutorial: Your First KFX with PyonFX","text":"<p>Welcome to the beginner series.</p> <p>In this tutorial, you'll create your first real karaoke effect (KFX) using PyonFX. We'll move beyond basic text positioning to build a structured three-phase effect that provides visual feedback synchronized with vocal timing.</p>"},{"location":"tutorials/1-beginner/01-first-kfx/#materials","title":"Materials","text":"<p>For this tutorial, we'll work with a more complex subtitle file: romaji_kanji_translation.ass. This file contains three types of subtitle lines:</p> <ul> <li>Romaji lines (phonetic Japanese) - alignment 7 or higher</li> <li>Kanji lines (Japanese characters) - intermediate alignment  </li> <li>Translation lines (English) - lower alignment</li> </ul> <p>Please ensure that you have downloaded and installed Migu Font, a free and publicly available Japanese font, so that the subtitles display correctly.</p> <p>This tutorial will focus on the Romaji lines.</p>"},{"location":"tutorials/1-beginner/01-first-kfx/#understanding-karaoke-effects","title":"Understanding Karaoke Effects","text":"<p>Before diving into code, let's understand what makes a good karaoke effect. Most follow a three-phase timing structure:</p> <ul> <li>Leadin Phase: Text begins transitioning slightly before the syllable timing. Think of it as a gentle \"get ready\" cue that prevents jarring sudden changes</li> <li>Highlight Phase (or Main Phase): This is your color change, scaling, or animation that clearly shows when to sing. It's perfectly synchronized with the vocal timing, and it's what defines the character of the karaoke style</li> <li>Leadout Phase: After singing ends, text gracefully transitions away rather than vanishing instantly. This maintains visual continuity and feels much more polished</li> </ul> <p>In this tutorial, we'll create a simple effect that follows this pattern.</p>"},{"location":"tutorials/1-beginner/01-first-kfx/#code-walkthrough","title":"Code Walkthrough","text":"<p>0. Setup and File Loading</p> <p>We start with our familiar pattern, but with our new karaoke file:</p> <pre><code>from pyonfx import Ass\n\n# Load the karaoke file\nio = Ass(\"romaji_kanji_translation.ass\")\nmeta, styles, lines = io.get_data()\n</code></pre> <p>1. Iterating and Filter Lines for Karaoke</p> <p>Unlike our previous single-line examples, we need to process selectively now. Here we'll iterate through all lines but filter for only the romaji lyrics that need karaoke effects:</p> <pre><code># Process each line\nfor line in lines:\n    # Only apply the effect to non-commented lines with alignment 7 or higher (Romaji)\n    if line.comment or line.styleref.alignment &lt; 7:\n        continue\n</code></pre> <p>This filter catches exactly what we want:</p> <ul> <li><code>line.comment</code> skips commented-out lines</li> <li><code>line.styleref.alignment &lt; 7</code> targets only Romaji lines (alignment 7+), ignoring Kanji and translation lines</li> </ul> <p>2. Iterating and Filtering Syllables</p> <p>Now we set up our syllable loop:</p> <pre><code>for line in lines:\n    ...\n\n    # Create a copy of the line for the output\n    l = line.copy()\n\n    # We'll work with syllables for karaoke effects\n    for syl in line.syls:\n        # Skip empty syllables\n        if syl.text == \"\":\n            continue\n</code></pre> <p>We skip empty syllables because they don't contribute visual content, but can exist in ASS files as timing placeholders.</p> <p>3. Introducing key concepts</p> <p>Before we build our effect, let's understand two important PyonFX features:</p> <ul> <li> <p>Introducing <code>line.leadin</code> and <code>line.leadout</code></p> <p>PyonFX calculates natural pause times between lines\u2014<code>line.leadin</code> (gap before this line) and <code>line.leadout</code> (gap after). These give us perfect timing windows for our effects without overlapping adjacent lines.</p> </li> <li> <p>Cleaner Code with f-strings</p> <p>We're upgrading from the % formatting you've seen to raw f-strings:</p> <pre><code># Old way (what you've seen)\nl.text = \"{\\\\an5\\\\pos(%.3f,%.3f)}%s\" % (syl.center, syl.middle, syl.text)\n\n# New way (cleaner and more readable)\nl.text = rf\"{{\\an5\\pos({syl.center:.3f},{syl.middle:.3f})}}{syl.text}\"\n</code></pre> <p>The <code>rf</code> prefix means \"raw f-string\" - raw strings don't need double backslashes for ASS tags, and f-strings let you put variables directly inside <code>{}</code> brackets.</p> </li> </ul> <p>4. Leadin Effect</p> <p>Let's make syllables appear gracefully before they're sung:</p> <pre><code>for syl in line.syls:\n    ...\n    # LEADIN EFFECT: syllable appears before being sung\n    l.layer = 0\n    l.start_time = line.start_time - line.leadin // 2\n    l.end_time = line.start_time + syl.start_time\n\n    tags = rf\"\\an5\\pos({syl.center:.3f},{syl.middle:.3f})\\fad({line.leadin//2},0)\"\n    l.text = f\"{{{tags}}}{syl.text}\"\n\n    io.write_line(l)\n</code></pre> <p>Breaking this down:</p> <ul> <li>Layer 0: Background layer (our highlight will go on top later)</li> <li>Timing: Starts halfway through the available leadin time, ends when syllable singing begins</li> <li>Fade: Simple fade-in using half the leadin duration</li> </ul> <p></p> <p>5. Highlight Effect</p> <p>Time for the main event\u2014the syllable gets emphasized while being sung:</p> <pre><code>for syl in line.syls:\n    ...\n    # HIGHLIGHT EFFECT: main effect when syllable is sung\n    l.layer = 1\n    l.start_time = line.start_time + syl.start_time\n    l.end_time = line.start_time + syl.end_time\n\n    tags = (\n        rf\"\\an5\\pos({syl.center:.3f},{syl.middle:.3f})\"\n        rf\"\\t(0,{syl.duration // 2},\\fscx125\\fscy125\\1c&amp;HFFFFFF&amp;\\3c&amp;HABABAB&amp;)\"\n        rf\"\\t({syl.duration // 2},{syl.duration},\\fscx100\\fscy100\\1c{line.styleref.color1}\\3c{line.styleref.color3})\"\n    )\n    l.text = f\"{{{tags}}}{syl.text}\"\n\n    io.write_line(l)\n</code></pre> <p>This creates a simple \"swell\" effect:</p> <ul> <li>Layer 1: Places this on top of the leadin effect</li> <li>Timing: Perfectly matches the syllable's singing duration</li> <li>Double transformation:<ul> <li>First half: Scale to 125% with white/gray colors</li> <li>Second half: Returns to normal size and original style colors</li> </ul> </li> </ul> <p>The result? A syllable that grows, changes color, then settles back\u2014perfectly timed to the vocals.</p> <p></p> <p>6. Leadout Effect</p> <p>Finally, let's make the syllable fade gracefully after being sung:</p> <pre><code>for syl in line.syls:\n    ...\n    # LEADOUT EFFECT: syllable fades after being sung\n    l.layer = 0\n    l.start_time = line.start_time + syl.end_time\n    l.end_time = line.end_time + line.leadout // 2\n\n    tags = rf\"\\an5\\pos({syl.center:.3f},{syl.middle:.3f})\\fad(0,{line.leadout//2})\"\n    l.text = f\"{{{tags}}}{syl.text}\"\n\n    io.write_line(l)\n</code></pre> <p>The details:</p> <ul> <li>Layer 0: Back to background layer</li> <li>Timing: Starts when singing ends, extends into the leadout period</li> <li>Fade: Simple fade-out using half the available leadout time</li> </ul> <p></p> Coming from Aegisub's Karaoke Templater? Try <code>Utils.retime</code> <p><code>Utils.retime</code> is PyonFX\u2019s drop-in replacement for the retime directive used in Aegisub templates. It only changes the timing: the helper sets <code>l.start_time</code> and <code>l.end_time</code> for you, but everything else (layer, tags, colours, etc.) remains under your control\u2014and you still need to call <code>io.write_line(l)</code> to actually add the modified line to the script.</p> <p>Here\u2019s how you could rely on it for the three phases in this tutorial:</p> <pre><code># Lead-in\nUtils.retime(\"start2syl\", l, line, syl, offset_start=-line.leadin // 2)\n\n# Highlight\nUtils.retime(\"syl\", l, line, syl)\n\n# Lead-out\nUtils.retime(\"syl2end\", l, line, syl, offset_end=line.leadout // 2)\n</code></pre> <p>Everything else in the original code stays the same\u2014you still build <code>l.text</code>, set <code>l.layer</code>, and finish with <code>io.write_line(l)</code>. Remember to <code>from pyonfx import Utils</code> beforehand.</p> <p>7. Bringing it all together</p> <p>Save and preview your masterpiece:</p> <pre><code>io.save()\nio.open_aegisub()\n</code></pre> <p></p>"},{"location":"tutorials/1-beginner/01-first-kfx/#conclusion","title":"Conclusion","text":"<p>Excellent work. You've just created your first karaoke effect. You've learned to build a complete three-phase system that makes syllables appear, highlight, and fade with perfect timing.</p> <p>The effect looks great, but I bet you noticed the code is getting complex. In the next tutorial, we'll refactor this into clean, reusable functions that will make your karaoke workflow much more efficient and maintainable.</p>"},{"location":"tutorials/1-beginner/01-first-kfx/#full-source-code","title":"Full Source Code","text":"Show full source code <pre><code>\"\"\"\nTutorial: Creating your first Karaoke Effect (KFX)\n\nThis tutorial demonstrates how to define and apply your first karaoke effect.\nWe work with a .ass file containing Romaji, Kanji and Translation lines, applying the effects only to those with alignment 7 or higher (Romaji).\n\nFor each applicable line, we process each syllable to apply 3 distinct effects:\n\u2022 LEADIN EFFECT: makes the syllable fade in before being sung\n\u2022 HIGHLIGHT EFFECT: highlights the syllable with scaling and color transitions\n\u2022 LEADOUT EFFECT: makes the syllable fade out after being sung\n\nExercise:\n\u2022 Change the 1c and 3c tags of the main effect to see how the effect changes.\n\"\"\"\n\nfrom pyonfx import Ass\n\n# Load the karaoke file\nio = Ass(\"../../ass/romaji_kanji_translation.ass\")\nmeta, styles, lines = io.get_data()\n\n# Process each line\nfor line in lines:\n    # Only apply the effect to non-commented lines with alignment 7 or higher (Romaji)\n    if line.comment or line.styleref.alignment &lt; 7:\n        continue\n\n    # Create a copy of the line for the output\n    l = line.copy()\n\n    # We'll work with syllables for karaoke effects\n    for syl in line.syls:\n        # Skip empty syllables\n        if syl.text == \"\":\n            continue\n\n        # LEADIN EFFECT: syllable appears before being sung\n        l.layer = 0\n        l.start_time = line.start_time - line.leadin // 2\n        l.end_time = line.start_time + syl.start_time\n        # Or use: Utils.retime(\"start2syl\", l, line, syl, offset_start=-line.leadin // 2)\n\n        tags = rf\"\\an5\\pos({syl.center:.3f},{syl.middle:.3f})\\fad({line.leadin//2},0)\"\n        l.text = f\"{{{tags}}}{syl.text}\"\n\n        io.write_line(l)\n\n        # HIGHLIGHT EFFECT: main effect when syllable is sung\n        l.layer = 1\n        l.start_time = line.start_time + syl.start_time\n        l.end_time = line.start_time + syl.end_time\n        # Or use: Utils.retime(\"syl\", l, line, syl)\n\n        tags = (\n            rf\"\\an5\\pos({syl.center:.3f},{syl.middle:.3f})\"\n            rf\"\\t(0,{syl.duration // 2},\\fscx125\\fscy125\\1c&amp;HFFFFFF&amp;\\3c&amp;HABABAB&amp;)\"\n            rf\"\\t({syl.duration // 2},{syl.duration},\\fscx100\\fscy100\\1c{line.styleref.color1}\\3c{line.styleref.color3})\"\n        )\n        l.text = f\"{{{tags}}}{syl.text}\"\n\n        io.write_line(l)\n\n        # LEADOUT EFFECT: syllable fades after being sung\n        l.layer = 0\n        l.start_time = line.start_time + syl.end_time\n        l.end_time = line.end_time + line.leadout // 2\n        # Or use: Utils.retime(\"syl2end\", l, line, syl, offset_end=line.leadout // 2)\n\n        tags = rf\"\\an5\\pos({syl.center:.3f},{syl.middle:.3f})\\fad(0,{line.leadout//2})\"\n        l.text = f\"{{{tags}}}{syl.text}\"\n\n        io.write_line(l)\n\n# Save and preview\nio.save()\nio.open_aegisub()\n</code></pre>"},{"location":"tutorials/1-beginner/02-first-kfx-organized/","title":"Tutorial: Organizing Your First KFX","text":"<p>In the previous tutorial, you created your first KFX, but I bet you noticed something: the code was getting pretty repetitive and hard to manage. When you're building real karaoke effects, you'll often work with dozens of lines and complex timing\u2014having everything in one big loop becomes unwieldy fast.</p> <p>In this tutorial, we'll refactor that same effect into clean, organized functions that are easier to read, debug, and reuse. You'll also discover some handy PyonFX utilities that make your code more robust.</p>"},{"location":"tutorials/1-beginner/02-first-kfx-organized/#materials","title":"Materials","text":"<p>We'll continue working with the same romaji_kanji_translation.ass file from the previous tutorial.</p>"},{"location":"tutorials/1-beginner/02-first-kfx-organized/#why-organize-your-code","title":"Why Organize Your Code?","text":"<p>We encourage organizing your code because:</p> <ul> <li>Clarity: Giving each effect phase its own function keeps the logic easy to follow.</li> <li>Debugging: If something doesn't work as expected, you'll know exactly where to look.</li> <li>Reusability: Well-structured functions can be easily reused in other projects or combined in new ways.</li> <li>Maintenance: Isolating effects makes it much easier to tweak timing or styling down the road.</li> </ul>"},{"location":"tutorials/1-beginner/02-first-kfx-organized/#code-walkthrough","title":"Code Walkthrough","text":"<p>0. Familiar Setup with New Imports</p> <p>We start similarly, but import a few more PyonFX components:</p> <pre><code>from pyonfx import Ass, Line, Syllable, Utils\n\nio = Ass(\"romaji_kanji_translation.ass\")\nmeta, styles, lines = io.get_data()\n</code></pre> <p>The new imports are:</p> <ul> <li><code>Line</code> and <code>Syllable</code>: Type hints for our functions (makes code clearer)</li> <li><code>Utils</code>: PyonFX's utility class</li> </ul> <p>1. Leadin Function</p> <p>Let's convert our three-phase effect into separate functions, starting with one for the leadin effect:</p> <pre><code>def leadin_effect(line: Line, syl: Syllable, l: Line):\n    l.layer = 0\n    l.start_time = line.start_time - line.leadin // 2\n    l.end_time = line.start_time + syl.start_time\n\n    tags = rf\"\\an5\\pos({syl.center:.3f},{syl.middle:.3f})\\fad({line.leadin // 2},0)\"\n    l.text = f\"{{{tags}}}{syl.text}\"\n\n    io.write_line(l)\n</code></pre> <p>Notice the function signature\u2014it takes the original <code>line</code>, current <code>syl</code>lable, and the copied line <code>l</code> as parameters. This makes the function completely self-contained and reusable.</p> <p>2. Enhanced Main Effect</p> <p>While moving our main effect to a separate function, let's also make it more robust:</p> <pre><code>def highlight_effect(line: Line, syl: Syllable, l: Line):\n    l.layer = 1\n    l.start_time = line.start_time + syl.start_time\n    l.end_time = line.start_time + syl.end_time\n\n    # Original style values\n    c1 = line.styleref.color1\n    c3 = line.styleref.color3\n    fscx = line.styleref.scale_x\n    fscy = line.styleref.scale_y\n\n    # Target values\n    t_c1 = \"&amp;HFFFFFF&amp;\"\n    t_c3 = \"&amp;HABABAB&amp;\"\n    t_fscx = fscx * 1.25\n    t_fscy = fscy * 1.25\n    grow_duration = syl.duration // 2\n\n    tags = (\n        rf\"\\an5\\pos({syl.center:.3f},{syl.middle:.3f})\"\n        rf\"\\t(0,{grow_duration},\\fscx{t_fscx}\\fscy{t_fscy}\\1c{t_c1}\\3c{t_c3})\"\n        rf\"\\t({grow_duration},{syl.duration},\\fscx{fscx}\\fscy{fscy}\\1c{c1}\\3c{c3})\"\n    )\n    l.text = f\"{{{tags}}}{syl.text}\"\n\n    io.write_line(l)\n</code></pre> <p>This version is much more robust because:</p> <ul> <li>Dynamic scaling: Instead of hardcoded <code>125%</code>, we multiply the original scale by <code>1.25</code></li> <li>Style-aware colors: We extract colors from the line's style, then return to them</li> <li>Clear variable names: <code>c1</code>, <code>c3</code>, <code>fscx</code>, <code>fscy</code> make the ASS tags more readable</li> </ul> <p>This means your effect will work correctly regardless of the original style settings.</p> <p>3. Leadout Function</p> <p>The leadout effect gets the same treatment:</p> <pre><code>def leadout_effect(line: Line, syl: Syllable, l: Line):\n    l.layer = 0\n    l.start_time = line.start_time + syl.end_time\n    l.end_time = line.end_time + line.leadout // 2\n\n    tags = rf\"\\an5\\pos({syl.center:.3f},{syl.middle:.3f})\\fad(0,{line.leadout // 2})\"\n    l.text = f\"{{{tags}}}{syl.text}\"\n\n    io.write_line(l)\n</code></pre> <p>4. Introducing PyonFX Utilities</p> <p>Now let's use PyonFX's <code>Utils.all_non_empty()</code> to clean up our main loop:</p> <pre><code>for line in Utils.all_non_empty(lines):\n    if line.styleref.alignment &gt;= 7:\n        l = line.copy()\n        for syl in Utils.all_non_empty(line.syls):\n            leadin_effect(line, syl, l)\n            highlight_effect(line, syl, l)\n            leadout_effect(line, syl, l)\n</code></pre> <p><code>Utils.all_non_empty()</code> is incredibly handy\u2014it automatically:</p> <ul> <li>Skips commented lines and empty syllables (no more manual <code>if syl.text == \"\":</code> checks)</li> <li>Reassigns indexes (<code>i</code>, <code>word_i</code>, <code>syl_i</code>, ...) of the filtered objects</li> <li>Shows a progress bar while the iteration is in progress</li> </ul> <p>Your code becomes cleaner and more robust with just one function call. For more details, check its documentation here.</p> <p>5. Effect Tracking with Decorators</p> <p>PyonFX includes a powerful feature for tracking your effects. Add the <code>@io.track</code> decorator to each function:</p> <pre><code>@io.track\ndef leadin_effect(line: Line, syl: Syllable, l: Line):\n    # ... function code ...\n\n@io.track\ndef highlight_effect(line: Line, syl: Syllable, l: Line):\n    # ... function code ...\n\n@io.track\ndef leadout_effect(line: Line, syl: Syllable, l: Line):\n    # ... function code ...\n</code></pre> <p>When you run your script, you'll get detailed statistics for each effect:</p> Show Output <p>(Pardon the output formatting, I promise it's better when you actually see it in the terminal) <pre><code>\ud83d\udc30 Produced lines: 135\n\u23f1\ufe0f Total runtime: 0.1s (avg 0.001s per generated line)\n\n\ud83d\udcca STATISTICS\n\u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 Name           \u2502   Calls \u2502   Lines \u2502   Time (s) \u2502   Avg/Call (s) \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 leadin_effect  \u2502      45 \u2502      45 \u2502      0.001 \u2502              0 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 highlight_effect    \u2502      45 \u2502      45 \u2502      0.001 \u2502              0 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 leadout_effect \u2502      45 \u2502      45 \u2502          0 \u2502              0 \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre></p> <p>This is invaluable for debugging complex effects\u2014you can see exactly how many lines each function generated and spot problems immediately.</p> <p>6. Final Result</p> <p>Save and preview your organized masterpiece:</p> <pre><code>io.save()\nio.open_aegisub()\n</code></pre> <p>The visual result is identical to the previous tutorial, but your code is now professional-grade: organized, maintainable, and scalable.</p>"},{"location":"tutorials/1-beginner/02-first-kfx-organized/#conclusion","title":"Conclusion","text":"<p>Good job. You've transformed functional but messy karaoke code into clean, professional structure. You've learned to break effects into logical functions, use PyonFX utilities to handle common tasks, and track your effects with decorators.</p> <p>This organizational pattern will serve you well as effects become more complex. Up next, we'll also show some love to the kanji and translation lines.</p>"},{"location":"tutorials/1-beginner/02-first-kfx-organized/#full-source-code","title":"Full Source Code","text":"Show full source code <pre><code>\"\"\"\nTutorial: Creating your first organized Karaoke Effect\n\nThis tutorial recreates the KFX seen in '01_first_kfx.py', but using an organized structure and a few utilities.\n\nWe have refactored the code into three distinct functions:\n\u2022 `leadin_effect`: makes the syllable fade in before being sung\n\u2022 `highlight_effect`: highlights the syllable with scaling and color transitions\n\u2022 `leadout_effect`: makes the syllable fade out after being sung\n\nWe also use:\n\u2022 `Utils.all_non_empty()` to skip empty syllables and comment lines\n\u2022 `io.track()` decorator to track statistics for each effect\n\nExercise:\n\u2022 Try to change the leadin/leadout to make the syllable move from y=middle-80 to y=middle during the effect\n\u2022 Try to change the growing duration of the main effect to make the syllable grow faster or slower\n\"\"\"\n\nfrom pyonfx import Ass, Line, Syllable, Utils\n\nio = Ass(\"../../ass/romaji_kanji_translation.ass\")\nmeta, styles, lines = io.get_data()\n\n\n@io.track\ndef leadin_effect(line: Line, syl: Syllable, l: Line):\n    l.layer = 0\n    l.start_time = line.start_time - line.leadin // 2\n    l.end_time = line.start_time + syl.start_time\n    # Or use: Utils.retime(\"start2syl\", l, line, syl, offset_start=-line.leadin // 2)\n\n    tags = rf\"\\an5\\pos({syl.center:.3f},{syl.middle:.3f})\\fad({line.leadin // 2},0)\"\n    l.text = f\"{{{tags}}}{syl.text}\"\n\n    io.write_line(l)\n\n\n@io.track\ndef highlight_effect(line: Line, syl: Syllable, l: Line):\n    l.layer = 1\n    l.start_time = line.start_time + syl.start_time\n    l.end_time = line.start_time + syl.end_time\n    # Or use: Utils.retime(\"syl\", l, line, syl)\n\n    # Original style values\n    c1 = line.styleref.color1\n    c3 = line.styleref.color3\n    fscx = line.styleref.scale_x\n    fscy = line.styleref.scale_y\n\n    # Target values\n    t_c1 = \"&amp;HFFFFFF&amp;\"\n    t_c3 = \"&amp;HABABAB&amp;\"\n    t_fscx = fscx * 1.25\n    t_fscy = fscy * 1.25\n    grow_duration = syl.duration // 2\n\n    tags = (\n        rf\"\\an5\\pos({syl.center:.3f},{syl.middle:.3f})\"\n        rf\"\\t(0,{grow_duration},\\fscx{t_fscx}\\fscy{t_fscy}\\1c{t_c1}\\3c{t_c3})\"\n        rf\"\\t({grow_duration},{syl.duration},\\fscx{fscx}\\fscy{fscy}\\1c{c1}\\3c{c3})\"\n    )\n    l.text = f\"{{{tags}}}{syl.text}\"\n\n    io.write_line(l)\n\n\n@io.track\ndef leadout_effect(line: Line, syl: Syllable, l: Line):\n    l.layer = 0\n    l.start_time = line.start_time + syl.end_time\n    l.end_time = line.end_time + line.leadout // 2\n    # Or use: Utils.retime(\"syl2end\", l, line, syl, offset_end=line.leadout // 2)\n\n    tags = rf\"\\an5\\pos({syl.center:.3f},{syl.middle:.3f})\\fad(0,{line.leadout // 2})\"\n    l.text = f\"{{{tags}}}{syl.text}\"\n\n    io.write_line(l)\n\n\n# Generating lines\nfor line in Utils.all_non_empty(lines):\n    if line.styleref.alignment &gt;= 7:\n        l = line.copy()\n        for syl in Utils.all_non_empty(line.syls):\n            leadin_effect(line, syl, l)\n            highlight_effect(line, syl, l)\n            leadout_effect(line, syl, l)\n\nio.save()\nio.open_aegisub()\n</code></pre>"},{"location":"tutorials/1-beginner/03-romaji-kanji-translation/","title":"Tutorial: Complete Karaoke with Romaji, Kanji &amp; Translation","text":"<p>You've built a solid karaoke effect for romaji lines, but if you look at your ASS file, you'll notice there are actually three types of subtitle lines that need attention. In this tutorial, we'll extend your organized effect to handle all subtitle types: romaji (phonetic), kanji (Japanese characters), and translation (Italian) lines.</p> <p>This is where your organized code structure really pays off\u2014we'll reuse your existing effect functions and add specialized handling for each subtitle type.</p>"},{"location":"tutorials/1-beginner/03-romaji-kanji-translation/#materials","title":"Materials","text":"<p>We'll continue working with the same romaji_kanji_translation.ass file, but this time we'll process all the lines instead of filtering out the kanji and translation lines.</p>"},{"location":"tutorials/1-beginner/03-romaji-kanji-translation/#code-walkthrough","title":"Code Walkthrough","text":"<p>0. Setup with Vertical Kanji</p> <p>We start similarly, but with one important addition\u2014the <code>vertical_kanji</code> parameter:</p> <pre><code>from pyonfx import Ass, Line, Syllable, Utils\n\nio = Ass(\"romaji_kanji_translation.ass\", vertical_kanji=True)\nmeta, styles, lines = io.get_data()\n</code></pre> <p>The <code>vertical_kanji=True</code> parameter tells PyonFX to automatically rotate lines with alignment 4-6 to vertical orientation, which is traditional for Japanese text display. PyonFX handles all the complex positioning math for you.</p> <p>1. Reusing Our Effect Functions</p> <p>The beauty of our organized approach becomes clear here\u2014we can reuse the exact same effect functions from the previous tutorial:</p> <pre><code>@io.track\ndef leadin_effect(line: Line, syl: Syllable, l: Line):\n    l.layer = 0\n    l.start_time = line.start_time - line.leadin // 2\n    l.end_time = line.start_time + syl.start_time\n\n    tags = rf\"\\an5\\pos({syl.center:.3f},{syl.middle:.3f})\\fad({line.leadin // 2},0)\"\n    l.text = f\"{{{tags}}}{syl.text}\"\n\n    io.write_line(l)\n\n@io.track\ndef highlight_effect(line: Line, syl: Syllable, l: Line):\n    # ... same as before ...\n\n@io.track\ndef leadout_effect(line: Line, syl: Syllable, l: Line):\n    # ... same as before ...\n</code></pre> <p>These functions work perfectly for both romaji and kanji because they use the segment's positioning properties (<code>syl.center</code>, <code>syl.middle</code>), which PyonFX calculates correctly regardless of text orientation.</p> <p>2. Creating Subtitle Type Handlers</p> <p>Now we'll create specialized functions for each subtitle type. Let's start with the romaji handler:</p> <pre><code>@io.track\ndef romaji(line: Line, l: Line):\n    for syl in Utils.all_non_empty(line.syls):\n        leadin_effect(line, syl, l)\n        highlight_effect(line, syl, l)\n        leadout_effect(line, syl, l)\n</code></pre> <p>This is identical to our main loop from the previous tutorial, just wrapped in a function.</p> <p>3. Kanji Handler</p> <p>For kanji lines, we'll create a separate handler:</p> <pre><code>@io.track\ndef kanji(line: Line, l: Line):\n    for syl in Utils.all_non_empty(line.syls):\n        leadin_effect(line, syl, l)\n        highlight_effect(line, syl, l)\n        leadout_effect(line, syl, l)\n</code></pre> <p>You might notice this looks identical to the romaji function. While they're the same now, having separate handlers is good practice\u2014in more complex effects, you might want different colors, positioning, or most likely use a different text segmentation (e.g. chars instead of syls). This structure makes those future customizations easy.</p> <p>Also, we're using syllable-level processing here because each syllable in our input file happens to be exactly one Japanese character. But what if your kanji line had multi-character syllables? In that case, you'd want to iterate over <code>line.chars</code> instead to get true character-by-character effects. Keep this in mind for future projects!</p> <p>4. Translation Handler - A Different Approach</p> <p>Translation lines need different treatment. They're not meant for karaoke timing\u2014they're for comprehension. A simple fade in/out works better:</p> <pre><code>@io.track\ndef translation(line: Line, l: Line):\n    l.start_time = line.start_time - line.leadin // 2\n    l.end_time = line.end_time + line.leadout // 2\n\n    tags = rf\"\\fad({line.leadin // 2}, {line.leadout // 2})\"\n    l.text = f\"{{{tags}}}{line.text}\"\n\n    io.write_line(l)\n</code></pre> <p>This creates a gentle fade-in at the beginning and fade-out at the end, using the full line duration. No syllable processing, no complex timing\u2014just clean, readable subtitles that don't compete with the karaoke effects above them.</p> <p>5. The Dispatch Logic</p> <p>Now we tie it all together with logic that automatically chooses the right handler based on alignment:</p> <pre><code># Generating lines\nfor line in Utils.all_non_empty(lines):\n    l = line.copy()\n    if line.styleref.alignment &gt;= 7:\n        romaji(line, l)\n    elif line.styleref.alignment &gt;= 4:\n        kanji(line, l)\n    else:\n        translation(line, l)\n</code></pre> <p>This dispatch system routes each line to its appropriate handler:</p> <ul> <li>Alignment 7+: Romaji lines get full karaoke treatment</li> <li>Alignment 4-6: Kanji lines get the same karaoke treatment (but vertical)</li> <li>Alignment 1-3: Translation lines get simple fade effects</li> </ul> <p>6. Understanding the Results</p> <p>Save and preview your complete karaoke system:</p> <pre><code>io.save()\nio.open_aegisub()\n</code></pre> <p>You'll now see a complete karaoke experience:</p> <ul> <li>Romaji syllables highlighting horizontally as they're sung</li> <li>Kanji characters highlighting vertically in sync with the romaji  </li> <li>Translation lines fading in and out cleanly at the bottom</li> </ul> <p></p>"},{"location":"tutorials/1-beginner/03-romaji-kanji-translation/#conclusion","title":"Conclusion","text":"<p>Great job. You've just completed the beginner series and created a complete karaoke system that handles all three subtitle types appropriately. You've learned how organized code enables easy extension, how PyonFX's features like <code>vertical_kanji</code> make complex layouts manageable, and how to structure effects that can grow with your needs.</p> <p>You now have the foundation to stand on your own and create simple karaoke effects for any project \ud83e\udd72. You understand text segmentation, timing, positioning, and how to organize your code for maintainability and reuse.</p> <p>In the next tutorial series, \"Intermediate,\" we'll explore how to add variations to your karaoke effects and integrate ASS shapes using PyonFX's powerful shape module. Get ready to take your effects to the next level!</p>"},{"location":"tutorials/1-beginner/03-romaji-kanji-translation/#full-source-code","title":"Full Source Code","text":"Show full source code <pre><code>\"\"\"\nTutorial: Creating a Karaoke Effect for Romaji, Kanji and Translation lines\n\nThis tutorial extend the KFX seen in '02_first_kfx_organized.py' by adding an effect for kanji and translation lines.\n\nWe pass the `vertical_kanji` flag to the Ass constructor to make the kanji lines vertical.\n\nAs before, there are three distinct effect functions:\n\u2022 `leadin_effect`: makes the syllable fade in before being sung\n\u2022 `highlight_effect`: highlights the syllable with scaling and color transitions\n\u2022 `leadout_effect`: makes the syllable fade out after being sung\n\nIt also distinguishes between subtitle types:\n\u2022 The `romaji` function processes syllables for lines with alignment 7 or higher (Romaji)\n\u2022 The `kanji` function processes individual characters for lines with intermediate alignment\n\u2022 The `translation` function handles other subtitle lines with lower alignment\n\nWe re-use the same effect functions for romaji and kanji.\n\nExercise:\n\u2022 Try making a different effect for the kanji instead of re-using the same effect functions.\n\"\"\"\n\nfrom pyonfx import Ass, Line, Syllable, Utils\n\nio = Ass(\"../../ass/romaji_kanji_translation.ass\", vertical_kanji=True)\nmeta, styles, lines = io.get_data()\n\n\n@io.track\ndef leadin_effect(line: Line, syl: Syllable, l: Line):\n    l.layer = 0\n    l.start_time = line.start_time - line.leadin // 2\n    l.end_time = line.start_time + syl.start_time\n\n    tags = rf\"\\an5\\pos({syl.center:.3f},{syl.middle:.3f})\\fad({line.leadin // 2},0)\"\n    l.text = f\"{{{tags}}}{syl.text}\"\n\n    io.write_line(l)\n\n\n@io.track\ndef highlight_effect(line: Line, syl: Syllable, l: Line):\n    l.layer = 1\n    l.start_time = line.start_time + syl.start_time\n    l.end_time = line.start_time + syl.end_time\n\n    # Original style values\n    c1 = line.styleref.color1\n    c3 = line.styleref.color3\n    fscx = line.styleref.scale_x\n    fscy = line.styleref.scale_y\n\n    # Target values\n    t_c1 = \"&amp;HFFFFFF&amp;\"\n    t_c3 = \"&amp;HABABAB&amp;\"\n    t_fscx = fscx * 1.25\n    t_fscy = fscy * 1.25\n    grow_duration = syl.duration // 2\n\n    tags = (\n        rf\"\\an5\\pos({syl.center:.3f},{syl.middle:.3f})\"\n        rf\"\\t(0,{grow_duration},\\fscx{t_fscx}\\fscy{t_fscy}\\1c{t_c1}\\3c{t_c3})\"\n        rf\"\\t({grow_duration},{syl.duration},\\fscx{fscx}\\fscy{fscy}\\1c{c1}\\3c{c3})\"\n    )\n    l.text = f\"{{{tags}}}{syl.text}\"\n\n    io.write_line(l)\n\n\n@io.track\ndef leadout_effect(line: Line, syl: Syllable, l: Line):\n    l.layer = 0\n    l.start_time = line.start_time + syl.end_time\n    l.end_time = line.end_time + line.leadout // 2\n\n    tags = rf\"\\an5\\pos({syl.center:.3f},{syl.middle:.3f})\\fad(0,{line.leadout // 2})\"\n    l.text = f\"{{{tags}}}{syl.text}\"\n\n    io.write_line(l)\n\n\n@io.track\ndef romaji(line: Line, l: Line):\n    for syl in Utils.all_non_empty(line.syls):\n        leadin_effect(line, syl, l)\n        highlight_effect(line, syl, l)\n        leadout_effect(line, syl, l)\n\n\n@io.track\ndef kanji(line: Line, l: Line):\n    for syl in Utils.all_non_empty(line.syls):\n        leadin_effect(line, syl, l)\n        highlight_effect(line, syl, l)\n        leadout_effect(line, syl, l)\n\n\n@io.track\ndef translation(line: Line, l: Line):\n    l.start_time = line.start_time - line.leadin // 2\n    l.end_time = line.end_time + line.leadout // 2\n\n    tags = rf\"\\fad({line.leadin // 2}, {line.leadout // 2})\"\n    l.text = f\"{{{tags}}}{line.text}\"\n\n    io.write_line(l)\n\n\n# Generating lines\nfor line in Utils.all_non_empty(lines):\n    l = line.copy()\n    if line.styleref.alignment &gt;= 7:\n        romaji(line, l)\n    elif line.styleref.alignment &gt;= 4:\n        kanji(line, l)\n    else:\n        translation(line, l)\n\nio.save()\nio.open_aegisub()\n</code></pre>"},{"location":"tutorials/2-intermediate/01-variations/","title":"Tutorial: Adding Variations to Your Karaoke Effects","text":"<p>Welcome to the intermediate series.</p> <p>You've built a solid foundation with a complete three-line karaoke system, but it can quickly become repetitive. Different singers might need different visual styles or special moments in songs (e.g. refrains) might call for dedicated effects.</p> <p>In this tutorial, you'll learn how to add variations by defining when to do so directly in your .ass file, and then reading them in your code to apply the variations.</p>"},{"location":"tutorials/2-intermediate/01-variations/#materials","title":"Materials","text":"<p>We'll continue with the same romaji_kanji_translation.ass file, but this time we'll leverage some additional data that's been prepared in the file:</p> <ul> <li>Actor fields: Different lines are assigned to \"Singer1\" and \"Singer2\" to demonstrate personalized theming</li> <li>Inline effects: Some syllables are marked with special <code>inline_fx</code> (<code>\\-fx</code>) tags for dramatic moments</li> <li>Color transformations: The file includes existing color styling that we'll preserve and enhance</li> </ul>"},{"location":"tutorials/2-intermediate/01-variations/#code-walkthrough","title":"Code Walkthrough","text":"<p>0. Familiar Setup with New Imports</p> <p>We start with our familiar pattern but import several new PyonFX components:</p> <pre><code>from pyonfx import Ass, ColorUtility, Convert, Line, Syllable, Utils\n\nio = Ass(\"romaji_kanji_translation.ass\", vertical_kanji=True)\nmeta, styles, lines = io.get_data()\n</code></pre> <p>The new imports unlock powerful features:</p> <ul> <li><code>ColorUtility</code>: Preserves and works with existing color transformations in your input file</li> <li><code>Convert</code>: Provides utilities for converting between different ASS value formats (like alpha values)</li> </ul> <p>1. Setting Up Color Preservation with ColorUtility</p> <p>First, let's set up PyonFX's <code>ColorUtility</code> to preserve any existing color styling from our input file:</p> <pre><code># Set up ColorUtility to preserve existing color transformations\ncu = ColorUtility(lines)\n</code></pre> <p><code>ColorUtility</code> is a utility that analyzes your entire ASS file and extracts any existing color changes or transformations (like <code>\\1c</code>, <code>\\3c</code>, <code>\\t</code> tags). It then provides methods to recreate those color effects in your output, ensuring that any original styling is maintained while your karaoke effects are applied.</p> <p>This way you don't need to hardcode color changes in your code: simply use <code>cu.get_color_change(line, c1=True, c3=True)</code> to get the color changes for a line, and then apply them to your output. For more information, see the ColorUtility documentation.</p> <p>2. Creating Actor-Based Theme System</p> <p>Next, let's prepare a dictionary of color themes for different performers:</p> <pre><code># Define color themes for different actors\nACTOR_THEMES = {\n    \"Singer1\": {\n        \"highlight\": \"&amp;H4B19E6&amp;\",  # Purple\n        \"outline\": \"&amp;H8B4B9B&amp;\",   # Light purple\n        \"fade\": \"&amp;HBB6BFF&amp;\",      # Very light purple\n    },\n    \"Singer2\": {\n        \"highlight\": \"&amp;H19E64B&amp;\",  # Green\n        \"outline\": \"&amp;H4B9B8B&amp;\",   # Light green\n        \"fade\": \"&amp;H6BFFBB&amp;\",      # Very light green\n    },\n    \"\": {  # Default (no actor)\n        \"highlight\": \"&amp;HFFFFFF&amp;\",  # White\n        \"outline\": \"&amp;HABABAB&amp;\",   # Gray\n        \"fade\": \"&amp;HDDDDDD&amp;\",      # Light gray\n    },\n}\n</code></pre> <p>3. Enhanced Leadin/Leadout Effect with Theming</p> <p>Let's upgrade our leadin effect to use the theme system:</p> <pre><code>@io.track\ndef leadin_effect(line: Line, syl: Syllable, l: Line):\n    l.layer = 0\n    l.start_time = line.start_time - line.leadin // 2\n    l.end_time = line.start_time + syl.start_time\n\n    # Original style values\n    c1 = line.styleref.color1\n    c3 = line.styleref.color3\n\n    # Configuration\n    theme = ACTOR_THEMES.get(line.actor, ACTOR_THEMES[\"\"])\n\n    tags = (\n        rf\"\\an5\\pos({syl.center:.3f},{syl.middle:.3f})\"\n        rf\"\\1c{theme['fade']}\\3c{theme['outline']}\"\n        rf\"\\t(0,{line.leadin // 2},\\1c{c1}\\3c{c3})\"\n        rf\"\\fad({line.leadin // 2},0)\"\n    )\n    l.text = f\"{{{tags}}}{syl.text}\"\n\n    io.write_line(l)\n</code></pre> <p>Notice how we:</p> <ul> <li>Extract the theme using <code>ACTOR_THEMES.get(line.actor, ACTOR_THEMES[\"\"])</code> - this gets the actor's theme or falls back to default</li> <li>Start with theme colors then transition to the original line colors using <code>\\t()</code> transforms</li> <li>Preserve original styling by storing and returning to <code>c1</code> and <code>c3</code></li> </ul> <p>We can do something similar for the leadout effect, but we'll leave it to you for exercise! (Or you could check the full source code at the end of this tutorial )</p> <p>4. Enhanced Main Effect with Theming</p> <p>Let's also apply the theme to the main effect:</p> <pre><code>@io.track\ndef highlight_effect(line: Line, syl: Syllable, l: Line):\n    l.layer = 1\n    l.start_time = line.start_time + syl.start_time\n    l.end_time = line.start_time + syl.end_time\n\n    # Original style values\n    c1 = line.styleref.color1\n    c3 = line.styleref.color3\n    fscx = line.styleref.scale_x\n    fscy = line.styleref.scale_y\n\n    # Configuration\n    theme = ACTOR_THEMES.get(line.actor, ACTOR_THEMES[\"\"])\n    t_fscx = fscx * 1.25\n    t_fscy = fscy * 1.25\n    grow_duration = syl.duration // 2\n\n    tags = (\n        rf\"\\an5\\pos({syl.center:.3f},{syl.middle:.3f})\"\n        rf\"\\t(0,{grow_duration},\\fscx{t_fscx}\\fscy{t_fscy}\\1c{theme['highlight']}\\3c{theme['outline']})\"\n        rf\"\\t({grow_duration},{syl.duration},\\fscx{fscx}\\fscy{fscy}\\1c{c1}\\3c{c3})\"\n    )\n    l.text = f\"{{{tags}}}{syl.text}\"\n\n    io.write_line(l)\n</code></pre> <p>5. Creating Special Effects for Dramatic Moments</p> <p>For syllables marked with special effects, we'll create a dramatic echo effect:</p> <pre><code>@io.track\ndef main_echo_effect(line: Line, syl: Syllable, l: Line):\n    l.layer = 1\n    l.start_time = line.start_time + syl.start_time\n    l.end_time = line.start_time + syl.end_time\n\n    # Original style values\n    c1 = line.styleref.color1\n    fscx = line.styleref.scale_x\n    fscy = line.styleref.scale_y\n\n    # Configuration\n    theme = ACTOR_THEMES.get(line.actor, ACTOR_THEMES[\"\"])\n\n    # Base layer (fully opaque)\n    tags = (\n        rf\"\\an5\\pos({syl.center:.3f},{syl.middle:.3f})\"\n        rf\"\\t(0,{syl.duration // 2},\\1c{theme['highlight']})\"\n        rf\"\\t({syl.duration // 2},{syl.duration},\\1c{c1})\"\n    )\n    l.text = f\"{{{tags}}}{syl.text}\"\n    io.write_line(l)\n\n    # Echo Configuration\n    echo_layer_count = 8\n    max_fscx, max_fscy = fscx * 1.6, fscy * 1.6\n    min_alpha, max_alpha = 130, 230\n\n    # Echo layers (progressively larger and more transparent)\n    for layer_index in range(1, echo_layer_count + 1):\n        l.layer = 1 + layer_index\n\n        # Calculate interpolation factor (0.0 to 1.0)\n        progress = layer_index / echo_layer_count\n\n        # Interpolated values\n        echo_fscx = fscx + (max_fscx - fscx) * progress\n        echo_fscy = fscy + (max_fscy - fscy) * progress\n        echo_alpha = Convert.alpha_dec_to_ass(min_alpha + (max_alpha - min_alpha) * progress)\n\n        tags = (\n            rf\"\\an5\\pos({syl.center:.3f},{syl.middle:.3f})\\alpha{echo_alpha}\"\n            rf\"\\t(0,{syl.duration // 2},\\1c{theme['highlight']}\\fscx{echo_fscx}\\fscy{echo_fscy})\"\n            rf\"\\t({syl.duration // 2},{syl.duration},\\1c{c1}\\fscx{fscx}\\fscy{fscy})\"\n            rf\"\\fad({syl.duration // 4},{syl.duration // 4})\"\n        )\n\n        l.text = f\"{{{tags}}}{syl.text}\"\n        io.write_line(l)\n</code></pre> <p>This creates a multi-layered echo effect where:</p> <ul> <li>Base layer: Normal syllable with color transitions</li> <li>Echo layers: 8 additional layers with progressively larger scale and increasing transparency</li> <li>Mathematical progression: Each layer scales and fades according to its position in the sequence</li> <li>Convert utility: <code>Convert.alpha_dec_to_ass()</code> converts decimal alpha values (0-255) to ASS hex format</li> </ul> <p>6. Upgrading Effect Dispatch</p> <p>Now we enhance our handler functions to automatically choose effects based on syllable properties:</p> <pre><code>@io.track\ndef romaji(line: Line, l: Line):\n    for syl in Utils.all_non_empty(line.syls):\n        leadin_effect(line, syl, l)\n        if syl.inline_fx == \"echo\":\n            main_echo_effect(line, syl, l)\n        else:\n            highlight_effect(line, syl, l)\n        leadout_effect(line, syl, l)\n</code></pre> <p>The <code>syl.inline_fx</code> property contains any special effect tags from your ASS file. When PyonFX finds <code>{\\fx}echo{\\fxend}</code> tags around a syllable, it automatically sets <code>syl.inline_fx = \"echo\"</code>, triggering our special effect.</p> <p>We'll leave up to you to upgrade the kanji dispatcher as well!</p> <p>7. Making use of ColorUtility in the translation lines</p> <p>For translation lines, we'll use <code>ColorUtility</code> to preserve any existing color styling:</p> <pre><code>@io.track\ndef translation(line: Line, l: Line):\n    l.start_time = line.start_time - line.leadin // 2\n    l.end_time = line.end_time + line.leadout // 2\n\n    tags = (\n        rf\"\\fad({line.leadin // 2}, {line.leadout // 2})\"\n        f\"{cu.get_color_change(l, c1=True, c3=True)}\"\n    )\n\n    l.text = f\"{{{tags}}}{line.text}\"\n\n    io.write_line(l)\n</code></pre> <p><code>ColorUtility.get_color_change()</code> uses the timing of your line (<code>l.start_time</code> and <code>l.end_time</code>) to determine which color transformations from the original ASS file should be applied during that time range. It generates the appropriate ASS tags to recreate those color effects at the correct timing. This means if your input file has color transformations that overlap with your line's timing, those colors will be accurately reproduced in the output.</p> <p>8. Final Result</p> <p>Save and preview your effect:</p> <pre><code>io.save()\nio.open_aegisub()\n</code></pre> <p>You'll now see a sophisticated karaoke experience with:</p> <ul> <li>Color-coded singers: Different performers get distinct visual themes</li> <li>Special effects: Syllables marked for emphasis get dramatic echo effects</li> <li>Preserved styling: Existing colors and transformations from the input file remain intact</li> <li>Smart automation: All variations happen automatically based on input file metadata</li> </ul> <p></p>"},{"location":"tutorials/2-intermediate/01-variations/#conclusion","title":"Conclusion","text":"<p>Excellent work. You've transformed your basic karaoke system into a sophisticated variation system. You've learned to leverage PyonFX's advanced features like actor-based theming, inline effect detection, and color preservation utilities.</p> <p>In the next tutorial, we'll explore one of the PyonFX most powerful classes: the <code>Shape</code> class.</p>"},{"location":"tutorials/2-intermediate/01-variations/#full-source-code","title":"Full Source Code","text":"Show full source code <pre><code>\"\"\"\nTutorial: Adding variety\n\nThis tutorial demonstrates how to add variety to your effects by using:\n\u2022 line.actor to personalize the effect for specific lines\n\u2022 syl.inline_fx to apply special effects to specific syllables\n\u2022 ColorUtility to change colors based on existing color transformations in the input file\n\nExercise:\n\u2022 Try using line.effect instead of line.actor\n\u2022 Try adding a \"rotate\" highlight effect, transforming over the \\\\frz tag: you'll find that the input .ass file already has some syllables marked with it\n\"\"\"\n\nfrom pyonfx import Ass, ColorUtility, Convert, Line, Syllable, Utils\n\nio = Ass(\"../../ass/romaji_kanji_translation.ass\", vertical_kanji=True)\nmeta, styles, lines = io.get_data()\n\n# Set up ColorUtility to preserve existing color transformations\ncu = ColorUtility(lines)\n\n# Define color themes for different actors\nACTOR_THEMES = {\n    \"Singer1\": {\n        \"highlight\": \"&amp;H4B19E6&amp;\",  # Purple\n        \"outline\": \"&amp;H8B4B9B&amp;\",  # Light purple\n        \"fade\": \"&amp;HBB6BFF&amp;\",  # Very light purple\n    },\n    \"Singer2\": {\n        \"highlight\": \"&amp;H19E64B&amp;\",  # Green\n        \"outline\": \"&amp;H4B9B8B&amp;\",  # Light green\n        \"fade\": \"&amp;H6BFFBB&amp;\",  # Very light green\n    },\n    \"\": {  # Default (no actor)\n        \"highlight\": \"&amp;HFFFFFF&amp;\",  # White\n        \"outline\": \"&amp;HABABAB&amp;\",  # Gray\n        \"fade\": \"&amp;HDDDDDD&amp;\",  # Light gray\n    },\n}\n\n\n@io.track\ndef leadin_effect(line: Line, syl: Syllable, l: Line):\n    l.layer = 0\n    l.start_time = line.start_time - line.leadin // 2\n    l.end_time = line.start_time + syl.start_time\n\n    # Original style values\n    c1 = line.styleref.color1\n    c3 = line.styleref.color3\n\n    # Configuration\n    theme = ACTOR_THEMES.get(line.actor, ACTOR_THEMES[\"\"])\n\n    tags = (\n        rf\"\\an5\\pos({syl.center:.3f},{syl.middle:.3f})\"\n        rf\"\\1c{theme['fade']}\\3c{theme['outline']}\"\n        rf\"\\t(0,{line.leadin // 2},\\1c{c1}\\3c{c3})\"\n        rf\"\\fad({line.leadin // 2},0)\"\n    )\n    l.text = f\"{{{tags}}}{syl.text}\"\n\n    io.write_line(l)\n\n\n@io.track\ndef highlight_effect(line: Line, syl: Syllable, l: Line):\n    l.layer = 1\n    l.start_time = line.start_time + syl.start_time\n    l.end_time = line.start_time + syl.end_time\n\n    # Original style values\n    c1 = line.styleref.color1\n    c3 = line.styleref.color3\n    fscx = line.styleref.scale_x\n    fscy = line.styleref.scale_y\n\n    # Configuration\n    theme = ACTOR_THEMES.get(line.actor, ACTOR_THEMES[\"\"])\n    t_fscx = fscx * 1.25\n    t_fscy = fscy * 1.25\n    grow_duration = syl.duration // 2\n\n    tags = (\n        rf\"\\an5\\pos({syl.center:.3f},{syl.middle:.3f})\"\n        rf\"\\t(0,{grow_duration},\\fscx{t_fscx}\\fscy{t_fscy}\\1c{theme['highlight']}\\3c{theme['outline']})\"\n        rf\"\\t({grow_duration},{syl.duration},\\fscx{fscx}\\fscy{fscy}\\1c{c1}\\3c{c3})\"\n    )\n    l.text = f\"{{{tags}}}{syl.text}\"\n\n    io.write_line(l)\n\n\n@io.track\ndef main_echo_effect(line: Line, syl: Syllable, l: Line):\n    l.layer = 1\n    l.start_time = line.start_time + syl.start_time\n    l.end_time = line.start_time + syl.end_time\n\n    # Original style values\n    c1 = line.styleref.color1\n    fscx = line.styleref.scale_x\n    fscy = line.styleref.scale_y\n\n    # Configuration\n    theme = ACTOR_THEMES.get(line.actor, ACTOR_THEMES[\"\"])\n\n    # Base layer (fully opaque)\n    tags = (\n        rf\"\\an5\\pos({syl.center:.3f},{syl.middle:.3f})\"\n        rf\"\\t(0,{syl.duration // 2},\\1c{theme['highlight']})\"\n        rf\"\\t({syl.duration // 2},{syl.duration},\\1c{c1})\"\n    )\n    l.text = f\"{{{tags}}}{syl.text}\"\n    io.write_line(l)\n\n    # Echo Configuration\n    echo_layer_count = 8\n    max_fscx, max_fscy = fscx * 1.6, fscy * 1.6\n    min_alpha, max_alpha = 130, 230\n\n    # Echo layers (progressively larger and more transparent)\n    for layer_index in range(1, echo_layer_count + 1):\n        l.layer = 1 + layer_index\n\n        # Calculate interpolation factor (0.0 to 1.0)\n        progress = layer_index / echo_layer_count\n\n        # Interpolated values\n        echo_fscx = fscx + (max_fscx - fscx) * progress\n        echo_fscy = fscy + (max_fscy - fscy) * progress\n        echo_alpha = Convert.alpha_dec_to_ass(\n            min_alpha + (max_alpha - min_alpha) * progress\n        )\n\n        tags = (\n            rf\"\\an5\\pos({syl.center:.3f},{syl.middle:.3f})\\alpha{echo_alpha}\"\n            rf\"\\t(0,{syl.duration // 2},\\1c{theme['highlight']}\\fscx{echo_fscx}\\fscy{echo_fscy})\"\n            rf\"\\t({syl.duration // 2},{syl.duration},\\1c{c1}\\fscx{fscx}\\fscy{fscy})\"\n            rf\"\\fad({syl.duration // 4},{syl.duration // 4})\"\n        )\n\n        l.text = f\"{{{tags}}}{syl.text}\"\n        io.write_line(l)\n\n\n@io.track\ndef leadout_effect(line: Line, syl: Syllable, l: Line):\n    l.layer = 0\n    l.start_time = line.start_time + syl.end_time\n    l.end_time = line.end_time + line.leadout // 2\n\n    # Original style values\n    original_c1 = line.styleref.color1\n    original_c3 = line.styleref.color3\n\n    # Configuration\n    theme = ACTOR_THEMES.get(line.actor, ACTOR_THEMES[\"\"])\n    leadout_duration = line.leadout // 2\n    color_transition_start = l.duration - leadout_duration\n\n    tags = (\n        rf\"\\an5\\pos({syl.center:.3f},{syl.middle:.3f})\"\n        rf\"\\1c{original_c1}\\3c{original_c3}\"\n        rf\"\\t({color_transition_start},{l.duration},\\1c{theme['fade']}\\3c{theme['outline']})\"\n        rf\"\\fad(0,{leadout_duration})\"\n    )\n    l.text = f\"{{{tags}}}{syl.text}\"\n\n    io.write_line(l)\n\n\n@io.track\ndef romaji(line: Line, l: Line):\n    for syl in Utils.all_non_empty(line.syls):\n        leadin_effect(line, syl, l)\n        if syl.inline_fx == \"echo\":\n            main_echo_effect(line, syl, l)\n        else:\n            highlight_effect(line, syl, l)\n        leadout_effect(line, syl, l)\n\n\n@io.track\ndef kanji(line: Line, l: Line):\n    for syl in Utils.all_non_empty(line.syls):\n        leadin_effect(line, syl, l)\n        if syl.inline_fx == \"echo\":\n            main_echo_effect(line, syl, l)\n        else:\n            highlight_effect(line, syl, l)\n        leadout_effect(line, syl, l)\n\n\n@io.track\ndef translation(line: Line, l: Line):\n    l.start_time = line.start_time - line.leadin // 2\n    l.end_time = line.end_time + line.leadout // 2\n\n    tags = (\n        rf\"\\fad({line.leadin // 2}, {line.leadout // 2})\"\n        f\"{cu.get_color_change(l, c1=True, c3=True)}\"\n    )\n\n    l.text = f\"{{{tags}}}{line.text}\"\n\n    io.write_line(l)\n\n\n# Generating lines\nfor line in Utils.all_non_empty(lines):\n    l = line.copy()\n\n    # Process based on alignment (line type)\n    if line.styleref.alignment &gt;= 7:\n        romaji(line, l)\n    elif line.styleref.alignment &gt;= 4:\n        kanji(line, l)\n    else:\n        translation(line, l)\n\nio.save()\nio.open_aegisub()\n</code></pre>"},{"location":"tutorials/2-intermediate/02-shapes/","title":"Tutorial: Adding Shapes to your Karaoke Effects","text":"<p>In this tutorial, you'll learn how to use PyonFX's <code>Shape</code> module to integrate geometric shapes into your karaoke effects. You'll create moving, rotating, and animated shapes that add visual interest to complement your syllable highlighting.</p>"},{"location":"tutorials/2-intermediate/02-shapes/#materials","title":"Materials","text":"<p>We'll continue with the same romaji_kanji_translation.ass file, building upon the foundation from previous tutorials.</p>"},{"location":"tutorials/2-intermediate/02-shapes/#understanding-pyonfx-shapes","title":"Understanding PyonFX Shapes","text":"<p>PyonFX's <code>Shape</code> class is a powerful tool for creating and manipulating vector graphics programmatically. It provides methods to:</p> <ul> <li>Generate new shapes: like rectangles, circles, stars and more</li> <li>Integrate with ASS: automatic conversion to and from ASS drawing commands</li> <li>Manipulate shapes: geometric transformations (e.g., move, scale, rotate, shear), analysis (e.g., bounding box computation), and more</li> </ul> <p>For more information, please refer to the reference documentation.</p> <p>Shapes are perfect for creating backgrounds, decorative elements, particle effects and more to enhance the visual appeal of your karaoke.</p>"},{"location":"tutorials/2-intermediate/02-shapes/#code-walkthrough","title":"Code Walkthrough","text":"<p>0. Familiar Setup with New Imports</p> <p>We start with our familiar pattern but add the <code>Shape</code> module and the built-in <code>random</code> module:</p> <pre><code>from pyonfx import Ass, Convert, Line, Shape, Syllable, Utils\nimport random\n\nio = Ass(\"../../ass/romaji_kanji_translation.ass\", vertical_kanji=True)\nmeta, styles, lines = io.get_data()\n</code></pre> <p>1. Creating Utility Functions for Complex Animations</p> <p>Let's start by building a utility function for creating oscillating animations:</p> <pre><code>def generate_oscillating_transforms(\n    start_time: int, end_time: int, cycle_duration: int, tags1: str, tags2: str\n) -&gt; str:\n    \"\"\"Generate a string of oscillating \\\\t transformations between two sets of tags.\n\n    Alternates tags1/tags2 every half of cycle_duration, from start_time to end_time.\n    \"\"\"\n    duration = end_time - start_time\n    if duration &lt;= 0 or cycle_duration &lt;= 0:\n        return \"\"\n\n    half_cycle = cycle_duration // 2\n    transforms = []\n\n    # We step through each full cycle\n    for current_time in range(0, duration, cycle_duration):\n        first_half_end = min(current_time + half_cycle, duration)\n        second_half_end = min(current_time + cycle_duration, duration)\n\n        # First half: to tags1\n        if first_half_end &gt; current_time:\n            transforms.append(\n                f\"\\\\t({start_time + current_time},{start_time + first_half_end},{tags1})\"\n            )\n        # Second half: to tags2\n        if second_half_end &gt; first_half_end:\n            transforms.append(\n                f\"\\\\t({start_time + first_half_end},{start_time + second_half_end},{tags2})\"\n            )\n\n    return \"\".join(transforms)\n</code></pre> <p>This function creates smooth oscillating animations by generating a series of transform (<code>\\t</code>) tags that alternate between two states. We'll make use of this function in the next section.</p> <p>2. Creating Pulsing Heart Decorations</p> <p>Let's use our utility function to create pulsing heart shapes that appear on both sides of each line:</p> <pre><code>@io.track\ndef heartbeat_effect(line: Line, l: Line):\n    \"\"\"Creates pulsing hearts on the left and right sides of each line\"\"\"\n    l.layer = 0\n    l.start_time = line.start_time - line.leadin // 2\n    l.end_time = line.end_time + line.leadout // 2\n\n    # Configuration\n    HEART_SHAPE = Shape.heart(30)\n    HEARTBEAT_PERIOD = 800  # milliseconds for one heartbeat cycle\n    HEART_SCALE_MIN = 80  # minimum scale percentage\n    HEART_SCALE_MAX = 120  # maximum scale percentage\n    HEART_OFFSET = 30  # pixels spacing from text\n\n    # Generate oscillating scale transforms\n    scale_max = rf\"\\fscx{HEART_SCALE_MAX}\\fscy{HEART_SCALE_MAX}\"\n    scale_min = rf\"\\fscx{HEART_SCALE_MIN}\\fscy{HEART_SCALE_MIN}\"\n    oscillating_transforms = generate_oscillating_transforms(\n        0, l.duration, HEARTBEAT_PERIOD, scale_max, scale_min\n    )\n\n    # Prepare common tags for both hearts\n    common_tags = (\n        rf\"\\fad({line.leadin // 4},{line.leadin // 4})\"\n        rf\"{oscillating_transforms}\"\n        rf\"\\1c&amp;HEAE3FF&amp;\\3c&amp;HCBBBFF&amp;\\bord2\\shad0\\p1\"\n    )\n\n    # Left heart\n    position_tags = rf\"\\an5\\pos({line.left - HEART_OFFSET},{line.middle})\"\n    l.text = f\"{{{position_tags}{common_tags}}}{HEART_SHAPE}\"\n    io.write_line(l)\n\n    # Right heart\n    position_tags = rf\"\\an5\\pos({line.right + HEART_OFFSET},{line.middle})\"\n    l.text = f\"{{{position_tags}{common_tags}}}{HEART_SHAPE}\"\n    io.write_line(l)\n</code></pre> <p>This creates heart shapes that pulse in sync on both sides of each line.</p> <p>3. Creating Dynamic Shape Effects</p> <p>Now let's create random moving shapes that appear behind syllables:</p> <pre><code>@io.track\ndef highlight_effect_shapes(line: Line, syl: Syllable, l: Line):\n    \"\"\"Creates random moving and rotating shapes behind syllables\"\"\"\n    l.layer = 0\n    l.start_time = line.start_time + syl.start_time\n    l.end_time = line.start_time + syl.end_time\n\n    # Configuration\n    SHAPE_SIZE = 20  # pixels\n    HIGHLIGHT_SHAPES: list[Shape] = [\n        Shape.triangle(SHAPE_SIZE, SHAPE_SIZE),\n        Shape.rectangle(SHAPE_SIZE, SHAPE_SIZE),\n        Shape.polygon(5, SHAPE_SIZE),  # pentagon\n        Shape.polygon(6, SHAPE_SIZE),  # hexagon\n        Shape.ellipse(SHAPE_SIZE, SHAPE_SIZE),\n        Shape.circle(SHAPE_SIZE),\n        Shape.ring(SHAPE_SIZE, SHAPE_SIZE // 2),\n        Shape.star(5, SHAPE_SIZE // 2, SHAPE_SIZE),\n        Shape.glance(4, SHAPE_SIZE // 2, SHAPE_SIZE),\n    ]\n    SHAPES_NUMBER = 10\n</code></pre> <p>We define a collection of shapes and then generate multiple instances with random properties:</p> <pre><code>    for _ in range(SHAPES_NUMBER):\n        # Generate random shape\n        shape = random.choice(HIGHLIGHT_SHAPES)\n\n        # Random movement parameters\n        start_x = syl.center\n        start_y = syl.middle\n        end_x = start_x + random.randint(-int(syl.width * 0.7), int(syl.width * 0.7))\n        end_y = start_y + random.randint(-int(syl.height * 0.7), int(syl.height * 0.7))\n\n        # Random rotation\n        rotation = random.randint(90, 270) * (1 if random.random() &gt; 0.5 else -1)\n\n        # Random color (bright colors)\n        r = random.randint(127, 255)\n        g = random.randint(127, 255)\n        b = random.randint(127, 255)\n        color = Convert.color_rgb_to_ass((r, g, b))\n\n        # Fade out duration\n        fade_duration = syl.duration // 4\n</code></pre> <p>Notice how we generate random colors: we create RGB values (each component from 127-255 to ensure bright colors) and then use <code>Convert.color_rgb_to_ass()</code> to convert the RGB tuple into ASS color format.</p> <p>Finally, we create the ASS drawing and animate it:</p> <pre><code>        tags = (\n            rf\"\\an5\\move({start_x:.3f},{start_y:.3f},{end_x:.3f},{end_y:.3f})\"\n            rf\"\\fad({fade_duration},{fade_duration})\"\n            rf\"\\t(\\frz{rotation})\"\n            rf\"\\fscx{syl.height}\\fscy{syl.height}\"\n            rf\"\\bord1\\1c{color}\\3c&amp;H000000&amp;\\p1\"\n        )\n        l.text = f\"{{{tags}}}{shape}\"\n        io.write_line(l)\n</code></pre> <p>Each shape starts at the syllable's center, moves to a random nearby position, rotates, and fades in/out.</p> <p>4. Reusing Previous Leadin/Main/Leadout Effects</p> <p>Since they are not the focus of this tutorial, let's reuse the same <code>leadin_effect()</code>, <code>highlight_effect()</code>, and <code>leadout_effect()</code> functions from the previous tutorial. Simply copy and paste them into your code.</p> <p>5. Enhanced Line Processors with the new effects</p> <p>We integrate our shape effects into the line processing workflow:</p> <pre><code>@io.track\ndef romaji(line: Line, l: Line):\n    heartbeat_effect(line, l)\n    for syl in Utils.all_non_empty(line.syls):\n        leadin_effect(line, syl, l)\n        highlight_effect(line, syl, l)\n        highlight_effect_shapes(line, syl, l)\n        leadout_effect(line, syl, l)\n\n\n# Process all lines\nfor line in Utils.all_non_empty(lines):\n    l = line.copy()\n    if line.styleref.alignment &gt;= 7:\n        romaji(line, l)\n</code></pre> <p>Notice that for this effect we focus on romaji lines only.</p> <p>6. Saving and Previewing Your Masterpiece</p> <p>Save and preview your enhanced karaoke system:</p> <pre><code>io.save()\nio.open_aegisub()\n</code></pre> <p>You'll now see an enhanced karaoke experience with:</p> <ul> <li>Pulsing heart decorations that appear on both sides of lines</li> <li>Dynamic shape particles that move around syllables during highlighting</li> </ul> <p></p>"},{"location":"tutorials/2-intermediate/02-shapes/#conclusion","title":"Conclusion","text":"<p>Great job. You've now learned the fundamentals of PyonFX's shape system. You've discovered how to create geometric animations and build utility functions for reusable animation patterns. Your karaoke effects now include heart decorations with pulsing animations and dynamic particle effects.</p> <p>You've built a solid foundation covering text segmentation, timing, positioning, theming, variations, and shape integration. This gives you the tools needed to create engaging karaoke effects for a variety of projects.</p> <p>And thus, this concludes the intermediate series. The advanced series will cover even more sophisticated techniques and workflows.</p>"},{"location":"tutorials/2-intermediate/02-shapes/#full-source-code","title":"Full Source Code","text":"Show full source code <pre><code>\"\"\"\nTutorial: Adding shapes\n\nThis tutorial demonstrates how to make use of the Shape class to enrich KFXes.\n\nThe script creates two main effect types:\n\u2022 `heartbeat_effect`: Continuous pulsing hearts on left and right sides of the screen\n\u2022 `highlight_effect_shapes`: Random shapes that move and rotate behind each syllable during singing\n\nExercise:\n\u2022 Try creating a pattern of equally spaced semi-transparent shapes behind the line instead of the 2 hearts\n\u2022 Try changing the shape's alignment for the highlight effect or add a \\\\org tag to change the result of the \\\\frz tag\n\u2022 Try extending these effects also to kanji and translation lines\n\"\"\"\n\nimport random\n\nfrom pyonfx import Ass, Convert, Line, Shape, Syllable, Utils\n\nio = Ass(\"../../ass/romaji_kanji_translation.ass\")\nmeta, styles, lines = io.get_data()\n\n\ndef generate_oscillating_transforms(\n    start_time: int, end_time: int, cycle_duration: int, tags1: str, tags2: str\n) -&gt; str:\n    \"\"\"Generate a string of oscillating \\\\t transformations between two sets of tags.\n\n    Alternates tags1/tags2 every half of cycle_duration, from start_time to end_time.\n    \"\"\"\n    duration = end_time - start_time\n    if duration &lt;= 0 or cycle_duration &lt;= 0:\n        return \"\"\n\n    half_cycle = cycle_duration // 2\n    transforms = []\n\n    # We step through each full cycle\n    for current_time in range(0, duration, cycle_duration):\n        first_half_end = min(current_time + half_cycle, duration)\n        second_half_end = min(current_time + cycle_duration, duration)\n\n        # First half: to tags1\n        if first_half_end &gt; current_time:\n            transforms.append(\n                f\"\\\\t({start_time + current_time},{start_time + first_half_end},{tags1})\"\n            )\n        # Second half: to tags2\n        if second_half_end &gt; first_half_end:\n            transforms.append(\n                f\"\\\\t({start_time + first_half_end},{start_time + second_half_end},{tags2})\"\n            )\n\n    return \"\".join(transforms)\n\n\n@io.track\ndef heartbeat_effect(line: Line, l: Line):\n    \"\"\"Creates pulsing hearts on the left and right sides of each line\"\"\"\n    l.layer = 0\n    l.start_time = line.start_time - line.leadin // 2\n    l.end_time = line.end_time + line.leadout // 2\n\n    # Configuration\n    HEART_SHAPE = Shape.heart(30)\n    HEARTBEAT_PERIOD = 800  # milliseconds for one heartbeat cycle\n    HEART_SCALE_MIN = 80  # minimum scale percentage\n    HEART_SCALE_MAX = 120  # maximum scale percentage\n    HEART_OFFSET = 30  # pixels spacing from text\n\n    # Generate oscillating scale transforms\n    scale_max = rf\"\\fscx{HEART_SCALE_MAX}\\fscy{HEART_SCALE_MAX}\"\n    scale_min = rf\"\\fscx{HEART_SCALE_MIN}\\fscy{HEART_SCALE_MIN}\"\n    oscillating_transforms = generate_oscillating_transforms(\n        0, l.duration, HEARTBEAT_PERIOD, scale_max, scale_min\n    )\n\n    # Prepare common tags for both hearts\n    common_tags = (\n        rf\"\\fad({line.leadin // 4},{line.leadin // 4})\"\n        rf\"{oscillating_transforms}\"\n        rf\"\\1c&amp;HEAE3FF&amp;\\3c&amp;HCBBBFF&amp;\\bord2\\shad0\\p1\"\n    )\n\n    # Left heart\n    position_tags = rf\"\\an5\\pos({line.left - HEART_OFFSET},{line.middle})\"\n    l.text = f\"{{{position_tags}{common_tags}}}{HEART_SHAPE}\"\n    io.write_line(l)\n\n    # Right heart\n    position_tags = rf\"\\an5\\pos({line.right + HEART_OFFSET},{line.middle})\"\n    l.text = f\"{{{position_tags}{common_tags}}}{HEART_SHAPE}\"\n    io.write_line(l)\n\n\n@io.track\ndef highlight_effect_shapes(line: Line, syl: Syllable, l: Line):\n    \"\"\"Creates random moving and rotating shapes behind syllables\"\"\"\n    l.layer = 0\n    l.start_time = line.start_time + syl.start_time\n    l.end_time = line.start_time + syl.end_time\n\n    # Configuration\n    SHAPE_SIZE = 20  # pixels\n    HIGHLIGHT_SHAPES: list[Shape] = [\n        Shape.triangle(SHAPE_SIZE, SHAPE_SIZE),\n        Shape.rectangle(SHAPE_SIZE, SHAPE_SIZE),\n        Shape.polygon(5, SHAPE_SIZE),  # pentagon\n        Shape.polygon(6, SHAPE_SIZE),  # hexagon\n        Shape.ellipse(SHAPE_SIZE, SHAPE_SIZE),\n        Shape.circle(SHAPE_SIZE),\n        Shape.ring(SHAPE_SIZE, SHAPE_SIZE // 2),\n        Shape.star(5, SHAPE_SIZE // 2, SHAPE_SIZE),\n        Shape.glance(4, SHAPE_SIZE // 2, SHAPE_SIZE),\n    ]\n    SHAPES_NUMBER = 10\n\n    for _ in range(SHAPES_NUMBER):\n        # Generate random shape\n        shape = random.choice(HIGHLIGHT_SHAPES)\n\n        # Random movement parameters\n        start_x = syl.center\n        start_y = syl.middle\n        end_x = start_x + random.randint(-int(syl.width * 0.7), int(syl.width * 0.7))\n        end_y = start_y + random.randint(-int(syl.height * 0.7), int(syl.height * 0.7))\n\n        # Random rotation\n        rotation = random.randint(90, 270) * (1 if random.random() &gt; 0.5 else -1)\n\n        # Random color (bright colors)\n        r = random.randint(127, 255)\n        g = random.randint(127, 255)\n        b = random.randint(127, 255)\n        color = Convert.color_rgb_to_ass((r, g, b))\n\n        # Fade out duration\n        fade_duration = syl.duration // 4\n\n        tags = (\n            rf\"\\an5\\move({start_x:.3f},{start_y:.3f},{end_x:.3f},{end_y:.3f})\"\n            rf\"\\fad({fade_duration},{fade_duration})\"\n            rf\"\\t(\\frz{rotation})\"\n            rf\"\\fscx{syl.height}\\fscy{syl.height}\"\n            rf\"\\bord1\\1c{color}\\3c&amp;H000000&amp;\\p1\"\n        )\n        l.text = f\"{{{tags}}}{shape}\"\n        io.write_line(l)\n\n\n@io.track\ndef leadin_effect(line: Line, syl: Syllable, l: Line):\n    l.layer = 0\n    l.start_time = line.start_time - line.leadin // 2\n    l.end_time = line.start_time + syl.start_time\n\n    tags = rf\"\\an5\\pos({syl.center:.3f},{syl.middle:.3f})\\fad({line.leadin // 2},0)\"\n    l.text = f\"{{{tags}}}{syl.text}\"\n\n    io.write_line(l)\n\n\n@io.track\ndef highlight_effect(line: Line, syl: Syllable, l: Line):\n    l.layer = 1\n    l.start_time = line.start_time + syl.start_time\n    l.end_time = line.start_time + syl.end_time\n\n    # Original style values\n    c1 = line.styleref.color1\n    c3 = line.styleref.color3\n    fscx = line.styleref.scale_x\n    fscy = line.styleref.scale_y\n\n    # Target values\n    t_c1 = \"&amp;HFFFFFF&amp;\"\n    t_c3 = \"&amp;HABABAB&amp;\"\n    t_fscx = fscx * 1.25\n    t_fscy = fscy * 1.25\n    grow_duration = syl.duration // 2\n\n    tags = (\n        rf\"\\an5\\pos({syl.center:.3f},{syl.middle:.3f})\"\n        rf\"\\t(0,{grow_duration},\\fscx{t_fscx}\\fscy{t_fscy}\\1c{t_c1}\\3c{t_c3})\"\n        rf\"\\t({grow_duration},{syl.duration},\\fscx{fscx}\\fscy{fscy}\\1c{c1}\\3c{c3})\"\n    )\n    l.text = f\"{{{tags}}}{syl.text}\"\n\n    io.write_line(l)\n\n\n@io.track\ndef leadout_effect(line: Line, syl: Syllable, l: Line):\n    l.layer = 0\n    l.start_time = line.start_time + syl.end_time\n    l.end_time = line.end_time + line.leadout // 2\n\n    tags = rf\"\\an5\\pos({syl.center:.3f},{syl.middle:.3f})\\fad(0,{line.leadout // 2})\"\n    l.text = f\"{{{tags}}}{syl.text}\"\n\n    io.write_line(l)\n\n\n@io.track\ndef romaji(line: Line, l: Line):\n    heartbeat_effect(line, l)\n    for syl in Utils.all_non_empty(line.syls):\n        leadin_effect(line, syl, l)\n        highlight_effect(line, syl, l)\n        highlight_effect_shapes(line, syl, l)\n        leadout_effect(line, syl, l)\n\n\n# Process all lines\nfor line in Utils.all_non_empty(lines):\n    l = line.copy()\n    if line.styleref.alignment &gt;= 7:\n        romaji(line, l)\n\nio.save()\nio.open_aegisub()\n</code></pre>"},{"location":"tutorials/3-advanced/01-frame-by-frame/","title":"Tutorial: Frame-by-Frame Animations","text":"<p>Welcome to the advanced series.</p> <p>So far, you\u2019ve built rich effects using ASS tags and time-based transforms. That model goes a long way\u2014but there are moments when you want finer, per-frame control than a single <code>\\t(...)</code> can express cleanly. Typical cases include: position transformations that are not as simple as moving a syllable from one point to another (i.e. <code>\\move</code>), non-linear tags transformations, particle effects, and more.</p> <p>That\u2019s where frame\u2011by\u2011frame comes in. Instead of asking the renderer to animate inside one long subtitle line, you generate one output line per video frame over a time span. Each frame has its own start/end time, and you decide exactly what tags to render for that slice.</p> <p>In this tutorial, you\u2019ll practice the main workflow: iterate frames and compute all the necessary values for each frame.</p>"},{"location":"tutorials/3-advanced/01-frame-by-frame/#materials","title":"Materials","text":"<p>We'll continue with the same romaji_kanji_translation.ass file, building upon the foundation from previous tutorials.</p>"},{"location":"tutorials/3-advanced/01-frame-by-frame/#code-walkthrough","title":"Code Walkthrough","text":""},{"location":"tutorials/3-advanced/01-frame-by-frame/#0-setup","title":"0. Setup","text":"<p>We'll import what we need and prepare our usual I/O.</p> <pre><code>from pyonfx import Ass, FrameUtility, Line, Syllable, Utils\nimport random\n\nio = Ass(\"romaji_kanji_translation.ass\", vertical_kanji=True)\nmeta, styles, lines = io.get_data()\n</code></pre>"},{"location":"tutorials/3-advanced/01-frame-by-frame/#1-start-simple-per-frame-jitter-for-the-highlight","title":"1. Start simple: per-frame jitter for the highlight","text":"<p>We'll start by building the highlight effect. The idea: iterate each syllable's singing window frame-by-frame and nudge the rendered position slightly each frame.</p> <pre><code>@io.track\ndef highlight_effect(line: Line, syl: Syllable, l: Line):\n    fu = FrameUtility(\n        line.start_time + syl.start_time,\n        line.start_time + syl.end_time,\n        meta.timestamps,\n    )\n    for s, e, i, n in fu:\n        l.layer = 1\n        l.start_time = s\n        l.end_time = e\n\n        # Constant jitter amplitude: \u00b15 px\n        pos_x = syl.center + random.uniform(-5, 5)\n        pos_y = syl.middle + random.uniform(-5, 5)\n\n        tags = rf\"\\an5\\pos({pos_x:.3f},{pos_y:.3f})\"\n        l.text = f\"{{{tags}}}{syl.text}\"\n        io.write_line(l)\n</code></pre> <p>This already produces a lively highlight with subtle randomness.</p> <p></p> <p>What powers the loop above is <code>FrameUtility</code>, constructed with a start time, an end time, and the video timestamps from <code>meta</code>. Iterating it yields, for each frame: <code>(s, e, i, n)</code> where <code>s</code>/<code>e</code> are the current frame\u2019s start/end in milliseconds and <code>i/n</code> is normalized progress from 0 to 1 across the span. It also exposes <code>duration</code> (the total span length) and helpers we\u2019ll use shortly. See the reference for details: <code>FrameUtility</code>.</p>"},{"location":"tutorials/3-advanced/01-frame-by-frame/#2-improve-motion-dynamic-amplitude-with-fuadd","title":"2. Improve motion: dynamic amplitude with <code>fu.add(...)</code>","text":"<p><code>FrameUtility.add(start, end, value)</code> returns a frame-local ramp based on the current frame's midpoint, measured within the iterator's time span:</p> <ul> <li>Before <code>start</code>: returns <code>0</code></li> <li>Between <code>start</code> and <code>end</code>: linearly interpolates from <code>0</code> to <code>value</code></li> <li>After <code>end</code>: returns <code>value</code></li> </ul> <p>Because it returns just \u201cthe contribution for this frame,\u201d you can add multiple <code>fu.add(...)</code> calls together to build envelopes. For example, over a 0\u2192duration window:</p> <ul> <li><code>fu.add(0, duration/2,  +A)</code> grows from 0 to +A in the first half</li> <li><code>fu.add(duration/2, duration,  -A)</code> grows from 0 to -A in the second half</li> </ul> <p>Adding them yields a triangular envelope: 0 \u2192 +A \u2192 0. We\u2019ll use that as the jitter amplitude:</p> <pre><code>@io.track\ndef highlight_effect(line: Line, syl: Syllable, l: Line):\n    # Max amplitude\n    max_amp = 5.0\n\n    fu = FrameUtility(\n        line.start_time + syl.start_time,\n        line.start_time + syl.end_time,\n        meta.timestamps,\n    )\n    for s, e, i, n in fu:\n        l.layer = 1\n        l.start_time = s\n        l.end_time = e\n\n        # Grow amplitude in first half, shrink in second half\n        amp = fu.add(0, fu.duration / 2, max_amp)\n        amp += fu.add(fu.duration / 2, fu.duration, -max_amp)\n\n        pos_x = syl.center + random.uniform(-amp, amp)\n        pos_y = syl.middle + random.uniform(-amp, amp)\n\n        tags = rf\"\\an5\\pos({pos_x:.3f},{pos_y:.3f})\"\n        l.text = f\"{{{tags}}}{syl.text}\"\n        io.write_line(l)\n</code></pre> <p>Now the jitter ramps up and back down within the highlight window.</p> <p></p> <p>This is a detail, but it helps in making the highlight effect transition more smooth and natural.</p>"},{"location":"tutorials/3-advanced/01-frame-by-frame/#3-add-color-transitions-with-interpolation","title":"3. Add color transitions with interpolation","text":"<p>In the beginner series, you drove the highlight\u2019s color change using ASS <code>\\t(...)</code> transforms inside the tag string (see the earlier tutorials in <code>1-beginner/</code>, e.g. Your First KFX). That approach tells the renderer how to animate between two colors over a time span.</p> <p>Here, because we\u2019re emitting one subtitle line per frame, we need the exact color for each frame. That\u2019s what interpolation gives us: given a start time/value and an end time/value, compute the in\u2011between value for the current frame. Using <code>fu.interpolate(...)</code> ties the timing directly to the frame iterator, so each <code>(s, e)</code> window gets the correct color. If you ever need a value from a plain percentage instead of times, <code>Utils.interpolate(...)</code> does the same math from a 0..1 progress. Both variants support easing as a final parameter when you want non\u2011linear transitions.</p> <pre><code>@io.track\ndef highlight_effect(line: Line, syl: Syllable, l: Line):\n    # Max amplitude\n    max_amp = 5.0\n\n    # Original style values\n    style_c1 = line.styleref.color1\n    style_c3 = line.styleref.color3\n\n    # Target values\n    target_c1 = \"&amp;HFFFFFF&amp;\"\n    target_c3 = \"&amp;HABABAB&amp;\"\n\n    fu = FrameUtility(\n        line.start_time + syl.start_time,\n        line.start_time + syl.end_time,\n        meta.timestamps,\n    )\n    for s, e, i, n in fu:\n        l.layer = 1\n        l.start_time = s\n        l.end_time = e\n\n        # Position (jitter)\n        amp = fu.add(0, fu.duration / 2, max_amp)\n        amp += fu.add(fu.duration / 2, fu.duration, -max_amp)\n        pos_x = syl.center + random.uniform(-amp, amp)\n        pos_y = syl.middle + random.uniform(-amp, amp)\n\n        # Color\n        t1_c1 = fu.interpolate(0, fu.duration / 2, style_c1, target_c1)\n        t1_c3 = fu.interpolate(0, fu.duration / 2, style_c3, target_c3)\n        t2_c1 = fu.interpolate(fu.duration / 2, fu.duration, t1_c1, style_c1)\n        t2_c3 = fu.interpolate(fu.duration / 2, fu.duration, t1_c3, style_c3)\n\n        tags = rf\"\\an5\\pos({pos_x:.3f},{pos_y:.3f})\\1c{t2_c1}\\3c{t2_c3}\"\n        l.text = f\"{{{tags}}}{syl.text}\"\n\n        io.write_line(l)\n</code></pre> <p></p>"},{"location":"tutorials/3-advanced/01-frame-by-frame/#4-lead-in-and-lead-out-with-bezier-motion-and-easing","title":"4. Lead-in and lead-out with Bezier motion and easing","text":"<p>For the lead\u2011in/lead\u2011out, we\u2019ll take advantage of frame-by-frame to move the text along a smooth Bezier curve, something totally impossible otherwise, as the <code>\\t</code> tag doesn't work on <code>\\pos</code>, and you can have only a single <code>\\move</code> per line. A quadratic Bezier curve uses three points: start <code>P0</code>, control <code>P1</code>, and end <code>P2</code>. The curve begins at <code>P0</code>, ends at <code>P2</code>, and bends toward <code>P1</code>.</p> <p>First, you might want to create and build your own curve shape. One comfortable way to do so is to use an online tool like: Desmos: quadratic Bezier preview. At the link you'll find already the curve shape we'll use next, but you can create your own.</p> <p>To implement the curve, we\u2019ll use the third\u2011party <code>bezier</code> package to build and sample the curve. Install with <code>pip install bezier</code> if needed.</p> <pre><code>import bezier\n\n@io.track\ndef leadin_effect(line: Line, syl: Syllable, l: Line):\n    # Control points (start above-left, curve, end at syllable center)\n    x0, y0 = syl.center - 60.0, syl.middle - 20.0\n    x1, y1 = syl.center - 20.0, syl.middle - 50.0\n    x2, y2 = syl.center, syl.middle\n    curve = bezier.Curve([[x0, x1, x2], [y0, y1, y2]], degree=2)\n\n    # Frame-by-frame movement\n    fu = FrameUtility(line.start_time - line.leadin // 2, line.start_time, meta.timestamps)\n    for s, e, i, n in fu:\n        l.layer = 0\n        l.start_time = s\n        l.end_time = e\n\n        # Position (evaluate Bezier curve)\n        pct = i / n\n        curve_point = curve.evaluate(pct)\n        x, y = float(curve_point[0][0]), float(curve_point[1][0])\n\n        tags = rf\"\\an5\\pos({x:.3f},{y:.3f})\"\n        l.text = f\"{{{tags}}}{syl.text}\"\n\n        io.write_line(l)\n</code></pre> <p>If you execute the script, you'll se the text moving along the curve we defined! But it's a bit rough: we can add easing (to start faster and settle smoothly) and a soft fade\u2011in to make it more refined. Here\u2019s the complete lead\u2011in:</p> <pre><code>import bezier\n\n@io.track\ndef leadin_effect(line: Line, syl: Syllable, l: Line):\n    # Control points (start above-left, curve, end at syllable center)\n    x0, y0 = syl.center - 60.0, syl.middle - 20.0\n    x1, y1 = syl.center - 20.0, syl.middle - 50.0\n    x2, y2 = syl.center, syl.middle\n    curve = bezier.Curve([[x0, x1, x2], [y0, y1, y2]], degree=2)\n\n    # Frame-by-frame movement\n    fu = FrameUtility(line.start_time - line.leadin // 2, line.start_time, meta.timestamps)\n    for s, e, i, n in fu:\n        l.layer = 0\n        l.start_time = s\n        l.end_time = e\n\n        # Position (evaluate Bezier curve)\n        pct = Utils.accelerate(i/n, \"out_quart\")\n        curve_point = curve.evaluate(pct)\n        x, y = float(curve_point[0][0]), float(curve_point[1][0])\n\n        # Alpha (fade-in)\n        alpha = fu.interpolate(0, fu.duration, \"&amp;HFF&amp;\", \"&amp;H00&amp;\", \"out_quart\")\n\n        tags = rf\"\\an5\\pos({x:.3f},{y:.3f})\\alpha{alpha}\"\n        l.text = f\"{{{tags}}}{syl.text}\"\n\n        io.write_line(l)\n\n    # Static until syllable start\n    l.layer = 0\n    l.start_time = line.start_time\n    l.end_time = line.start_time + syl.start_time\n\n    tags = rf\"\\an5\\pos({syl.center:.3f},{syl.middle:.3f})\"\n    l.text = f\"{{{tags}}}{syl.text}\"\n    io.write_line(l)\n</code></pre> <p>A quick note on easing</p> <p>Easing controls how fast progress moves from start to end. With ASS <code>\\t(...)</code>, you can only supply a single acceleration exponent per segment (or keep it linear), and you must bake all timing into tags. In frame\u2011by\u2011frame you have more control:</p> <ul> <li><code>fu.interpolate(...)</code> and <code>Utils.interpolate(...)</code> accept:<ul> <li>a float exponent (classic ASS\u2011style acceleration)</li> <li>a named preset (e.g., <code>\"out_quart\"</code>, <code>\"in_back\"</code>, <code>\"in_out_sine\"</code>)</li> <li>a custom Python callable for fully bespoke curves</li> </ul> </li> <li><code>Utils.accelerate(...)</code> is the low-level function that applies a given easing to a progress percentage. In this case, we use it to change the progress along the Bezier curve. See <code>Utils.accelerate</code>.</li> </ul> <p>For a visual gallery of common presets and their shapes, see easings.net. In PyonFX, use their snake_case variants (e.g., <code>easeOutQuart</code> \u2192 <code>\"out_quart\"</code>).</p> <p>Leadout mirrors the idea (different control points, reverse easing, and fading out toward the end). See the full source at the end for the complete implementation.</p>"},{"location":"tutorials/3-advanced/01-frame-by-frame/#5-putting-it-together","title":"5. Putting it together","text":"<p>As in earlier tutorials, we keep effects modular (<code>leadin_effect</code>, <code>highlight_effect</code>, <code>leadout_effect</code>) and call them from a romaji processor using <code>Utils.all_non_empty(...)</code>. Save and preview as usual:</p> <pre><code>io.save()\nio.open_aegisub()\n</code></pre> <p></p>"},{"location":"tutorials/3-advanced/01-frame-by-frame/#conclusion","title":"Conclusion","text":"<p>You've built a frame-by-frame highlight with controlled jitter and colour transitions, then wrapped it with Bezier-based lead-in/out for a smooth entrance and exit. You now know how to:</p> <ul> <li>Iterate and render per frame with <code>FrameUtility</code></li> <li>Shape progress with <code>Utils.accelerate</code></li> <li>Interpolate colours/alpha with <code>FrameUtility.interpolate</code> (or <code>Utils.interpolate</code>)</li> <li>Use quadratic Beziers for smooth spatial motion</li> </ul> <p>In the next tutorial we'll get back to the Shape realm, but this time we'll use the text as a shape.</p>"},{"location":"tutorials/3-advanced/01-frame-by-frame/#full-source-code","title":"Full Source Code","text":"Show full source code <pre><code>\"\"\"\nTutorial: Frame-by-frame animations\n\nThis tutorial demonstrates how to build frame-by-frame effects using:\n\u2022 FrameUtility for iterating per-frame and easing progress\n\u2022 Quadratic Bezier curves (via the `bezier` library) for smooth motion paths\n\u2022 Color and alpha interpolation for subtle highlights and fades\n\nExercise:\n\u2022 Tweak Bezier control points to adjust the arc shape\n\u2022 Try different easing (e.g., \"in_quart\", \"out_cubic\") for entry/exit timing\n\u2022 Increase jitter amplitude or change color targets to vary highlight intensity\n\"\"\"\n\nimport random\n\nimport bezier\n\nfrom pyonfx import Ass, FrameUtility, Line, Syllable, Utils\n\nio = Ass(\"../../ass/romaji_kanji_translation.ass\", vertical_kanji=True)\nmeta, styles, lines = io.get_data()\n\n\n@io.track\ndef leadin_effect(line: Line, syl: Syllable, l: Line):\n    # Control points (start above-left, curve, end at syllable center)\n    x0, y0 = syl.center - 60.0, syl.middle - 20.0\n    x1, y1 = syl.center - 20.0, syl.middle - 50.0\n    x2, y2 = syl.center, syl.middle\n    curve = bezier.Curve([[x0, x1, x2], [y0, y1, y2]], degree=2)\n\n    # Frame-by-frame movement\n    fu = FrameUtility(\n        line.start_time - line.leadin // 2, line.start_time, meta.timestamps\n    )\n    for s, e, i, n in fu:\n        l.layer = 0\n        l.start_time = s\n        l.end_time = e\n\n        # Position (evaluate Bezier curve)\n        pct = Utils.accelerate(i / n, \"out_quart\")\n        curve_point = curve.evaluate(pct)\n        x, y = float(curve_point[0][0]), float(curve_point[1][0])\n\n        # Alpha (fade-in)\n        alpha = fu.interpolate(0, fu.duration, \"&amp;HFF&amp;\", \"&amp;H00&amp;\", \"out_quart\")\n\n        tags = rf\"\\an5\\pos({x:.3f},{y:.3f})\\alpha{alpha}\"\n        l.text = f\"{{{tags}}}{syl.text}\"\n\n        io.write_line(l)\n\n    # Static until syllable start\n    l.layer = 0\n    l.start_time = line.start_time\n    l.end_time = line.start_time + syl.start_time\n\n    tags = rf\"\\an5\\pos({syl.center:.3f},{syl.middle:.3f})\"\n    l.text = f\"{{{tags}}}{syl.text}\"\n    io.write_line(l)\n\n\n@io.track\ndef highlight_effect(line: Line, syl: Syllable, l: Line):\n    # Max amplitude\n    max_amp = 5.0\n\n    # Original style values\n    style_c1 = line.styleref.color1\n    style_c3 = line.styleref.color3\n\n    # Target values\n    target_c1 = \"&amp;HFFFFFF&amp;\"\n    target_c3 = \"&amp;HABABAB&amp;\"\n\n    fu = FrameUtility(\n        line.start_time + syl.start_time,\n        line.start_time + syl.end_time,\n        meta.timestamps,\n    )\n    for s, e, i, n in fu:\n        l.layer = 1\n        l.start_time = s\n        l.end_time = e\n\n        # Position (jitter)\n        amp = fu.add(0, fu.duration / 2, max_amp)\n        amp += fu.add(fu.duration / 2, fu.duration, -max_amp)\n        pos_x = syl.center + random.uniform(-amp, amp)\n        pos_y = syl.middle + random.uniform(-amp, amp)\n\n        # Color\n        t1_c1 = fu.interpolate(0, fu.duration / 2, style_c1, target_c1)\n        t1_c3 = fu.interpolate(0, fu.duration / 2, style_c3, target_c3)\n        t2_c1 = fu.interpolate(fu.duration / 2, fu.duration, t1_c1, style_c1)\n        t2_c3 = fu.interpolate(fu.duration / 2, fu.duration, t1_c3, style_c3)\n\n        tags = rf\"\\an5\\pos({pos_x:.3f},{pos_y:.3f})\\1c{t2_c1}\\3c{t2_c3}\"\n        l.text = f\"{{{tags}}}{syl.text}\"\n\n        io.write_line(l)\n\n\n@io.track\ndef leadout_effect(line: Line, syl: Syllable, l: Line):\n    # Static from syllable end until line end\n    l.layer = 0\n    l.start_time = line.start_time + syl.end_time\n    l.end_time = line.end_time\n    tags = rf\"\\an5\\pos({syl.center:.3f},{syl.middle:.3f})\"\n    l.text = f\"{{{tags}}}{syl.text}\"\n    io.write_line(l)\n\n    # Control points (start at syllable center, curve going downwards)\n    x0, y0 = syl.center, syl.middle\n    x1, y1 = syl.center - 20.0, syl.middle + 50.0\n    x2, y2 = syl.center - 60.0, syl.middle + 20.0\n    curve = bezier.Curve([[x0, x1, x2], [y0, y1, y2]], degree=2)\n\n    # Frame-by-frame movement after line end, fading out towards the end\n    fu = FrameUtility(line.end_time, line.end_time + line.leadout // 2, meta.timestamps)\n    for s, e, i, n in fu:\n        l.layer = 0\n        l.start_time = s\n        l.end_time = e\n\n        # Position (evaluate Bezier curve)\n        pct = Utils.accelerate(i / n, \"in_quart\")\n        curve_point = curve.evaluate(pct)\n        x, y = float(curve_point[0][0]), float(curve_point[1][0])\n\n        # Alpha (fade-out)\n        alpha = fu.interpolate(0, fu.duration, \"&amp;H00&amp;\", \"&amp;HFF&amp;\", \"in_quart\")\n\n        tags = rf\"\\an5\\pos({x:.3f},{y:.3f})\\alpha{alpha}\"\n        l.text = f\"{{{tags}}}{syl.text}\"\n\n        io.write_line(l)\n\n\n@io.track\ndef romaji(line: Line, l: Line):\n    for syl in Utils.all_non_empty(line.syls):\n        leadin_effect(line, syl, l)\n        highlight_effect(line, syl, l)\n        leadout_effect(line, syl, l)\n\n\n# Generating lines\nfor line in Utils.all_non_empty(lines):\n    l = line.copy()\n    if line.styleref.alignment &gt;= 7:\n        romaji(line, l)\n\nio.save()\nio.open_aegisub()\n</code></pre>"}]}